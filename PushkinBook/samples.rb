Array.new(5) { Array.new(4) { rand(0..9) } } # Создать массив 5 на 4 и заполнить весь массив абсолютно случайными значениями от 0 до 9.


[11, 22, 33, 44, 55].count(&:even?)   # С помощью указателя на функцию посчитать количество четных элементов в массиве
[0, 0, 1, 1, 0, 0, 1, 0].count { |x| x == 0} # использование метода .count для вычисления количества нулевых значений в массиве. Метод .count может принимать блок.

arr = [ [30, 1], [25, 0], [64, 1], [64, 0], [33, 1] ] # первый элемент каждого подмассива - возраст, второй элемент - пол(муж - 1, жен - 0)
arr.select { |element| element[0] == 64 && element[1] == 1} # выбираем мужчин в возрасте 64 лет (выбран 1 элемент)
arr.select { |element| element[1] == 1} # выбираем всех мужчин (выбрано 3 элемента)
arr.reject { |element| element[0] >= 27 } # отсеять всех  мужчин старше двадцати семи лет (и выслать остальным повестку в военкомат)

[11, 22, 33, 44, 55].take(2) # метод .take принимает параметр (число) и берет определенное этим параметром количество элементов в начале массива
[20, 34, 65, 23, 18, 44, 32].all? { |element| element >= 18 } # метод .all? позволяет убедиться что все элементы удовлетворяют требованиям (true если все значения больше или равны 18(лет))

[false, false, false, true, false].any? { |element| element == true } # метод .any? позволяет узнать есть ли в массиве хоть одно совпадение (в данном случае: true), и выведет в случае успеха - true, если нет - false)
[false, false, false, true, false].find_index { |element| element == true } # метод .find_index показываете индекс искомого элемента в массиве - 3, в данном случае

-------------------------------------------------------------------------------------------------------------------------------------------------
# Передача опций в методы
# Conventional method (обычный метод)
def total_weight(soccer_ball_count, tennis_ball_count, golf_ball_count)
  #...
end

x = total_weight(3, 2, 1)

# Хеш с параметрами, вызов этого метода без параметров выдаст ошибку
def total_weight(options)
  a = options[:soccer_ball_count]
  b = options[:tennis_ball_count]
  c = options[:golf_ball_count]
  puts a 
  puts b 
  puts c  
  #...
end

params = { soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1 }
x = total_weight(params)
--------------------------------------------------------------------------------

# Хеш с опциями по умолчанию
def total_weight(options={})
    a = options[:soccer_ball_count]
    b = options[:tennis_ball_count]
    c = options[:golf_ball_count]
    puts a 
    puts b 
    puts c  
    #...
  end

  x = total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1)
--------------------------------------------------------------------------------

# если в хеше options значение не указано (nil), то переменной будет присвоено значение "0", и ошибки не будет

def total_weight(options={})
    a = options[:soccer_ball_count] || 0
    b = options[:tennis_ball_count] || 0
    c = options[:golf_ball_count] || 0
    puts a 
    puts b 
    puts c  
    # (a * 410) + (b * 58) + (c * 45) + 29  # 29 - вес коробки
  end

  x = total_weight(soccer_ball_count: 3, tennis_ball_count: 2)
  puts x
--------------------------------------------------------------------------------
# пример применения метода initialize

class Car 
  def initialize
    puts 'hello from constructor!'
  end
end

car1 = Car.new

-------------------------------------------------------------------------------
# пример конструктора в JS
class Car {
  constructor() {
    console.log('hello from constructor!');
  }
}

let car1 = new Car();
-------------------------------------------------------------------------------
# пример тестов rspec: файл shipment_spec.rb

require './lib/shipment'                        # подключаем юнит
                                                # специальный синтаксис, который дословно говорит:
describe Shipment do                            # "описываем Shipment (отправление)"
  it 'should work without options' do           # специальный синтаксис, который дословно говорит: "это должно работать без опций". То что в кавычках - это строка, мы сами её пишем, слово "it" служебное.
    expect(Shipment.total_weight).to eq(29)     # ожидаем, что общий вес отправления будет равен 29 (eq от англ. "equal")
  end

  it 'should calculate shipment with only one item' do    # пример теста проверки для только одной вещи каждого вида в корзине
    expect(Shipment.total_weight(soccer_ball_count: 1)).to eq(410 + 29)
    expect(Shipment.total_weight(tennis_ball_count: 1)).to eq(58 + 29)
    expect(Shipment.total_weight(golf_ball_count: 1)).to eq(45 + 29)
  end

  it 'should calculate shipment with multiple items' do # пример теста проверки для нескольких вещей в корзине
    expect(
      Shipment.total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1)
    ).to eq(1420)
  end
end
-----------------------------------------------------------------------------------------------------------------
# Отложенная интерполяция
# использование eval
str = '#{name} - моё имя, а #{nation} - моя страна.'
name, nation = "Стивен Дедал", "Ирландия"
s1 = eval('"' + str + '"')
--------------------------------------------------------------------------------------------
# использование proc
str = proc do |name, nation|
  "#{name} - моё имя, а #{nation} - моя страна."
end
s2 = str.call("Гулливер Фойл", "Терра")
--------------------------------------------------------------------------------------------
# Символы
# Чаще всего символы применяются для определения атрибутов класса:
class MyClass
  attr_reader :alpha, :beat
  attr_writer :gamma, :delta
  attr_accessor :epsilon
  # ...
end
# применение символов
class SomeClass
  attr_accessor :whatever    # чтобы добавить в класс аттрибут, допускающий чтение и изменение
end
# это же можно выразить иначе
class SomeClass
  def whatever
    @whatever
  end
  def whatever=(val)
    @whatever = val 
  end
end
--------------------------------------------------------------------------------------------
# преобразование строки в символ и обратно с помощью методов to_str и to_sym
a = "foobar"
b = :foobar
a == b.to_str  # true
b == a.to_sym  # true
--------------------------------------------------------------------------------------------
# проверка принадлежности к диапазону с помощью метода include?
r1 = 23456..34567
x = 14142
y = 31416
r1.include?(x)  # false
r1.include?(y)  # true
--------------------------------------------------------------------------------------------
# преобразование диапазона в массив
r = 3..12
arr = r.to_a   # [3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
--------------------------------------------------------------------------------------------
# определение порядкового номера дня в году
t = Time.now
day = t.yday   # 146
--------------------------------------------------------------------------------------------
# как открывать файлы для чтениия и записи
file1 = File.new("one")         # Открыть для чтения
file2 = File.new("two", "w")    # Открыть для записи
-----------------------------------------------------------------------------
# закрытие файла с методом close
out = File.new("captains.log", "w")
  # обработка файла...
out.close

# Имеется также метод open. В простейшей форме это просто синоним new:
trans = File.open("transactions", "w")
-----------------------------------------------------------------------------
# автоматическое закрытие файла с методом open
File.open("somefile", "w") do |file|
  file.puts "Строка 1"
  file.puts "Строка 2"
  file.puts "Третья и последняя строка"
end
# теперь файл закрыт

# Метод reopen ассоциирует с объектом-получателем новый поток. В примере ниже мы отключаем запись на
# стандартный вывод для ошибок, а затем снова включаем:
save = STDERR.dup
STDERR.reopen("/dev/null")
# Работаем молча...
STDERR.reopen(save)

-----------------------------------------------------------------------------
# обновление файла
# чтобы открыть файл для чтения и записи, достаточно добавить знак (+) в строку задания режима
f1 = File.new("file1", "r+")
# Чтение/запись, от начала файла.

f2 = File.new("file2", "w+")
# Чтение/запись; усечь существующий файл или создать новый.

f3 = File.new("file3", "a+")
# Чтение/запись; перейти в конец существующего файла или создать новый.

# Дописывание в конец файла. Чтобы дописать данные в конец существующего файла, нужно указать строку
# задания режима "а" (см. раздел 10.1.1)
logfile = File.open("captains_log", "a")
# Добавить строку в конец и закрыть файл.
logfile.puts "Stardate 47824.1: Our show has been canceled."
logfile.close

# Прямой доступ к файлу
# Для чтения из файла в произвольном порядке, а не последловательно, можно воспользоваться методом seek,
# который класс File наследует от IO. Проще всего перейти на байт в указанной позициию Номер позиции
# отсчитывается от начала файла, причем самый первый байт находится в позиции 0
# myfile содержит строку: abcdefghi
file = File.new("myfile")
file.seek(5)
str = file.gets                       # "fghi"

# Если все строки в файле имеют одинаковую длину, то можно перейти сразу в начало нужной строки:
# Предполагается, что все строки имеют длину 20.
# Строка N начинается с байта (N-1)*20
file = File.new("fixedlines")
file.seek(5*20)                        # Шестая строка!

# Для выполнения относительного поиска воспользуйтесь вторым параметром.
# Константа IO::SEEK_CUR означает, что смещение задано относительно текущей позиции (и может быть отрицательным):
file = File.new("somefile")
file.seek(55)                          # Позиция 55
file.seek(-22, IO::SEEK_CUR)           # Позиция 33
file.seek(47, IO::SEEK_CUR)            # Позиция 80

# Можно также искать относительно конца файла, в таком случае смещение может быть только отрицательным:
file.seek(-20, IO::SEEK_END)           # двадцать байтов от конца файла

# Есть еще и третья константа IO::SEEK_SET, но это значение по умолчанию (поиск относительно начала файла).
# Метод tell возвращает текущее значение позиции в файле, у него есть синоним pos:
file.seek(20)
pos1 = file.tell                       # 20
file.seek(50, IO::SEEK_CUR)            
pos2 = file.pos                        # 70
# Метод rewind устанавливает указатель файла в начало. Его название восходит ко временам использования лент.
# Для выполнения прямого доступа файл часто открывается в режиме обновления (для чтения и записи). Этот 
# режим обозначается знаком + в начале строки задания режима (см. раздел 10.1.2)

# Работа с двоичными файлами.
# В двоичном режиме можно читать байты и производить над ними такие манипуляции, которые
# при наличии кодировки были бы недопустимымы:
File.write("invalid", "\xFC\x80 \x80\x80\xAF")
File.read("invalid", mode: "r").split(" ")
# invalid byte sequence in UTF-8 недопустимая последовательность байтов в UTF-8
File.read("invalid", mode: "rb").split(" ")
# ["\xFC\x80", "\x80\xAF"]

# В Windows двоичный режим означает также, что пару символов r\n\(возврат каретки и перевод строки),
# завершающую строку, не следует преобразовывать в один символ \n.
# Еще одно важное отличие - интерпретация символа Ctrl+Z как конца файла в текстовом режиме:
# myfile содержит "12345\0326789\r".
# Обратите внимание на восьмеричное 032 (^Z)
File.open("myfile", "rb") {|f| str = f.sysread(15) }.size       # 11
File.open("myfile", "r") {|f| str = f.sysread(15) }.size        # 5

# В следующем фрагменте показано, что на платформе Windows символ возврата каретки не преобразуется в двоичном режиме:
# Входной файл содержит всего одну строку: Строка 1.
file = File.open("data")
line = file.readline                # "Строка 1.\n"
puts "#{line.size} символов."       # 10 символов
file.close

file = File.open("data", "rb") 
line = file.readline                # "Строка 1.\r\n"
puts "#{line.size} символов."       # 11 символов
file.close

# Отметим, что упомянутый в коде метод binmode переключает поток в двоичный режим.
# После переключения вернуться в текстовый режим невозможно.
file = File.open("data")
file.binmode
line = file.readline                # "Строка 1.\r\n"
puts "#{line.size} символов."       # 11 символов
file.close

# При необходимости выполнить низкоуровневый ввод-вывод можно воспользоваться методами sysread и syswrite.
# Первый принимает в качестве параметра число подлежащих чтению байтов, второй принимает строку и возвращает число
# написанных байтов.
input = File.new("infile")
output = File.new("outfile")
instr = input.sysread(10);
bytes = output.syswrite("Это тест.")
# Отметим, что метод sysread возбуждает исключение EOFError при попытке вызвать его, когда достигнут
# конец файла (но не в том случае, когда конец файла встретился в ходе успешной операции чтения).
# Оба метода возбуждают исключение SystemCallError при возникновении ошибки ввода-вывода.
# При работе с двоичными данными могут оказаться полезны метод pack из класса Array и метод unpack из класса String.

# Блокировка файлов.
# В тех операционных системах, которые поддерживают такую возможность, метод flock класса File блокирует и разблокирует файл.
# Вторым параметром может быть одна из констант File::LOCK_EX, File::LOCK_NB, File::LOCK_SH, File::LOCK_UN 
# или их объединение с помощью оператора ИЛИ. Понятно, что многие комбинации не имеют смысла,
# чаще всего употребляется флаг, задающий неблокирующий режим.
file = File.new("somefile")

file.flock(File::LOCK_EX)                 # Монопольная блокировка; никакой другой
                                          # процесс не может обратиться к другому файлу.
file.flock(File::LOCK_UN)                 # Разблокировать.

file.flock(File::LOCK_SH)                 # Разделяемая блокировка (другие
                                          # процессы могут сделать то же самое).

file.flock(File::LOCK_UN)                 # Разблокировать.

locked = file.flock(File::LOCK_EX  File::LOCK_NB)
# Пытаемся заблокировать файл, но не приостанавливаем программу, если
# не получилось; в таком случае переменная locked будет равна false.

# Простой ввод-вывод. 
# Кроме методов gets, puts, print, printf и p, есть еще метод putc.
# Метод putc выводит один символ
# Если параметроа является объект String, то печатается первый символ строки.
putc(?\n)           # Вывести символ новой строки
putc("X")           # Вывести букву X

# Весь вывод, формируемыц методами из Kernel направляется в глобальную переменную $stdout
# Она инициализирована значением STDOUT, так что данные отправляются на стандартный вывод.
# В любой момент переменной $stdout можно присвоить другое значение, являющееся объектом IO.
diskfile = File.new("foofile", "w")
puts "Привет..."                     # Выводится на stdout
$stdout = diskfile
puts "Пока!"                         # выводится в файл "foofile"
diskfile.close
$stdout = STDOUT                     # восстановление исходного значения
puts "Это все."                      # выводится на stdout
# Помимо метода gets, в модуле Kernel есть также методы ввода readline и readlines.
# Первый аналогичен gets в том смысле, что возбуждает исключение EOFError при попытке читать за концом
# файла, а не просто возвращает nil. Последний эквивалентет методу IO.readlines(то есть считывает весь файл в память).
# Откуда мы получаем ввод? Есть переменная $stdin, которая по умолчанию равна STDIN. Точно также
# существует поток стандартного вывода для ошибок ($stderr, по умолчанию равен STDERR).
# Еще имеется интересный глобальный объект ARGF, представляющий конкатенацию всех файлов, указанных
# в командной строке. Это не объект класса File, хотя и напоминает таковой. По умолчанию ввод связан
# именно с этим объектом, если в командной строке задан хотя бы один файл.
# cat.rb
# Прочитать все файлы, а затем вывести их
puts ARGF.read
# А при таком способе более экономно расходуется память:
puts ARGF.readline until ARGF.eof?
# Пример: ruby cat.rb file1 file2 file3

# Чтение из стандартного ввода (STDIN) происходит в обход методов Kernel. 
# Поэтому можно обойти (или не обходить) ARGF, как показано ниже:
# Прочитать строку из стандартного ввода
str1 = STDIN.gets
# Прочитать строку из ARGF
str2 = ARGF.gets
# А теперь снова из стандартного ввода
str3 = STDIN.gets

# Существует возможность читать как на уровне символов, так и на уровне байтов. 
# В случае однобайтовой кодировки разница только в том, что байт имеет тип Fixnum, а символ - это односимвольная строка:
c = input.getc
b = input.getbyte
input.ungetc                     # Эти две операции не всегда
input.ungetbyte                  # возможны.
b = input.readbyte               # Как getbyte, но может возбуждать EOFError

# Буферизованный и небуферизованный ввод-вывод
# В некоторых случаях Ruby осуществляет буферизацию самостоятельно. Рассмотрим следующий фрагмент:
print "Привет..."
sleep 10
print "Пока!\n"
# Если запустить программу, то можно увидеть, что сообщения "Привет" и "Пока" появляются одновременно, 
# после завершения sleep. При этом первое сообщение не завершается символом новой строки.
# Это можно исправить, вызвав метод flush для опустошения буфера ввода.
# В данном случае вывод идет в поток $defout (подразумеваемый по умолчанию для всех методов Kernel,
# которые занимаются выводом). И поведение оказывается ожидаемым, т.е. первое сообщение появляется раньше второго.
print "Привет... "
STDOUT.flush
sleep 10
print "Пока!\n"
# Буферизацию можно отключить (или включить) методом sync=, а метод sync позволяет узнать текущее состояние.
buf_flag = $defout.sync           # true
STDOUT.sync = false
buf_flag = STDOUT.sync            # false
# Есть также еще по крайней мере один низкий уровень буферизации, который не виден. Если метод getc
# возвращает символ и продвигает вперед указатель файла или потока, то метод ungetc возвращает символ назад в поток.
ch = mystream.getc                # ?A
mystream.ungetc(?C)
ch = mystream.getc                # ?C
# Тут следует иметь ввиду три вещи. Во-первых, только что упомянутая буферизация не имеет отношения
# к механизму буферизации, о котором мы говорили выше в этом разделе. Иными словами, предложение
# sync=false не отключает ее. Во-вторых, вернуть в поток можно только один символ, при попытке вызвать
# метод ungetc несколько раз будте возвращен только символ, прочитанный последним. И, в-третьих, 
# метод ungetc не работает для принципиально небуфиризуемых операций (например, sysread).

# Манипулирование правами владения и разрешениями на доступ к файлу.
# Для определения владельца и группы файла (это целые числа), класс File::Stat предоставляет методы экземпляра uid и gid:
data = File.stat("somefile")
owner_id = data.uid
group_id = data.gid
# В классе File::Stat есть также метод экземпляра mode, который возвращает текущий набор разрешений для файла.
perms = File.stat("somefile").mode
# В классе File имеется метод класса и экземпляра chown, который позволяет изменить идентификаторы владельца и группы.
# Метод класса принимает произвольное число файлов. Если идентификатор не нужно изменять, можно передать nil или -1.
uid = 201
gid = 10
File.chown(uid, "alpha", "beta")
f1 = File.new("delta")
f1.chown(uid, gid)
f2 = File.new("gamma")
f2.chown(nil, gid)                        # Оставить идентификатор владельца без изменения
# Разрешения можно изменить с помощью метода chmod (у него есть два варианта: метод класса и метод экземпляра).
# Традиционно разрешения представляют восьмеричным числом, хотя это и не обязательно.
File.chmod(0644, "epsilon", "theta")
f = File.new("eta")
f.chmod(0444)
# Процесс всегда работает от имени какого-то пользователя (возможно, root), поэтому с ним связан идентификатор пользователя
# (мы сейчас говорим о действующем идентификаторе пользователя). Часто нужно знать, имеет ли этот пользователь право читать,
# писать или исполнять данный файл. В классе File::Stat есть методы экземпляра для получения такой информации.
info = File.stat("/tmp/secrets")
rflag = info.readable?
wflag = info.writable?
xflag = info.executable?
# Иногда нужно отличить действующий идентификатор пользователя от реального. На этот случай предлагаются методы экземпляра
# readable_real?, writable_real? и executable_real?.
info = File.stat("/tmp/secrets")
rflag2 = info.readable_real?
wflag2 = info.writable_real?
xflag2 = info.executable_real?
# Можно сравнить владельца файла с действующим идентификатором пользователя (и идентификатором группы) текущего процесса.
# В классе File::Stat для этого есть методы owned? и grpowned?.
# Отметим, что многие из этих методов можно найти также в модуле FileTest:
rflag = FileTest::readable?("pentagon_files")
# Прочие методы: writable? executable? readable_real?
# writable_real? executable_real? owned? grpowned?
# Отсутствую здесь: uid gid mode

# Маска umask, ассоциированная с процессомм, определяет начальные разрешения для всех созданных им файлов.
# Стандартные разрешения 0777 логически пересекаются (AND) с отрицанием umask, то есть биты, поднятые в маске, "маскируются"
# или сбрасываются. Если вам удобнее, можете представлять себе эту операцию как вычитание (без занимания).
# Следовательно, если задана маска 022, то все файлы создаются с разрешениями 0755.
# Получить или установить маску можно с помощью метода umask класса File. Если ему передан параметр, то он становится
# новым значением маски (при этом метод возвращает старое значение).
File.umask(0237)                       # Установить umask
current_umask = File.umask             # 0237
# Некоторые биты режима файла (например, бит фиксации (sticky bit)) не имеют прямого отношенияя к разрешениям.

# Получение и установка временных меток
# Ruby понимает три таких метки: время модификации, время доступа и время изменения. Получить эту информацию можно тремя разными способами.
# Методы mtime, atime и ctime класса File возвращают временные метки, не требуя предварительного открытия или даже создания объекта File.
t1 = File.mtime("somefile")
# Thu Jan 04 09:03:10 GMT-6:00 2001
t2 = File.atime("somefile")
# Thu Jan 09 10:03:34 GMT-6:00 2001
t3 = File.ctime("somefile")
# Sun Nov 26 23:48:32 GMT-6:00 2000

# Если файл, представленный экземпляром File, уже открыт, то можно воспользоваться методами этого экземпляра.
myfile = File.new("somefile")
t1 = myfile.mtime
t2 = myfile.atime
t3 = myfile.ctime
# А если имеется экземпляр класса File::Stat, то и у него есть методы, позволяющие получить ту же информацию:
myfile = File.new("somefile")
info = myfile.stat
t1 = info.mtime
t2 = info.atime
t3 = info.ctime
# Отметим, что объект File::Stat возвращается методом класса (или экземпляра) stat из класса File. Метод класса lstat
# (или одноименный метод экземпляра) делает то же самое, но возвращает информацию о состоянии самой ссылки, а не файла,
# на который она ведет. Если имеется цепочка из нескольких ссылок, то метод следует по каждой из них, кроме последней.
# Для изменения времени доступа и модификации применяется метод utime, которому можно передать несколько файлов.
# Время можно создать в виде объекта Time или числа секунд, прошедших с точки отсчета.
today = Time.now
yesterday = today - 86400
File.utime(today, today, "alpha")
File.utime(today, yesterday, "beta", "gamma")
# Поскольку обе временные метки изменяются одновременно, то при желании оставить одну без изменения, ее сначала следует получить и сохранить.
mtime = File.mtime("delta")
File.utime(Time.now, mtime, "delta")

# Проверка существования и получение размера файла
# Часто необходимо знать, существует ли файл с данным именем. Это позволяет выяснить метод exist? из модуля FileTest:
flag = FileTest::exist?("LochNessMonster")
flag = FileTest::exists?("UFO")
# exists? является синонимом exist?

# Чтобы узнать есть ли в файле какие-нибудь данные, можно использовать метод zero?
# Метод zero? возвращает true, если длина файла равна нулю, и false в противном случае.
flag = File.new("somefile").stat.zero?
# Метод size? возвращает либо размер файла в байтах, если он больше нуля, либо nil для файла нулевой длины.
# Не сразу понятно, почему nil а не 0. Дело в том, то метод предполагалось использовать в качестве предиката,
# а значение истинности нуля в Ruby - true, тогда для nil оно равно false.
if File.size?("myfile")
  puts "В файле есть данные."
else
  puts "Файл пуст."
end
# Далее возникает вопрос: "Каков размер файла?". Мы уже видели, что для непустого файла метод size?
# возвращает длину. Но, если мы применяем его не в качестве предиката, то значение nil только путает.
# В классе File  для ответа на этот вопрос есть как метод класса, так и метод экземпляра:
size1 = File.size?("filename")                  # возвращает 0, если файл filename пуст
# Чтобы получить размер файла в блоках, а не в байтах, можно обратиться к методу blocks из класса File::Stat.
# Результат, конечно, зависит от операционной системы. (Метод blksize сообщает размер блока операционной системы.)
info = File.stat("somefile")
total_bytes = info.blocks * info.blksize

# Опрос специальных свойств файла
# У файла есть много свойств, которые можно опросить. 
# В некоторых операционных системах устройства подразделяются на блочные и символьные. Файл может ссылаться
# как на то, так и на другое, но не на оба сразу. Методы blockdev? и chardev? из модуля FileTest проверяют тип устройства:
flag1 = FileTest::chardev?("/dev/hdisk0")   # false
flag2 = FileTest::blockdev?("/dev/hdisk0")  # true
# Иногда нужно знать, ассоциирован ли данный поток с терминалом. Метод tty? класса IO (синоним isatty) дает ответ на этот вопрос:
flag1 = STDIN.tty?                          # true
flag2 = File.new("diskfile").isatty         # false
# Поток может быть связан с каналом (pipe) или сокетом. В модуле FileTest есть методы для опроса этих условий:
flag1 = FileTest::pipe?(myfile)
flag2 = FileTest::socket?(myfile)
# Напомним, что каталог - это частный случай файла. Поэтому нужно уметь отличать каталоги от обычных файлов, 
# для чего предназначены следующие два метода:
file1 = File.new("/tmp")
file2 = File.new("tmp/myfile")
test1 = file1.directory?                    # true
test2 = file.file?                          # false
test3 = file2.directory?                    # false
test4 = file2.file?                         # true
# В классе File есть также метод класса ftype, который сообщает вид потока, одноименный метод экземпляра
# находится в классе File::Stat. Этот метода возвращает одну из следующих строк:file, directory, blockSpecial,
# characterSpecial, fifo, link или socket(строка fifo относится к каналу).
this_kind = File.ftype("/dev/hdisk0")       # "blockSpecial"
that_kind = File.new("/tmp").stat.ftype     # "directory"
# В маске, описывающей режим файла, можно устанавливать или сбрасывать некоторые биты. Они не имеют прямого
# отношения к битам, обсуждавшимся в разделе 10.1.9. Речь идет о битах set-group-id, set-user-id, и бите
# фиксации (sticky bit). Для каждого из них есть свой метод.
file = File.new("somefile")
sticky_flag = file.sticky?
setgid_flag = file.setgid?
setuid_flag = file.setuid?
# На дисковый файл могут вести символические или физические ссылки (в тех операционных системах, где такой
# механизм поддерживается). Чтобы проверить, является ли файл символической ссылкой на другой файл, обратитесь
# к методу symlink?. Для подсчета числа физических ссылок на файл служит метод nlink (он есть только в классе File::Stat).
# Физическая ссылка не отличима от обычного файла, это просто файл, для которого есть несколько имен и записей в каталоге.
File.symlink("yourfile", "myfile")             # Создать ссылку
is_sym = File.symlink?("myfile")               # true
hard_count = File.new("myfile").stat.nlink     # 0
# Отметим попутно, что в предыдущем примере мы воспользовались методом класса symlink из класса File
# для создания символической ссылки.
# В редких случаях может понадобиться информация о файле еще более низкого уровня. В классе File::Stat есть
# еще три метода экземпляра, представляющих такую информацию. Метод dev возвращает целое число, идентифицирующее
# устройство, на котором расположен файл. Метод rdev возвращает целое число, описывающее тип устройства, 
# а для дисковых файлов метод ino возвращает номер первого индексного узла, занятого файлом.
file = File.new("diskfile")
info = file.stat 
device = info.dev
devtype = info.rdev
inode = info.ino
------------------------------------------------------------------------------
# Каналы
# Ruby поддерживает разные способы читать из канала и писать в него. Метод класса IO.popen открывает канал
# и связывает с возвращенным объектом стандартные ввод и вывод процесса. Часто с разными концами канала работают
# разные потоки, но в примере ниже запись и чтение осуществляет один и тот же поток:
check = IO.popen("spell", "r+")
check.puts("T was brillig, and the slithy toves")
check.puts("Did gyre and gimble in the wabe.")
check.close_write
list = check.readlines
list.collect! { |x| x.chomp }
# list равно %w[brillig gimble gyre slithy toves wabe]
# Отметим, что вызов close_write обязателен, иначе мы никогда не достигнем конца файла при чтении из канала.
# Существует также блочная форма:
File.popen("/usr/games/fortune") do |pipe|
  quote = pipe.gets
  puts quote
  # На чистом диске можно искать бесконечно. - Том Стил
end
#  Если задана строка "-", то запускается новый экземпляр Ruby. Если при этом задан еще и блок, то он работает
# в двух разных процессах, как в результате разветвления (fork); блоку в процессе-потомке передается nil, 
# а в процессе-родителе объект iO, с которым связан стандартный ввод или стандартный вывод.
IO.popen("-") do |mypipe|
  if mypipe
    puts "Я родитель: pid = #{Process.pid}"
    listen = mypipe.gets
    puts listen
  else
    puts "Я потомок: pid = #{Process.pid}"
  end
end

# Печатается:
# Я родитель: pid = 10580
# Я потомок: pid = 10582

# Метод pipe возвращает также два конца канала, связанных между собой. В следующем примере мы создаем два потока,
# один из которых передает сообщение другому (то самое сообщение, которое Сэмьюел Морзе послал по телеграфу).
pipe = IO.pipe
reader = pipe[0]
writer = pipe[1]

str = nil
thread1 = Thread.new(reader,writer) do |reader,writer|
  # writer.close_write
  str = reader.gets
  reader.close
end

thread2 = Thread.new(reader,writer) do |reader,writer|
  # reader.close_read
  writer.puts("What hath God wrougth?")
  writer.close
end

thread1.join
thread2.join

puts str                 # What hath God wrought?

# Неблокирующий ввод-вывод
string = input.read(64)                    # читать 64 байта
buffer = ""
input.read(64, buffer)                     # необязательный буфер
# По достижении конца файла возбуждается исключение EOFError. Если возникло исключение EWOULDBLOCK, то
# в следующий раз метод можно вызывать только после того, как станут доступны данные. Например:
begin
  data = input.read_nonblock(256)
rescue Errno::EWOULDBLOCK
  IO.select([input])
  retry
end
# Аналогично метод write_nonblock обращается к системному вызову write(2) (и возбуждает соответствующие исключения).
# Он принимает в качестве аргумента строку и возвращает количество записанных байтов (которое может оказаться
# меньше длины строки). Исключение EWOULDBLOCK следует обрабатывать так же, как в случае описанного выше метода read_nonblock

# Применение метода readpartial
# Метод readpartial упрощает ввод-вывод в поток, например в сокет.
# Параметр "максимальная длина" (max length) обязателен. Если задан параметр buffer, то он должен ссылаться на строку, в которой будут храниться данные.
data = sock.readpartial(128)              # Читать не более 128 байтов

# Манипулирование путевыми именами
# Основными методами для работы с путевыми именами являются методы класса File.dirname и File.basename;
# они работают, как одноименные команды UNIX, то есть возвращают имя каталога и имя файла соответственно.
# Если вторым параметром методу basename передана строка с расширением имени файла, то это расширение исключается.
str = "/home/dave/podbay.rb"
dir = File.dirname(str)                     # "/home/dave"
file1 = File.basename(str)                  # "podbay.rb"
file2 = File.basename(str, ".rb")           # "podbay"
# Хотя это методы класса File, на самом деле они просто манипулируют строками.
# Упомянем также метод File.split, который возвращает обе компоненты (имя каталога и файла) в массиве из двух элеметов:
info = File.split(str)                      # ["/home/dave/","podbay.rb"]
# Метод класса expand_path преобразует относительное путевое имя в абсолютный путь.
# Если операционная система понимает сокращения ~ и ~user, то они тоже учитываются.
# Необязательный второй аргумент задает путь, начиная от которого следует производить расширение; часто
# в этом качестве указывают путь к текущему каталогу __FILE__.
Dir.chdir("/home/poole/personal/docs")
abs = File.expand_path("../../misc")                # "/home/poole/misc"
abs = File/expand_path("misc", "/home/poole")       # "/home/poole/misc"
# Если передать методу экземпляра path открытый файл, то он вернет путевое имя, по которому файл открыт.
File.new("../../foobar").path                       # "../../foobar"
# Константа File::Separator равна символу, применяемому для разделения компонентов путевого имени (в Windows
# это обратная косая черта, а в UNIX - прямая косая черта). Имеется синоним File::SEPARATOR
# Метод класса join использует этот разделитель для составления полного путевого имени из переданного списка компонентов:
path = File.join("usr", "local", "bin", "someprog")
# path равно "usr/local/bin/someprog"
# Обратите внимание, что в начале имени разделитель не добавляется!
# Не думайте, что методы File.join и File.split взаимно обратны. Это не так.

# Класс Pathname
# Следует знать о стандартной библиотеке pathname, которая предоставляет класс Pathname.
# По существу, это обертка вокруг классов Dir, File и FileUtils, поэтому он комбинирует многие их 
# функции логичным и интуитивно понятным способом.
path = Pathname.new("/home/hal")
file = Pathname.new("file.txt")
p2 = path + file

path.directory?                      # true
path.file?                           # false
p2.directory?                        # false
p2.file?                             # true

parts = path2.split                  # [Pathname:/home/hal, Pathname:file.txt]
ext = path2.etxname                  # .txt
# Также имеется ряд вспомогательных методов. Метод root? пытается выяснить, относится ли данный путь к корневому каталогу,
# но его можно "обмануть", так как он просто анализирует строку, не обращаясь к файловой системе.
# Метод parent? возвращает путевое имя родительского каталога данного пути. Метод children возвращает
# непосредственных потомков каталога, заданного своим путевым именем, в их число включаются как файлы,
# так и каталоги, но рекурсивного спуска не производится.
p1 = Pathname.new("//")              # странно, но допустимо
p1.root?                             # true
p2 = Pathname.new("/home/poole")
p3 = p2.parent                       # Путевое имя:/home
items = p2.children                  # массив объектов Pathname (все файлы и каталоги, находящиеся непосредственно в каталоге poole)
# Как и следовало ожидать, методы relative и absolute пытаются определить, является ли путь относительным
# или абсолютным (проверяя, есть ли в начале имени косая черта):
p1 = Pathname.new("/home/dave")
p1.absolute?                         # true
p1.relative?                         # false
# Многие методы. например size, unlink и прочие, просто делегируют работу классам File и FileUtils;
# повторно функциональность не реализуется.

# Манипулирование файлами на уровне команд
# Часто приходится манипулировать файлами так, как это делается с помощью командной строки: копировать, удалять и т.д.
# Многие из этих операций реализованы встроенными методами, некоторые находятся в модуле FileUtils из библиотеки fileutils.
# Имейте в виду, что раньше функциональность модуля FileUtils подмешивалась прямо в класс File, 
# теперь эти методы помещены в отдельный модуль.
# Для удаления файла служит метод File.delete или его синоним File.unlink:
File.delete("history")
File.unlink("toast")
# Переименовать файл позволяет метод File.rename:
File.rename("Ceylon", "SriLanka")
# Создать ссылку на файл (физическую или символическую) позволяют методы File.link и File.symlink соответственно:
File.link("/etc/hosts", "/etc/hostfile")                   # физическая ссылка
File.symlink("/etc/hosts", "/tmp/hosts")                   # символическая ссылка
# Файл можно усечь до нулевой длины (или до любой другой), воспользовавшись методом экземпляра truncate:
File.truncate("myfile", 1000)                # Теперь не более 1000 байтов
# Два файла можно сравнить с помощью метода compare_fille. У него есть синонимы cmp и compare_stream:
require "fileutils"

same = FileUtils.compare_file("alpha", "beta")      # true
# Метод copy копирует файл в другое место, возможно, с переименованием. У него есть необязательный файл, 
# говорящий, что сообщения об ошибках нужно направлять на стандартный вывод для ошибок. Синоним - привычное
# для программистов UNIX имя cp.
require "fileutils"

# Скопировать файл epsilon в theta с протоколированием ошибок.
FileUtils.copy("epsilon", "theta", true)
# Файл можно перемещать методом move (синоним mv). Как и copy, этот метод имеет необязательный параметр, включающий вывод сообщений об ошибках.
FileUtils.move("/tmp/names", "/etc")                # Переместить в другой каталог
FileUtils.move("colours", "colors")                 # Просто переименовать

# Метод safe_unlink удаляет один или несколько файлов, предварительно пытаясь сделать их доступными
# для записи, чтобы избежать ошибок. Если последний параметр равен true или false, он интерпретируется как флаг,
# задающий режим вывода сообщений об ошибках.
require "fileutils"

FileUtils.safe_unlink("alpha", "beta", "gamma")
# Протоколировать ошибки при удалении следующих двух файлов
FileUtils.safe_unlink("delta", "epsilon", true)

# Наконец, метод install делает практически то же, что syscopy, но снаала проверяет, что целевой файл либо
# не существует, либо содержит такие же данные.
require "fileutils"

FileUtils.install("foo.so", "/usr/lib")
# Существующий файл foo.so не будет перезаписан, если он не отличается от нового.

# Ввод символов с клавиатуры
# В данном случае мы имеем в виду небуферизованный ввод, когда символ обрабатывается сразу после нажатия клавиши,
# не дожидаясь, пока будет введена вся строка.
# Это можно сделать и в UNIX, и в Windows, но, к сожалению, совершенно по разному.
# Версия для UNIX прямолинейна. Мы переводим терминал в режим прямого ввода (raw mode) и обычно одновременно отключаем эхо-контроль.
def getchar
  system("stty raw -echo")         # Прямой ввод без эхо-контроля
  char = STDIN.getc
  system("stty -raw echo")         # Восстановить режим терминала
  char
end

------------------------------------------------------------------------------
# простейшее Rack-приложение на основе класса
class MyRackApp
  def call(env)
    [200, {'Content-type' => 'text/plain'}, ["Welcome to Rack!"]]
  end
end

# Предполагается приведенное выше определение
app = MyRackApp.new
run app
-----------------------------------------------------------------------------
# определение размера массива с методами length и size
x = ["a", "b", "c", "d"]
a = x.length              # 4
b = x.size                # 4

# Сравнение массивов
# Массивы сравниваются поэлементно, первая же пара несовпадающих элементов определяет результат для сравнения (-1 или 0 или 1)
a = [1, 2, 3, 9, 9]
b = [1, 2, 4, 1, 1]
c = a <=> b                # -1 (то есть a < b)

# Сортировка массив в помощью метода sort
words = %w(the quick brown fox)
list = words.sort     # ["brown", "fox", "quick", "the"]
# Или отсортировать на месте
words.sort!           # ["brown", "fox", "quick", "the"]

# В подобных случаях можно воспользоваться также блочной формой того же метода (если у каждого элемента есть метод to_s):
a = [1, 2, "three", "four", 5, 6]
b = a.sort { |x,y| x.to_s <=> y.to_s}
# b равно [1, 2, 5, 6, "four", "three"]

# Чтобы отсортировать массив в порядке убывания, достаточно просто изменить порядок сравнения:
x = [1, 4, 3, 5, 2]
y = x.sort { |a,b| b <=> a}         # [5, 4, 3, 2, 1]


------------------------------------------------------------------------------
# использование метода grep для сопоставления
a = %w[January February March April May]
a.grep(/ary/)       # ["January", "February"]
b = [1, 20, 5, 7, 13, 33, 15, 28]
b.grep(12..24)      # [20, 13, 15]
------------------------------------------------------------------------------
# Продолжение предыдущего примера...
# Будем сохранять длины строк
a.grep(/ary/) {|m| m.length}    # [7, 8]
# Будем сохранять квадраты исходных элементов
b.grep(12..24) {|n| n*n}        # {400, 169, 225}

# Метод reject - полная противоположность select
# Он исключает из массива элементы, для которых блоок возвращает значение true
# Имеется также вариант reject! для модификации массива "на месте":
c = [5, 8, 12, 9, 4, 30]
d = c.reject { |e| 3 % 2 == 0 }        # [5, 9]
c.reject! { |e| e % 3 == 0 }
# c равно [5, 8, 4]

# Методы min и max ищут минимальное и максимальное значение в массиве
a = %w[Eldond Galadriel Aragorn Saruman Legolas]
b = a.min                                 # "Aragorn"
c = a.max                                 # "Saruman"
d = a.min {|x,y| x.reverse <=> y.reverse} # "Elrond"
e = a.max {|x,y| x.reverse <=> y.reverse} # "Legolas"

# Чтобы найти индекс минимального или максимального элемента используется метод index
# Продолжение предыдущего примера...
i = a.index a.min    # 2
j = a.index a.max    # 3

------------------------------------------------------------------------------
# Разбиение строки на лексемы. Метод split разбивает строку на части и возвращает массив лексем.
s1 = "Была темная грозовая ночь"
words = s1.split                    # ["Была", "темная", "грозовая", "ночь"]

s2 = "яблоки, груши, персики"
list = s2.split(", ")               # ["яблоки", "груши", "персики"]

s3 = "львы и тигры и медведи"
zoo = s3.split(/ и /)             # ["львы", "тигры", "медведи"]
------------------------------------------------------------------------------
# controlling Uppercase and Lowercase
s1 = "Boston Tea Party"
s2 = s1.downcase            # "boston tea party"
s3 = s2.upcase              # "BOSTON TEA PARTY"

# the capitalize method capitalizes the first character of a string while forcing all the remaining characters to lowercase
s4 = s1.capitalize          # "Boston tea party"
s5 = s2.capitalize          # "Boston tea party"
s6 = s3.capitalize          # "Boston tea party"

# the swapcase method exchanges the case of each letter in a string
s7 = "THIS IS AN ex-parrot."
s8 = s7.swapcase            # "this is an EX-PARROT."
-----------------------------------------------------------------------------
# конкатенация строк с оператором <<
str = "A"
str << [1, 2, 3].to_s << " " << (3.14).to_s
# str теперь равно "A123 3.14"
-----------------------------------------------------------------------------

# получение длины строки
str1 = "Карл"
x = str1.length   # 4
str2 = "Дойль"
x = str2.size     # 5
-----------------------------------------------------------------------------
# Построчная обработка
str = "Когда-то\nдавным-давно...\nКонец\n"
num = 0
str.each_line do |line|
    num += 1
    print "Строка #{num}: #{line}"
end

# результат...
# Строка 1: Когда-то
# Строка 2: давным-давно...
# Строка 3: Конец
-----------------------------------------------------------------------------
# побайтовая обработка
str = "ABC"
str.each_byte { |byte| print byte, " "}
puts
# результат 65 66 67
-----------------------------------------------------------------------------
# подсчет числа определенных символов в строке
s1 = "abracadabra"
a = s1.count("c")     # 1
b = s1.count("bdr")   # 5

c = s1.count("^a")    # 6
d = s1.count("^bdr")  # 6

e = s1.count("a-d")   # 9
f = s1.count("^a-d")  # 2
-----------------------------------------------------------------------------
# обращение строки
s1 = "Star Trek"
s2 = s1.reverse          # "kerT ratS"
s1.reverse!              # s1 теперь равно "kerT ratS"

# обращение порядка слов, а не символов
phrase = "Now here's a sentence"
phrase.split(" ").reverse.join(" ")   # "sentence a here's Now"
-----------------------------------------------------------------------------
# Удаление дубликатов. Цепочки повторящихся символов можно сжать до одного методом squeeze
s1 = "bookkeeper"
s2 = s1.squeeze      # "bokeper"
s3 = "Hello..."
s4 = s3.squeeze      # "Helo."
# Если указан параметр, то будут удаляться только дубликаты заданных в нем символов
s5 = s3.squeeze(".") # "Hello."
-----------------------------------------------------------------------------
# Удаление заданных символов
s1 = "To be, or not to be"
s2 = s1.delete("b")           # "To e, or not to e"
s3 = "Veni, vidi, vici!"      
s4 = s3.delete(",!")          # "Veni vidi vici"
-----------------------------------------------------------------------------
# Generating Successive Strings Генерирование последовательности строк
droid = "R2D2"
improved = droid.succ            # "R2D3"
pill = "Vitamin B"
pill2 = pill.succ                # "Vitamin C"
-----------------------------------------------------------------------------
# Вычленение и замена подстрок
str = "Шалтай-Болтай"
sub1 = str[7,4]                # "Болт"
sub2 = str[7,99]               # "Болтай" (выход за границу строки допускается)
sub3 = str[10,-4]              # nil (отрицательная длина)
# если индекс отрицательный, то отсчет ведется от конца строки (в этом случае индекс начинается с единицы, а не с нуля)
str1 = "Алиса"
sub1 = str1[-3, 3]             # "иса"
str2 = "В Зазеркалье"         
sub3 = str2[-8, 6]             # "зеркал"

# Можно задавать диапазон. Он интерпретируется как диапазон позиций внутри строки
str = "Уинстон Черчилль"
sub1 = str[8..13]       # "Черчил"
sub2 = str[-4..-1]      # "илль"
sub3 = str[-1..-4]      # nil
sub4 = str[25..30]      # nil

# Если задано регулярное выражение, то возвращается строка по образцу, если нет соответствия, то nil
str = "Alistair Cooke"
sub1 = str[/l..t/]      # "list"
sub2 = str[/s.*r/]      # "stair"
sub3 = str[/foo/]       # nil

# Если задана строка, то она и возвращается, если встречается в качестве подстроки в исходной строке, в противном случае возвращается nil
str = "theater"
sub1 = str['heat']      # "heat"
sub2 = str["eat"]       # "eat"
sub3 = str["ate"]       # "ate"
sub4 = str["beat"]      # nil
sub5 = str["cheat"]     # nil

str = "Aaron Burr"
ch1 = str[0]            # "A"
ch2 = str[1]            # "a"
ch3 = str[99]           # nil

# важно понимать, что все описанные выше способы могут использоваться не только для досупа к построке, но, и для ее замены
str1 = "Шалтай-Болтай"
str1[7,3] = "Хва"                         # "Шалтай-Хватай"

str2 = "Алиса"
str2[-3,3] = "ександра"                   # "Александра"

str3 = "В Зазеркалье"
str3[-9, 9] = "стеколье"                  # "В Застеколье"

str4 = "Уинстон Черчилль"
str4[8..11] = "Х"                         # "Уинстон Хилль"

str5 = "Alistair Cooke"
str[/e$/] = "ie Monster"                  # "Alistair Cookie Monster"

str6 = "theater"
str6["er"] = "re"                         # "theatre"

str7 = "Aaron Burr"
str7[0] = "B"                             # "Baron Burr"
# присваивание выражения, равного nil, не оказывает никакого действия

------------------------------------------------------------------------------
# метод sub заменяет первое вхождение строки, соответствующей образцу другой строкой или результатом вычисления блока
s1 = "spam, spam, and eggs"
s2 = s1.sub(/spam/, "bacon")
# "bacon, spam, and eggs"

s3 = s2.sub(/(\w+), (\w+),/,'\2, \1,')
# "spam, bacon, and eggs"

s4 = "Don't forget the spam."
s5 = s4.sub(/spam/) { |m| m.reverse }
# "Don't forget the maps"

s4.sub!(/spam/) { |m| m.reverse }
# s4 is now "Don't forget the maps."

# метод gsub (глобальная подстановка) отличается от sub тем, что заменяет все вхождения, а не только первое
s5 = "alfalfa abracadabra"
s6 = s5.gsub(/a[bl]/, "xx")        # "xxfxxfa xxracadxxra"
s5.gsub!(/[lfdbr]/) { |m| m.upcase + "-" }
# s5 теперь равно "aL-F-aL-F-a aB-R-acaD-aB-R-a"
-----------------------------------------------------------------------------
# поиск в строке
# метод index возвращает начальную позицию заданной построки, символа или регулярного выражения
str = "Albert Einstein"
pos1 = str.index(?E)            # 7
pos2 = str.index("bert")        # 2
pos3 = str.index(/in/)          # 8
pos4 = str.index(?W)            # nil
pos5 = str.index("bart")        # nil
pos6 = str.index(/wein/)        # nil

# метод rindex начинает поиск с конца строки, но, номера позиций отсчитываются, тем не менее, от начала
str = "Albert Einstein"
pos1 = str.rindex(?E)          # 7
pos2 = str.rindex("bert")      # 2
pos3 = str.rindex(/in/)        # 13 (найдено самое правое соответствие)
pos4 = str.rindex(?W)          # nil
pos5 = str.rindex("bart")      # nil
pos6 = str.rindex(/wein/)      # nil

# метод include? сообщает, встречается ли в данной строке указанная подстрока или один символ

str1 = "mathematics"
flag1 = str1.include? ?e       # true
flag2 = str1.include? "math"   # true
str2 = "Daylight Saving Time"
flag3 = str2.include? ?s       # false
flag4 = str2.include? "Savings" # false

# метод scan многократно просматривает строку в поисках указанного образца
# будучи вызван внутри блока, он возвращает массив
# если образец содержит несколько (заключенных в скобки) групп, то массив окажется вложенным
str1 = "abracadabra"
sub1 = str1.scan(/a./)
# sub1 теперь рано ["ab","ac","ad","ab"]
str2 = "Acapulco, Mexico"
sub2 = str2.scan(/(.)(c.)/)
# sub2 теперь равно [ ["A", "ca"], ["l", "co"], ["i", "co"]]

# если при вызове задан блок, то метод поочередно передает этому блоку найденные значения
str3 = "Kobayashi"
str3.scan(/[^aeiou]+[aeiou]/) do |x|
  print "Слог: #{x}\n"
end
# код выше выведет такой результат:
Слог: Ko 
Слог: ba 
Слог: ya 
Слог: shi 
-------------------------------------------------------------------------------
# Преобразование символов в коды ASCII и обратно
# одиночные символы в Ruby возвращаются в виде односимвольных строк:
str = "Martin"
print str[0]          # "M"

# В классе Integer имеется метод chr, который преобразует целое число в символ
# в классе String имеется метод ord, выполняющий противоположное действие.
str = 77.chr          # "M"
s2 = 233.chr("UTF-8") # "e"
num = "M".ord         # 77

-------------------------------------------------------------------------------
# Удаление хвостовых символов новой строки и прочих
# Метод chop удаляет последний символ строки (\n) и символ перевода каретки (\r) если он стоит перед ним.
str = gets.chop            # Прочитать, удалить символ новой строки
s2 = "Some string\n"       # "Some string" (нет символа новой строки)
s3 = s2.chop!              # s2 теперь тоже равно "Some string"
s4 = "Other string\r\n"    
s4.chop!                   # "Other string" (нет символа новой строки)
# при вызове варианта chop! операнд-источник модифицируется

# важно отметить, что при использовании метода chop последний символ удаляется даже если это не символ новой строки
str = "abcxyz"
s1 = str.chop              # "abcxy"

# поскольку символ новой строки присутствует не всегда, иногда удобнее применять метод chomp
str = "abcxyz"
str2 = "123\n"
str3 = "123\r"
str4 = "123\r\n"
s1 = str.chomp             # "abcxyz"
s2 = str2.chomp            # "123"
# если установлен стандартный разделитель записей, то удаляется не только \n, но также \r и \r\n
s3 = str3.chopm            # "123"
s4 = str4.chomp            # "123"

# если методу chomp передана строка-параметр, то удаляются перечисленные в ней символы, а не подразумеваемый по умолчанию разделитель записей
str1 = "abcxyz"
str2 = "abcxyz"
s1 = str1.chomp("yz")      # "abcx"
# кстати, если разделитель записей встречается в середине строки, то он удаляется:
s2 = str2.chomp("x")       # "abcxyz"
-----------------------------------------------------------------------------------
# Убирание лишних пропусков (пробелов, символов табуляции и перехода на новую строку)
# Метод strip удаляет пропуски в начале и в конце строки, а вариант strip! делает то же самое "на месте"
str1 = "\t \nabc \t\n"
str2 = str1.strip          # "abc"
str3 = str1.strip!         # "abc"
# str1 теперь тоже равно "abc"

# чтобы удалить пропуски только в начале или только в конце строки, применяются методы lstrip и rstrip
str = " abc "
s2 = str.lstrip            # "abc "
s3 = str.rstrip            # " abc"
# имеются также варианты lstrip! и rstrip! для удаления "на месте".
-----------------------------------------------------------------------------------
# Повтор строк
# Если строку умножить на n, то получится строка, состоящая из n конкатенированных копий исходной:
etc = "Etc. " * 3          # "Etc. Etc. Etc. "
ruler = "+" + ("." * 4 + "5" + "." * 4 + "+") * 3
# "+....5....+....5....+....5....+"
-----------------------------------------------------------------------------------
# Включение выражений в строку с помощью синтаксической конструкции #{}
# Нет нужды думать о преобразовании, добавлении и конкатенации, нужно лишь интерполировать переменную или выражение в любое место строки:
puts "#{temp_f} по Фаренгейту равно #{temp_c} по Цельсию"
puts "Значение определителя равно #{b*b - 4*a*c}."
puts "#{word} это #{word.reverse} наоборот"

# Внутри фигурных скобок могут находиться даже полные предложения. При этом возвращается результат вычисления последнего выражения
str = "Ответ равен #{ def factorial(n)
                        n == ? 1 : n*factorial(n-1)
                      end

                      answer = factorial(3) * 7}, of course."
# Ответ равен 42, естественно.

# При интерполяции глобальных переменных, а также переменных класса и экземпляра фигурные скобки можно опускать:
puts "$gvar = #$gvar и ivar = #@ivar."
----------------------------------------------------------------------------------
# Возведение в степень обозначается оператором **, эта операция подчиняется обычным математическим правилам.
a = 64**2          # 4096
b = 64**0.5        # 8.0
c = 64**0          # 1
d = 64**-1         # 0.015625

# При делении одного целого числа на другое в Ruby дробная часть отбрасывается
# если один и операндов с плавающей точкой, то результат также будет с плавающей точкой
3 / 3              # 1
5 / 3              # 1
3 / 4              # 0
3.0 / 4            # 0.75
3 / 4.0            # 0.75
3.0 / 4.0          # 0.75

# Если вы работаете с переменными и сомневаетесь относительно их типа, воспользуйтесь приведением типа к Float или методом to_f:
z = x.to_f / y
z = Float(x) / y
-----------------------------------------------------------------------------------------------
# Округление чисел с плавающей точкой
# Метод round округляет число с плавающей точкой до целого:
pi = 3.14159
new_pi = pi.round        # 3
temp = -47.6
temp2 = temp.round       # -48

# В случае, когда надо округлить не до целого, а до заданного числа знаков после запятой, можно воспользоваться
# функциями sprintf (которая умеет округлять) и eval
pi = 3.1415926535
pi6 = eval (sprintf("%8.6f",pi))       # 3.141593
pi5 = eval (sprintf("%8.5f",pi))       # 3.14159
pi4 = eval (sprintf("%8.4f",pi))       # 3.1416
# Это не слишком красиво. Поэтому инкапсулируем оба вызова функций в метод, который добавим в класс Float:
class Float

  def roundf(places)
    temp = self.to_s.length
    sprintf("%#{temp}.#{places}f",self).to_f
  end

end
--------------------------------------------------------------------------------------
# Диапазоны
# Открытые и замкнутые диапазоны
# Диапазон называют замкнутым, если он включает конечную точку и открытым, в противном случае
r1 = 3..6       # замкнутый
r2 = 3...6      # открытый
a1 = r1.to_a    # [3,4,5,6]
a2 = r2.to_a    # [3,4,5]
# нельзя сконструировать диапазон, который не включал бы начальную точку. Можно считать это ограничением языка Ruby.

# Нахождение границ диапазона
# Методы first и last возвращают соответственно левую и правую границу диапазона. У них есть синонимы begin и end
r1 = 3..6
r2 = 3...6
r1a, r1b = r1.first, r1.last        # 3, 6
r1c, r1d = r1.begin, r1.end         # 3, 6
r2a, r2b = r1.begin, r1.end         # 3, 6

# метод exclude_end? сообщает, включена ли в диапазон конечная точка:
r1.exclude_end?   # false
r2.exclude_end?   # true

# обход диапазона:
(3..6).each { |x| puts x}           # печатаются четыре строки
                                    # скобки обязательны
# Проверка принадлежности к диапазону
r1 = 23456..34567
x = 14142
y = 31416
r1.include?(x)              # false
r1.include?(y)              # true
# у этого метода есть также синоним member?

# Преобразование в массив
r = 3..12
arr = r.to_a    # [3,4,5,6,7,8,9,10,11,12]

# Обратные диапазоны
r = 6..3
x = r.begin                 # 6
y = r.end                   # 3
flag = r.end_excluded?      # false
------------------------------------------------------------------------------------------
# Определение текущего момента времени
t0 = Time.new 
# Синонимом служит Time.now
t0 = Time.now

------------------------------------------------------------------------------------------
# Определение дня недели
# Способ с методом to_a. Можно обратиться к седьмому элементу массива (от 0 до 6), который соответствует дню недели (0 - воскресенье, а 6 - суббота)
time = Time.now
day = time.to_a[6]          # 2 (вторник)
# Еще лучше воспользоваться методом экземпляра wday:
day = time.wday             # 2 (вторник)
# Но оба вышеописанные методы не очень удобны. Есть еще один метод - strftime, который распознает около 20 спецификаторов
# позволяя по-разному форматировать дату и время
day = time.strftime("%A")        # "Tuesday"
# можно получить и сокращенное название
tln = time.strftime("%a")       # "Tue"

# Определение порядкового номера дня в году:
t = Time.now
day = t.yday                    # 315

# Определение часового пояса
z1 = Time.gm(2000,11,10,22,5,0).zone            # "UTC"
z2 = Time.local(2000,11,10,22,5,0).zone         # "PST"

# Прибавление интервала к моменту времени
t0 = Time.now
t1 = t0 + 60       # Ровно одна минута с момента t0
t2 = t0 + 3600     # Ровно один час с момента t0
t3 = t0 + 86400    # Ровно один день с момента t0

# можно вычислить интервал между двумя моментами времени
# в результате вычитания одного объекта Time из другого получаем количество секунд:
today = Time.local(2014,11,10)
yesterday = Time.local(2014,11,9)
diff = today - yesterday                  # 86400 секунд

# Преобразование часовых поясов, в случае если заранее известна разница во времени:
mississipi = Time.local(2014,11,13,9,35)        # 9:35 am CST
calofornia = mississipi - 2*3600                # Минус два часа

time1 = mississipi.strftime("%X CST")           # 09:35:00 CST
time2 = california.strftime("%X PST")           # 07:35:00 PST

# Если нужно часто преобразовывать время из одного часового пояса в другой, то можно воспользоваться
# расширением класса Time, предоставляемое gem-пакетом ActiveSupport
require 'active_support/time'
Time.zone = -8
Time.zone.name          # "Тихоокеанское время (США и Канада)"
Time.zone.now           # Wed, 25 Jun 2014 12:20:35 PDT -07:00
Time.zone.now.in_time_zone("Hawaii")  # 09:20:36 HST -10:00
----------------------------------------------------------------------------------------
# Выборка массива по заданному критерию
# Метод detect находит не больше одного элемента. Он принимает блок (которому элементы передаются последовательно)
# и возвращает первый элемент, для которого значение блока оказывается равным true
x = [5, 8, 12, 9, 4, 30]
# найти первый элемент, кратный 6
x.detect { |e|  e % 6 == 0}           # 12
# найти первый элемент, кратный 7
x.detect { |e| e % 7 == 0}           # nil

# Метод find - синоним detect, метод find_all возвращает несколько элементов, а не один единственный,
# а select - синоним find_all
# Продолжение предыдущего примера...
x.find { |e| e % 2 == 0}           # 8
x.find_all { |e| e % 2 == 0}       # [8, 12, 4, 30]
x.select { |e| e % 2 == 0}         # [8, 12, 4, 30]

# Массивы. Объединение и пересечение (операторы | (или) и &)
a = [1, 2, 3, 4, 5]
b = [3, 4, 5, 6, 7]
c = a | b                   # [1, 2, 3, 4, 5, 6, 7]
d = a & b                   # [3, 4, 5]

# Дубликаты удаляются...
e = [1, 2, 2, 3, 4]
f = [2, 2, 3, 4, 5]
g = e & f                   # [2, 3, 4]

# Для объединения множеств можно использовать и оператор конкатенации (+),
# но он не удаляет дубликаты
# Метод (-) позволяет удалить все одинаковые элементы множеств и оставить только те, которые не повторялись
a = [1, 2, 3, 4, 5]
b = [4, 5, 6, 7]
c = a - b                 # [1, 2, 3]
# Отметим, что наличие элементов 6 и 7 не отражается на результате

# Чтобы проверить входит ли некий элемент в множество, пользуйтесь методом include? или member?
x = [1, 2, 3]
if x.include? 2
  puts "yes"              # Печатается "yes"
else
  puts "no"
end
# Еще вариант:
class Object

  def in(other)
    other.include? self
  end

end

x = [1, 2, 3]
if 2.in x 
  puts "yes"              # Печатается "yes"
else
  puts "no"
end
---------------------------------------------------------------------------------------------------------
# Рандомизация массива
# Чтобы поставить элементы массива в случайном порядке можно воспользоваться методом shuffle:
x = [1, 2, 3, 4, 5]
y = x.shuffle               # [3, 2, 4, 1, 5]
x.shuffle!                  # x равно [3, 5, 4, 1, 2]

# Выбрать случайный элемент массива можно с помощью метода sample:
x = [1, 2, 3, 4, 5]
x.sample                    # 4
x.sample(2)                 # [5, 1]

# Удаление элементов, равных nil из массива
# Метод compact (и его вариант compact! для модификации на месте) удаляет из массива элементы, равные nil, оставляя все остальные без изменения:
a = [1, 2, nil, 3, nil, 4, 5]
b = a.compact                 # [1, 2, 3, 4, 5]
a.compact!                    # a равно [1, 2, 3, 4, 5]

# Удаление заданных элементов из массива
# Чтобы удалить элемент с известным индексом, достаточно вызвать метод delete_at:
a = [10, 12, 14, 16, 18]
a.delete_at(3)                # Возвращает 16
# a равно [10, 12, 14, 18]
a.delete_at(9)                # Возвращает nil (вне диапазона)

# Все элементы с заданным значением поможет удалить метод delete
# Он возвращает значения удаленных элементов или nil, если искомый элемент не найден:
b = %w(spam spam bacon spam eggs ham spam)
b.delete("spam")                           # Возвращает "spam"
# b равно ["bacon", "eggs", "ham"]
b.delete("caviar")                         # Возвращает nil

# Метод delete принимает также блок. Это не вполне согласуется с интуицией; если объект не найден, происходит
# вычисление блока (при этом могут выполняться различные операции) и возвращается вычисленное значение.
c = ["alpha", "beta", "gamma", "delta"]
c.delete("delta") { "Nonexistent"}
# Возвращается "delta" (блок не вычисляется)
c.delete("omega") { "Nonexistent"}
# Возвращается "Nonexistent"

# Метод delete_if передает каждый элемент массива в блоок и удаляет те элементы
# для которых вычисление блока дает true
email = ["job offer", "greetings", "spam", "news items"]
# удалить слова из четырех букв
email.delete_if { |x| x.length == 4 }
# email равно ["job offers", "greetings", "news items"]

# Метод slice! получает доступ к тем же элементам, что и slice, но, помимо
# возврата их значений, еще и удаляет из массива:
x = [0, 2, 4, 6, 8, 10, 12, 14, 16]
a = x.slice!(2)                       # 4
# x равно [0, 2, 6, 8, 10, 12, 14, 16]
b = x.slice!(2, 3)                    # [6, 8, 10]
# x равно [0, 2, 12, 14, 16]
c = x.slice!(2..3)                    # [12, 14]
# x равно [0, 2, 16]

# Для удаления элементов массива можно также пользоваться методами shift и pop
x = [1, 2, 3, 4, 5]
x.pop                                 # Удалить последний элемент
# x равно [1, 2, 3, 4]
x.shift                               # Удалить первый элемент
# x равно [2, 3, 4]

# Метод reject принимает блок и формирует новый массив без тех элементов, для которых блок возвращает true:
arr = [1, 2, 3, 4, 5, 6, 7, 8]
odd = arr.reject { |x| x % 2 == 0}             # [1, 3, 5, 7]

# Наконец метод clear удаляет из массива все элементы:
x = [1, 2, 3]
x.clear
# x равно []

# Конкатенирование массивов и добавление в конец массива
# Оператор << добавляет объект в конец массива, в качестве значения он возвращает сам массив, поэтому можно объединять
# в цепочку несколько таких операций:
x = [1, 5, 9]
x << 13                  # x равно [1, 5, 9, 13]
x << 17 << 21            # x равно [1, 5, 9, 13, 17, 21]

# Аналогичную операцию выполняют методы unshift и push, которые добавляют элемент в начало и в конец массива соответственно:
x = [1, 5, 9]
x.push *[2, 6, 10]                 # x равно [1, 5, 9, 2, 6, 10]
x.unshift 3                        # x равно [3, 1, 5, 9, 2, 6, 10]

# Массивы можно конкатенировать методом concat или с помощью операторов + b +=:
x = [1, 2]
y = [3, 4]
z = [5, 6]
b = y + z                      # [3, 4, 5, 6]
b += x                         # [3, 4, 5, 6, 1, 2]
z.concat y                     # z равно [5, 6, 3, 4]

# Оператор += всегда создает новый объект. Также не забываем, что оператор << добавляет в конец новый элемент, который сам может быть массивом:
a = [1, 2]
b = [3, 4]
a += b                         # [1, 2, 3, 4]

a = [1, 2]
b = [3, 4]
a << b                         # [1, 2, [3, 4]]

a = [1, 2]
b = [3, 4]
a = a.concat(b)                # [1, 2, 3, 4]
-------------------------------------------------------------------------------------------------------------
# Обход массива делается с помощью стандартного итератора each, однако есть и другие полезные итераторы, например - reverse_each,
# который обходит массив в обратном порядке:
words = %w(Son I am able she said)
str = ""
words.reverse_each { |w| str += "#{w} "}
# str равно "said she able am I Son "

# Итератор each_with_index (подмешанный из модуля Comparable) передает в блок как сам элемент, так и его индекс:
x = ["alpha", "beta", "gamma"]
x.each_with_index do |x, i|
  puts "Элемент #{i} равен #{x}"
end
# выводится три строки

# Предположим, что нужно обойти массив в случайном порядке. Ниже представлен итератор random_each (который просто вызывает метод shuffle)
class Array

# Предполагается, что метод randomize определен

  def random_each
        self.shuffle.each { |x| yield x}
  end

end

dwarves = %w(Sleepy Dopey Happy Sneezy Grumpy Bashful Doc)
list = ""
dwarves.random_each {|x| list += "#{x} "}
# list равен:
# "Bashful Dopey Sleepy Happy Grumpy Doc Sneezy"
# (На вашей машине порядок может быть другим.)

# Часто бывает необходимо вставить разделители между элементами массива, но не перед первым и не после последнего
# Для этого предназначен метод join и оператор *
been_there = ["Veni", "vidi", "vici."]
journal = been_there.join(", ")                 # "Veni, vidi, vici."

letters = ["Phi", "Mu", "Alpha"]
musicians = letters.join(" ")                   # "Phi Mu Alpha"

people = ["Bob", "Carol", "Ted", "Alice"]
movie = people * " and "
# movie равно "Bob and Carol and Ted and Alice"

# Если необходимо последний элемент обрабатывать особым образом, например, вставить перед ним слово "and",
# то можно сделать это вручную:
list = %w[A B C D E F]
with_commas = list[0..-2] *", " + ", and " + list[-1]
# with_commas равно "A, B, C, D, E, and F"

# Чередование массивов
# Предположим, что есть два массива и надо построить из них третий, который содержит массивы из двух элементов, взятых из 
# соответствующих позиций исходных массивов. Это делает метод zip из модуля Enumerable:
a = [1, 2, 3, 4]
b = ["a", "b", "c", "d"]
c = a.zip(b)
# c равно [[1,"a"], [2,"b"], [3,"c"], [4, "d"]]

# Чтобы устранить вложенность - воспользуемся методом flatten:
d = c.flatten
# d равно [1, "a", 2, "b", 3, "c", 4, "d"]

# Если задан блок, то создаваемые подмассивы будут один за другим передаваться ему:
a.zip(b) { |x1, x2| puts x2 + "-" + x1.to_s}
# Печатается: a-1
#             b-2
#             c-3
#             d-4
# и возвращается nil

# Вычисление частоты различных значений в массиве
# Для массивов нет метода count, как для строк. Поэтому создадим свой собственный:
class Array

  def count
    each_with_object(Hash.new(0)){|x,h| h[x] += 1}
  end

end

meal = %w[spam spam eggs ham eggs spam]
items = meal.counts
# items равно {"ham" => 1, "spam" => 3, "eggs" => 2}
spams = items["spam"]                    # 3
# Обратите внимание, что метод возвращает хэш
-----------------------------------------------------------------------------------------
# Инвертирование массива для получения хэша
class Array

  def invert
    each_with_object({}).with_index{|(x,h),i| h[x] = i}
  end

end

a = ["red", "yellow", "orange"]
h = a.invert        # {"orange"=>2, "yellow"=>1, "red"=>0}
------------------------------------------------------------------------------------------
# Создание нового хэша
# Как и в случае класса Array, для создания хэша слушит специальный метод класса []
# Данные, перечисленные в квадратных скобках, образуют ассоциированные пары
# Ниже показаны шесть способов вызвать этот метод (все хэши содержат одни и те же данные)
a1 = Hash.[]("flat",3, "curved", 2)
a2 = Hash.[]("flat"=>3, "curved"=>2)
b1 = Hash["flat", 3, "curved", 2]
b2 = Hash["flat"=>3, "curved"=>2]
c1 = {"flat", 3, "curved", 2}                  # Почему то выдает ошибку, возможно устарел синтаксис
c2 = {"flat"=>3, "curved"=>2}
# Для a1, b1, c1: число элементов должно быть четным.

# Существует также альтернативный синтаксис для задания литерального хэша в частном случае, когда ключами являются символы
# Начальное двоеточие в нем опускается, а стрелка заменяется двоеточием:
h1 = {:alpha => 123, :beta => 456}
h2 = {alpha: 123, beta: 456}
h1 == h2 # true

# Имеется также метод класса new, который может принимать параметр, задающий значение по умолчанию
# Это значение не является частью хэша, оно просто возвращается вместо nil
d = Hash.new                          # Создать пустой хэш
e = Hash.new(99)                      # Создать пустой хэш
f = Hash.new("a"=>3)                  # Создать пустой хэш
e["angled"]                           # 99
e.inspect                             # "{}"
f["b"]                                # {"a"=>3} (значением по умолчанию)
                                      # является тоже хэш
f.inspect                             # "{}"

# Наконец, упомянем о методе to_h из класса Array, он преобразует произвольный массив двухэлементных массивов в хэш,
# состоящий из ключей и значений:
g = [["a", 1]].to_h  # {"a" => 1}

# Задание значения по умолчанию для хэша
# Значением по умолчанию для хэша является объект, возвращаемый вместо nil в случае, когда указанный ключ не найден
# Это полезно, если вы планируете вызывать для возвращенного значения методы, которые для nil не определены.
# Задать значение по умолчанию можно в момент создания хэша или позже с помощью метода default=
a = Hash.new("missing")                # объект по умолчанию - строка "missing"
a["hello"]                             # "missing"
a.default="nothing"
a["hello"]                             # "nothing"
a["good"] << "bye"                     # "nothingbye"
a.default                              # "nothingbye"

# В отличие от метода default, блок позволяет задать свое значение вместо каждого отсутствующего ключа.
# Типичная идиома - хэш, для которого значением по умолчанию является массив, так что элементы можно добавлять,
# не проверяя явно, что значение отсутствует, и не создавая пустой массив:
a = Hash.new{|h, key| h[key] = []}            # Значением по умолчанию является new []
a["hello"]                                    # []
a["good"] << "bye"                            # {"good" => ["bye"]}

# Имеется также специальный метод экземпляра fetch, который возбуждает исключение IndexError, если в объекте
# типа Hash нет указанного ключа. Он принимает также второй параметр, играющий роль значения по умолчанию.
# Кроме того, методу fetch можно передать необязательный блок, который выработает значение по умолчанию, если ключ
# не будет найден. Принцип здесь такой же, как при создании значений по умолчанию блоком.
a = {"flat" => 3, "curved" => 2, "angled" => 5}
a.fetch("pointed")                               # IndexError
a.fetch("curved", "na")                          # 2
a.fetch("x", "na")                               # "na"
a.fetch("flat") {|x| x.upcase }                  # 3
a.fetch("pointed") {|x| x.upcase }               # "POINTED"

# Доступ к парам ключ-значение и добавление новых пар.
# В классе Hash есть методы класса [] и []=
# Используются они почти так же, как одноименные методы в классе Array, но принимают лишь один параметр.
# В качестве параметра может выступать любой объект, а не только строка (хотя строки используются чаще всего)
a = {}
a["flat"] = 3                       # {"flat"=>3}
a.[]=("curved", 2)                  # {"flat"=>3, "curved"=>2}
a.store("angled", 5)                # {"flat"=>3, "curved"=>2, "angled"=>5}
# Метод store - просто синоним []=, оба могут принимать два аргумента, как показано в примере выше.
# Метод [] аналогичен методу fetch, но не возбуждает исключение IndexError, когда ключи отсутствует, а возвращает nil
a.fetch("flat")                     # 3
a.[]("flat")                        # 3
a["flat"]                           # 3
a["bent"]                           # nil

# Предположим, что мы не уверены, существует ли объект Hash, но хотели бы избежать очистки имеющегося хэша.
# Очевидное решение - проверить, определен ли интересующий нас объект:
a = {} unless defined? a 
a["flat"] = 3
# Но есть и другой, более идиоматический, способ:
a ||= {}
a["flat"] = 3
# Или даже так:
(a ||= {})["flat"] = 3
# Тот же вопрос можно поставить для отдельных ключей, когда новое значение следует присваивать лишь, если такого ключа еще нет:
a = Hash.new(99)
a[2]                           # 99
a                              # {}
a[2] ||= 5                     # 99
a                              # {}
b=Hash.new
b                              # {}
b[2]                           # nil
b[2] ||= 5                     # 5
b                              # {2=>5}
# Отметим, что nil может выступать и в качестве ключа, и в качестве значения:
b={}
b[2]                           # nil
b[3]=nil                           
b                              # {3=>nil}
b[2].nil?                      # true
b[3].nil?                      # true
b[nil]=5                       
b                              # {3=>nil, nil=>5}
b[nil]                         # 5
b[b[3]]                        # 5

# Удаление пар ключ-значение
# Удалить пары ключ-значение из хэша можно с помощью методов clear, delete, delete_if, reject! и shift.
# Метод clear удаляет из хэша все пары. Метод shift удаляет незаданную пару ключ-значение и возвращает ее в виде
# массива из двух элементов или nil, если никаких ключей не осталось.
a = {1=>2, 3=>4}
b = a.shift                    # [1, 2]
# a равно {3=>4}

# Метод delete удаляет конкретную пару ключ-значение. Он принимает в качестве параметра ключ и возвращает ассоциированное
# с ним значение, если такой ключ существовал (и был удален). В противном случае возвращается значение по умолчанию.
# Метод также принимает блок, который вырабатывает уникальное значение по умолчанию вместо того, чтобы возвращать ссылку на общий объект.
a = {1=>1, 2=>4, 3=>9, 4=>16}
a.delete(3)                    # 9
# a равно {1=>1, 2=>4, 4=>16}
a.delete(5)                    # в этом случае nil
a.delete(6) { "не найдено" }   # "не найдено"

# Обход хэша.
# В классе Hash имеется стандартный итератор each, а кроме него итераторы each_key, each_pair и each_value (each_pair синоним each)
{"a" => 3, "b" => 2}.each do |key, val|
  print val, "from", key, "; "             # 3 from a; 2 from b;
end
# Остальные два итератора передают в блок только ключ или только значение:
{"a" => 3, "b" => 2}.each_key do |key|
  print "key = #{key};"                    # Prints: key = a; key = b;

{"a" => 3, "b" => 2}.each_value do |value|
  print "val = #{value};"                  # Prints: val = 3; val = 2;
end
# Инвертирование хэша
# Инвертирование хэша осуществляется в Ruby тривиально с помощью метода invert:
a = {"fred"=>"555-1122", "jane"=>"555-7779"}
b = a.invert
b["555-7779"]                               # "jane"

# Поиск ключей и значений в хэше
# Определить, было ли присвоено значение некоторому ключу, позволяет метод has_key? или любой из его синонимов include?, key?, member?:
a = {"a"=>1, "b"=>2}
a.has_hey? "c"       # false
a.include? "a"       # true
a.key? 2             # false
a.member? "b"        # true
# Можно также воспользоваться методом empty?, чтобы узнать, остался ли в хэше хотя бы один ключ.
# А метод length и его синоним size позволяют узнать, сколько ключей имеется в хэше:
a.empty?             # false
a.length             # 2
# Можно подтвердить также, существует ли указанное значение.
# Для этого предназначены методы has_value? или value?:
a.has_value? 2       # true
a.value?     99      # false

# Копирование хэша в массив.
# Чтобы преобразовать весь хэш в массив, пользуйтесь методом to_a.
# Получившийся массив содержит двухэлементные массивы, содержащие пары ключ-значение:
h = {"a" => 1, "b" => 2}
h.to_a                    # [["a", 1], ["b", 2]]
# Можно также получить массив, содержащий только ключи или только значения:
h.heys                    # ["a", "b"]
h.values                  # [1, 2]
# Наконец, можно поместить в массив только значения, соответствующие заданному списку ключей. 
# Этот метод работает для хэшей примерно так же, как одноименный метод для массивов.
# (Кроме того, как и в случае массивов, метод values_at заменяет устаревшие методы indices и indexes.)
h = {1=>"one", 2=>"two", 3=>"three", 4=>"four", "cinco"=>"five"}
h.values_at(3,"cinco",4)                  # ["three", "five", "four"]
h.values_at(1, 3)                         # ["one", "three"]

# Выборка пар ключ-значение по заданному критерию
# К классу Hash подмешан модуль Enumerable, поэтому можно обращаться к методам detect(find), select(find_all), grep, min, max и reject (как и для массивов).
# Метод detect (синоним find) находит одну пару ключ-значение. Он принимает блок (которому передается по одной паре за раз) и возвращает первую пару,
# для которой вычисление блока дает true.
names = {"fred"=>"jones", "jane"=>"tucker",
         "joe"=>"tucker","mary"=>"SMITH"}
# Найти tucker
names.detect { |k, v| v == "tucker" }              # ["joe", "tucker"]
# Найти имена, записанные заглавными буквами
names.find { |k, v| v == v.upcase }                # ["mary", "SMITH"]

# Разумеется, объекты в хэше могут быть сколько угодно сложными, как и условие, проверяемое в блоке, но
# сравнение объектов разных типов может оказаться проблематичным
# Метод select (синоним find_all) возвращает все пары, удовлетворяющие условию, а не только первую:
names.select { |k, v| v == "tucker" }
# [["joe", "tucker"], ["jane", "tucker"]]
names.find_all { |k, v| k.count("r")>0}
# [["mary", "SMITH"], ["fred", "jones"]]

# Сортировка хэша
# Хэши по своей природе не упорядочены ни по ключам, ни по значениям. Чтобы отсортировать хэш, Ruby преобразует его в массив,
# а затем сортирует этот массив. Понятно, что и результатом является массив.
names = {"Jack"=>"Ruby", "Monty"=>"Python",
         "Blaise"=>"Pascal", "Minnie"=>"Perl"}
list = names.sort
# list равно:
# [["Blaise", "Pascal"], ["Jack", "Ruby"],
# ["Minnie", "Perl"], ["Monty", "Python"]]
# Ниже показано, как такой массив преобразовать обрабно в хэш:
list_hash = list.to_h

# Объединение двух хэшей
# Иногда нужно объеденить хэши. Метод merge получает два хэша и формирует из них третий, перезаписывая обнаружившиеся дубликаты:
dict = {"base" => "foundation", "pedestal" => "base"}
added = {"base" => "non_acid", "salt" => "NaCL"}
new_dict = dict.merge(added)
# {"base" => "non-acid", "pedestal" => "base", "salt" = "NaCl"}
# У метода merge есть синоним update

# Если задан блок, то он может содержать алгоритм устранения коллизий. В примере ниже, если два ключа совпадают, 
# то в объединенном хэше остается меньшее значение (по алфавиту, по числовому значению или в каком то ином смысле):
dict = {"base" => "foundation", "pedestal" => "base"}
added = {"base" => "non-acid", "salt" => "NaCL"}
new_dict = dict.merge(added) { |key,old,new| old < new ? old : new}
# {"salt" => "NaCl", "pedestal" => "base", "base" => "foundation"}
# Таким образом, при использовании блока результат может получиться не такой, как в случае, когда блок не задан.
# Имеются также методы merge! и update!, которые изменяют вызывающий объект "на месте".

# Создание хэша из массива.
# Простейший способ сделать это - прибегнуть к методу to_h массива, содержащего двухэлементные массивы.
# Можно также воспользоваться методом [] класса Hash, которому передаются либо двухэлементные массивы, либо один
# массив, содержащий четное число элементов.
pairs = [[2, 3], [4, 5], [6, 7]]
array = [2, 3, 4, 5, 6, 7]
h1 = pairs.to_h                         # {2 => 3, 4 => 5, 6 => 7}
h2 = Hash[pairs]                        # {2 => 3, 4 => 5, 6 => 7}
h3 = Hash[*array]                      # {2 => 3, 4 => 5, 6 => 7}

# Вычислениие разности и пересечения хэшей
a = {"a" => 1, "b" => 2, "z" => 3}
b = {"x" => 99, "y" => 88, "z" => 77}
intersection = a.keys & b.keys
difference = a.keys - b.keys
c = a.dup.update(b)
inter = {}
intersection.each { |k| inter[k] = c[k] }
# inter равно {"z" = 77}
diff={}
difference.each { |k| diff[k]=c[k] }
# diff равно {"a"=> 1, "b"=>2}

# Хэш как разреженная матрица
# Часто в массиве или матрице заполнена лишь небольшая часть элементов. Можно хранить их как обычно, но такое
# расходование памяти неэкономно. Хэш позволяет хранить только реально существующие значения.
# В следующем примере предполагается, что несуществующие значения о умолчанию равны нулю:
values = Hash.new(0)
values[1001] = 5
values[2010] = 7
values[9237] = 9
x = values[9237]            # 9
y = values[5005]            # 0
# Ясно, что обычный массив в таком случае содержал бы более 9000 неиспользуемых элементов, что не всегда приемлемо.
# А если нужно реализовать разреженную матрицу размерности два или более?
# В этом случае можно было бы использовать массивы в качестве ключей:
cube = Hash.new(0)
cube[[2000, 2000, 2000]] = 2
z = cube[[36, 24, 36]]      # 0
# Здесь обычная матрица содержала бы миллиарды элементов.

# Хэши обычно индексируются на основе значений ключей. При желании можно изменить подобное поведение, так чтобы
# сравнение производилось по идентификатору объекта. Метод compare_by_identity переводит хэш в этот специальный режим,
# а метод compare_by_identity? сообщает, в каком режиме находится хэш:
h1 = { "alpha" => 1, :echo => 2, 35 => 3 }
h2 = h1.dup.compare_by_identity

h1.compare_by_identity?                  # false
h2.compare_by_identity?                  # true

a1 = h1.values_at("alpha", :echo, 35)    # [1, 2, 3]
a2 = h2.values_at("alpha", :echo, 35)    # [nil, 2, 3]
# Причина продемонстрированного выше поведения, конечно же, в том, что симвоы и целые числа в Ruby являются
# непосредственными значениями (как и true, false, nil).
# Однако же для строк в кавычках создаются разные объекты с разными идентификаторами.

# Метод inject. Этот метод пришел в Ruby из языка Smalltalk. В качестве примера рассмотрим массив чисел,
# которые нужно просуммировать:
nums = [3, 5, 7, 9, 11, 13]
sum = nums.inject(0) { |x,n| x + n }
# Обратите внимание, что начальное значение аккумулятора равно 0 ("нейтральный элемент" для операци сложения).
# Затем блок получает текущее значение аккумулятора и значение текущего элемента списка.
# Действие блока заключается в прибавлении нового значения к текущей сумме. Ясно, что этот код эквивалентен следующему:
sum = 0
nums.each { |n| sum += n}
# Начальное значение аккумулятора задавать необязательно. Если оно опущено, то в качестве такового используется
# значение первого элемента, который при последующих итерациях опускается.
sum = nums.inject { |x, n| x + n}
# То же самое, что:
sum = nums[0]
nums[1..-1].each { |n| sum += n}

# Похожий пример - вычисление произведения чисел. В данном случае аккумулятору следует присвоить начальное 
# значение 1 (нейтральный элемент для операции умножения)
prod = nums.inject(1) {|x,n| x*n}
# или
prod = nums.inject {|x,n| x*n}

# В следующем немного более сложном примере мы находим самое длинное слово в списке:
words = %w[ alpha beta gamma delta epsilon eta theta ]
longest_word = words.inject do |best,w|
  w.length > best.length ? w : best
end
# возвращается значение "epsilon"

# Кванторы. Кванторы any? и all? упрощают проверку свойств коллекции. Оба квантора принимают в качестве
# параметра блок (который должен возвращать значение true или false).
nums = [1, 3, 5, 8, 9]
# Есть ли среди чисел четные?
flag1 = nums.any? {|x| x % 2 == 0}      # true

# Все ли числа четные?
flag2 = nums.all? {|x| x % 2 == 0}      # false

# Если блок не задан, то просто проверяется значение истинности каждого элемента. Иными словами, неявно добавляется блок {|x| x}.
flag1 = list.all?                       # list не содержит ни одного false или nil
flag2 = list.any?                       # list содержит хотя бы одно истинное значение
                                        # не nil и не false

# Метод partition. Если при вызове метода задан блок, то этот блок вычисляется для каждого элемента набора.
# В результате создается два массива, в первый попадают элементы, для которых блок вернул true, во второй - остальные.
# Метод возвращает массив, двумя элементами которогоо являются эти массивы.
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]

odd_even = nums.partition { |x| x % 2 == 1 }
# [[1,3,5,7,9], [2,3,4,6,8]]

under5 = nums.partition { |x| x < 5 }
# [[1,2,3,4], [5,6,7,8,9]]

squares = nums.partition { |x| Math.sqrt(x).to_i**2 == x }
# [[1,4,9], [2,3,5,6,7,8]]

# Обход с группировкой
# Иногда желательно на каждой итерации анализировать по два, три или более элементов.
# Итератор each_slice принимает в качестве параметра число n, равное числу просматриваемых на каждой
# итерации элементов. Если не осталось достаточного количества, то размер последнего фрагмента будет меньше.
arr = [1,2,3,4,5,6,7,8,9,10]
arr.each_slice(3) do |triple|
  puts triple.join(",")
end

# Выводится:
# 1,2,3
# 4,5,6
# 7,8,9
# 10

# Имеется также итератор each_cons, который позволяет обходить набор методом "скользящего окна" заданного размера
# В таком случае фрагменты всегда будут иметь одинаковый размер.
arr = [1,2,3,4,5,6,7,8,9,10]
arr.each_cons(3) do |triple|
  puts triple.join(",")
end
# Выводится:
# 1,2,3
# 2,3,4
# 3,4,5
# 4,5,6
# 5,6,7
# 6,7,8
# 7,8,9
# 8,9,10

# Преобразование в массив или множество
# Каждая перечисляемая структура теоретически может быть тривиально преобразована в массив (методом to_a)
# Например, такое преобразование для хэша дает вложенный массив пар:
hash = {1=>2, 3=>4, 5=>6}
arr = hash.to_a                 # [[5, 6], [1, 2], [3, 4]]

# Синонимом метода to_a является метод entries.
# Если была затребована библиотека set, становится доступен метод to_set.
require 'set'
hash = {1=>2, 3=>4, 5=>6}
set = hash.to_set               # #<Set: {[1, 2], [3, 4], [5, 6]}>

# Перечислители
# Итераторный метод each не требует задания блока. Если блок не задан, то метод возвращает объект-перечислитель:
items = [1,2,3,4]
enum = items.each
enum.each { |x| puts x }        # Печатает числа по одному в строке

# 8.3.6 Пример внешнего итерирования
people = [2, "George", "Washington",
          3, "Edgar", "Allan", "Poe",
          2, "John", "Glenn",
          4, "Little", "Red", "Riding", "Hood",
          1, "Sting"]
enum = people.each
loop do
       count = enum.next         # Получить следующий элемент из массива
       count.times { print enum.next }
       puts
end

# Существует метод rewind, который "сбрасывает" внутреннее состояние, возвращаясь к началу перечисляемой последовательности:
list = [10, 20, 30, 40, 50]
enum = list.each 
puts enum.next      # 10
puts enum.next      # 20
puts.enum.next      # 30
enum.rewind
puts enum.next      # 10

# Метод with_index является простым (внутренним) итератором. Его можно использовать
# вместе с другим перечислителем, и возвращает он итератор:
list = [10, 20, 30, 40, 50]
list.each.with_index {|x,i| puts "list[#{i}] = #{x}" }
# или...
enum = list.each.with_index
loop { x, i = enum2.next; puts "list[#{i}] = #{x}" }   # такой же результат

# Дополнительные сведения о перечисляемых объектах
# Поиск и выборка
# Метод find_index ищет первый объект, равный переданному параметру и возвращает его индекс (индексация с нуля):
array = [10, 20, 30, 40, 50, 30, 20]
location = array.find_index(30)                # результат равен 2

# Методы first и last возвращают n первых или последних элементов коллекции (по умолчанию один):
array = [14, 17, 23, 25, 29, 35]
head = array.first                             # 14
tail = array.last                              # 35
front = array.first(2)                         # [14, 17]
back = array.last(3)                           # [25, 29, 35]

# Существуют также два квантора: one? и none?. Метод one? понять легко: чтобы он вернул true,
# вычисление блока кода должно дать результат true ровно один раз:
array = [1, 3, 7, 10, 15, 17, 21]
array.one? {|x| x % 2 == 0}                    # true (одно четное число)
array.one? {|x| x > 16}                        # false
[].one? {|x| true}                             # для пустого массива всегда возвращается false
# Но, вот none? не столь интуитивно очевиден. Он возвращает true, если при вычислении блока ни разу не получилось true.
array = [1, 3, 7, 10, 15, 17, 21]
array.none? {|x| x > 50}                       # true (значение блока равно false для всех элементов)
array.none? {|x| x == 1}                       # false
[].none? {|x| true}                            # true (для пустого массива блок не выполняется)
# Если блок опущен, то для каждого элемента коллекции проверяется, похож ли он на true или на false.
# Метод возвращает true, только если все проверки дают false.

# Подсчет и сравнение.
# С методом count все просто. Он может принимать параметр, блок или ничего. В последнем случае просто
# возвращается размер коллекции. Если параметром является объект, то подсчитывается количество вхождений этого 
# объекта (сравнение производится с помощью оператора ==). Если задан блок, то подсчитывается количество
# элементов коллекции, для которых блок возвращает true.
days = %w[Sunday Monday Tuesday Wednesday Thursday Friday Saturday]
days.count                         # всего 7
days.count("Saturday")             # 1 (суббота только одна!)
days.count {|x| x.length == 6}     # есть три 3 слова из шести букв
# С методами min и max мы уже встречались. Для их работы необходимо, чтобы существовал оператор <=>
# (или был включен модуль Comparable). Существует также метод minmax, который возвращает сразу
# и минимальный, и максимальный элемент массива:
days = %w[Sunday Monday Tuesday Wednesday Thursday Friday Saturday]
days.minmax     # ["Friday", "Wednesday"]
# Если для сравнения элементов нужно использовать более сложное правило, то можно прибегнуть
# к методам min_by, max_by и minmax_by, которые принимают произвольный блок кода
# (по аналогии с методом sort_by, рассмотренным выше в этой главе):
days = %w[Sunday Monday Tuesday Wednesday Thursday Friday Saturday]
days.min_by {|x| x.length}                      # "Sunday" (хотя есть и другие)
days.max_by {|x| x.length}                      # "Wednesday"
days.minmax_by {|x| x.reverse}                  # ["Friday", "Thursday"]
# В последнем примере результат содержит первый и последний элементы массива,
# буквы которых переставлены "задом наперед".

# Итерирование
# Метод cycle умеет обходить коллекцию более одного раза или даже "бесконечно"
# Параметр задает число циклов, по умолчанию подразумевается бесконечное число:
months = %w[Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec]
months.cycle(2) { |x| puts m }              # всего будет 24 итерации 24
months.cycle { |x| puts x }                 # бесконечный цикл
# Метод each_with_object работает так же, как inject, но в виде дополнительной любезности возвращает
# тот же объект, который был ему передан. Так удается избежать некрасивого решения, когда приходится
# явно возвращать аккумулятор в конце блока
h = Hash.new(0)
result = [1,2,3,4].inject(h) {|acc,n| acc[n] += 1; acc}          # Некрасиво

h = Hash.new(0)
result = [1,2,3,4].each_with_object(h) do |n, acc|
  acc[n] += 1 }                                                  # Так лучше
end

# Извлечение и преобразование. 
# Существуют способы извлекать в массив только части коллекции с помощью методов take и take_while
# Они возвращают список первых элементов коллекции. В первом примере ниже рассматривается хэш, элементом
# такой коллекции является пара ключ-значение, возвращаемая в виде подмассива.
# В следующих примерах те же операции применяются к массивам:
hash = {1 => 2, 3 => 6, 4 => 8, 5 => 10, 7 => 14}
arr1 = hash.take(2)                          # [[1,2], [3,6]]
arr2 = hash.take_while {|k,v| v <= 8 }       # [[1,2], [3,6], [4,8]]
arr3 = arr1.take(1)                          # [[1,2]]
arr4 = arr2.take_while {|x| x[0] < 4 }       # [[1,2], [3,6]]
# Метод drop дополняет take. Он пропускает первые элементы коллекции и возвращает остальные.
# Существует также метод drop_while.
hash = {1 => 2, 3 => 6, 4 => 8, 5 => 10, 7 => 14}
arr1 = hash.drop(2)                          # [[4,8], [5,10], [7 => 14]]
arr2 = hash.take_while {|k,v| v <= 8 }       # [[5,10], [7 => 14]]
# Метод reduce также навеян теми же идеями, что inject. Он применяет бинарную операцию (заданную символом)
# к каждой паре элементов коллекции, но может принять также и блок. Если задано начальное значение 
# аккумулятора, оно и используется, в противном случае начальным значением будет первый элемент коллекции.
range = 3..6
# символ
range.reduce(:*)                             # 3*4*5*6 = 360
# с начальным значением, символ
range.reduce(2, :*)                          # 2*3*4*5*6 = 720
# с начальным значением, блок
range.reduce(10) {|acc, item| acc += item }  # 10+3+4+5+6 = 28
# блок
range.reduce {|acc, item| acc += item }      # 3+4+5+6 = 28
# Отметим, что задать одновременно символ бинарного оператора и блок невозможно.
# Перечисляемые объекты можно также преобразовывать в формат JSON (если затребована библиотека json)
# или в множество (если затребована библиотека set):
require 'set'
require 'json'

array = [3,4,5,6]
p array.to_set             # #<Set: {3, 4, 5, 6}>
p array.to_json            # "[3,4,5,6]"

# Ленивые перечислители.
# Метод lazy объекта Enumerable возвращает специальный объект Enumerator, который вычисляет следующий 
# элемент по мере необходимости. Это позволяет обходить группы, слишком большие для хранения в памяти,
# например, все нечетныые числа от 1 до бесконечности:
enum = (1..Float::INFINITY).each         # Enumerator
lazy = enum.lazy                         # LazyEnumerator по всем целым числам
odds = lazy.select(&:odd?)               # LazyEnumerator по нечетным числам
odds.first(5)                            # [1, 3, 5, 7, 9]
odds.next                                # 1
odds.next                                # 3
# Ленивые перечислители открывают новые возможности для экономии памяти и времени при обходе больших
# коллекций, поэтому рекомендуется внимательно ознакомиться с документацией по классу LazyEnumerator

# Множества
# Чтобы получить в свое распоряжение класс Set, достаточно написать:
require 'set'
# При этом также добавляется метод to_set в модуль Enumerable, так что любой перечисляемый объект 
# становится возможно преобразовать в множество.
# Создать новое множество нетрудно. Метод [] работает почти так же, как и для хэшей. Метод new 
# принимает в качестве необязательных параметров перечисляемый объект и блок. Если блок задан, то он
# выступает в роли "препроцессора" для списка (подобно операции map).
s1 = Set[3,4,5]                          # в математике обозначается {3,4,5}
arr = [3,4,5]
s2 = Set.new(arr)                        # то же самое
s3 = Set.new(arr) {|x| x.to_s }          # множество строк, а не чисел

# Простые операции над множествами
# Для объединения множеств служит метод union (синонимы | и +)
x = Set[1,2,3]
y = Set[3,4,5]

a = x.union(y)                            # Set[1,2,3,4,5]
b = x | y                                 # то же самое
c = x + y                                 # то же самое
# Пересечение множеств вычисляется методом intersection (синоним &):
x = Set[1,2,3]
y = Set[3,4,5]

a = x.intersection(y)                     # Set[3]
b = x & y                                 # то же самое

# В случае бинарных операторов в правой части необязательно должно быть множество.
# Подойдет любой перечисляемый объект, порождающий множество в качестве результата.
# Унарный минус обозначает разность множеств. Это было в разделе 8.1.9
diff = Set[1,2,3] - Set[3,4,5]            # Set[1,2]
# Принадлежность элемента множесту проверяют методы member? или include?, как для массивов.
# Напомним, что порядок операндов противоположен принятому в математике.
Set[1,2,3].include?(2)                    # true
Set[1,2,3].include?(4)                     # false
Set[1,2,3].member?(4)                     # false
# Чтобы проверить, является ли множество пустым, мы вызываем метод empty?, как и в случае массивов.
# Метод clear очищает множество, то есть удаляет из него все элементы.
s = Set[1,2,3,4,5,6]
s.empty?                                  # false
s.clear
s.empty?                                  # true
# Можно проверить, является ли одно множество подмножеством, собственным подмножеством или надмножеством другого.
x = Set[3,4,5]
y = Set[3,4]

x.subset?(y)                              # false
y.subset?(x)                              # true
y.proper_subset?(x)                       # true
x.subset?(x)                              # true
x.proper_subset?(x)                       # false
x.superset?(y)                            # true
# Метод add (синоним <<) добавляет в множество один элемент и обычно возвращает его в качестве значения.
# Метод add? возвращает nil, если такой элемент уже присутствовал в множестве. Метод merge полезен, если
# надо добавить сразу несколько элементов. Все они, конечно, могут изменить состояние вызывающего объекта.
# Метод replace работает так же, как и в случае строки или массива. Наконец, два множества можно сравнить
# на равенство очевидным способом:
Set[3,4,5] == Set[5,4,3]                  # true

# Более сложные операции над множествами.
# Ruby не гарантирует никакой последовательности при обходе множеств, временами можно получить повторяющиеся результаты
# но полагаться на это неразумно
s = Set[1,2,3,4,5]
s.each {|x| puts x; break }               # Выводится 5

# Метод classify подобен методу partition, но с разбиением на несколько частей;
# он послужил источником идеи для реализации вашей версии метода classify в разделе 8.3.3
files = Set.new(Dir["*"])
hash = files.classify do |f|
  if File.size(f) <= 10_000
    :small 
  elsif File.size(f) <= 10_000_000
    :medium 
  else
    :large
  end
end

big_files = hash[:large]                  # big_files - это Set

# Метод divide аналогичен, но вызывает блок, чтобы выяснить "степень общности" элементов,
# и возвращает множество, состоящее из множеств.
# Следующий блок (с арностью 1) разбивает множество на два подмножества, одно из которых содержит четные, а другое - нечетные числа:
require 'set'
numbers = Set[1,2,3,4,5,6,7,8,9,0]
set = numbers.divide{|i| i % 2}
p set          # #<Set: {#<Set: {5,1,7,3,9}>, #<Set: {0,6,2,8,4}>}>

# Простыми числами-близнецами называются простые числа отличающиеся на 2(например, 11 и 13); все
# остальные называются одиночными (например, 23). Следующий код разбивает множество на группы, помещая
#  числа-близнецы в одно и то же подмножестово. В данном случае применяется блок с арностью 2:
primes = Set[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
set = primes.divide{|i,j| (i-j).abs == 2}
# set is #<Set: { #<Set: {2}>, #<Set: {3, 5, 7}>, #<Set: {11, 13},
# #<Set: {17, 19}>, #<Set: {23}>, #<Set: {29, 31}> }>

# Более строгая реализация стека
# Вот пример простого класса, который хранит внутри себя массив и управляет доступом к этому массиву.
class Stack

  def initialize
    @store = []
  end

  def push(x)
    @store.push(x)
  end

  def pop
    @store.pop
  end

  def peek
    @store.last
  end

  def empty?
    @store.empty?
  end

end
# Мы добавили еще одну опеарацию, которая для массивов не определена; метод peek возвращает элемент,
# находящийся на вершине стека, не выталкивая его.

# Более строгая реализация очереди. Если вы хотите защититься от некорректного доступа к структуре данных,
# рекомендуем поступать аналогично.
class Queue

  def initialize
    @store = []
  end

  def enqueue(x)
    @store << x
  end

  def dequeue
    @store.shift
  end

  def peek
    @store.first
  end

  def length
    @store.length
  end

  def empty?
    @store.empty?
  end

end

# Решение задачи "Ханойская башня" с помощью стека (с тремя дисками)
def towers(list)
  while !list.empty?
    n, src, dst, aux = list.pop
    if n == 1
      puts "Перемещаем диск c #{src} на #{dst}"
    else
      list.push [n-1, aux, dst, src]
      list.push [1, src, dst, aux]
      list.push [n-1, src, aux, dst]
    end
  end
end

list = []
list.push([3, "a", "c", "b"])

towers(list)

# Конечно, классическое решение этой задачи рекурсивно. Но, как отмечалось, тесная связь между алгоритмами
# не должна вызывать удивления, т.к. для рекурсии применяется невидимый системный стек.
def towers(n, src, dst, aux)
  if n == 1
    puts "Перемещаем диск с #{src} на #{dst}"
  else
    towers(n-1, src, aux, dst)
    towers(1, src, dst, aux)
    towers(n-1, aux, dst, src)
  end
end

towers(3, "a", "c", "b")
# Печатается точно такой же результат. Но, рекурсивное решение оказалось в два раза быстрее.

# Обнаружение несбалансированных скобок.
def paren_match(str)
  stack = Stack.new
  lsym = "{[(<"
  rsym = "}])>"
  str.each_char do |sym|
    if lsym.include? sym
      stack.push(sym)
    elsif rsym.include? sym
      top = stack.peek
      if lsym.index(top) != rsym.index(sym)
        return false
      else
        stack.pop
      end
      # Игнорируем символы, отличные от скобок...
    end
  end
  # Убедимся, что стек пуст...
  return stack.empty?
end

str1 = "(((a+b))*((c-d)-(e*f))"
str2 = "[[(a-(b-c))], [[x,y]]]"

paren_match str1                 # false
paren_match str2                 # true

# Использование двоичного дерева как справочной таблицы
class Tree

  # Предполагается, что определения
  # взяты из предыдущего примера...

  def search(x)
    if self.data == x 
      return self
    elsif x < self.data
      return left ? left.search(x) : nil 
    else
      return right ? right.search(x) : nil 
    end
  end

end

keys = [50, 20, 80, 10, 30, 70, 90, 5, 14,
        28, 41, 66, 75, 88, 96]

tree = Tree.new

keys.each {|x| tree.insert(x)}

s1 = tree.search(75)                      # Возвращает ссылку на узел, содержащий 75...

s2 = tree.search(100)                     # Возвращает nil (не найдено)
