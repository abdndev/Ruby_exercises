Array.new(5) { Array.new(4) { rand(0..9) } } # Создать массив 5 на 4 и заполнить весь массив абсолютно случайными значениями от 0 до 9.


[11, 22, 33, 44, 55].count(&:even?)   # С помощью указателя на функцию посчитать количество четных элементов в массиве
[0, 0, 1, 1, 0, 0, 1, 0].count { |x| x == 0} # использование метода .count для вычисления количества нулевых значений в массиве. Метод .count может принимать блок.

arr = [ [30, 1], [25, 0], [64, 1], [64, 0], [33, 1] ] # первый элемент каждого подмассива - возраст, второй элемент - пол(муж - 1, жен - 0)
arr.select { |element| element[0] == 64 && element[1] == 1} # выбираем мужчин в возрасте 64 лет (выбран 1 элемент)
arr.select { |element| element[1] == 1} # выбираем всех мужчин (выбрано 3 элемента)
arr.reject { |element| element[0] >= 27 } # отсеять всех  мужчин старше двадцати семи лет (и выслать остальным повестку в военкомат)

[11, 22, 33, 44, 55].take(2) # метод .take принимает параметр (число) и берет определенное этим параметром количество элементов в начале массива
[20, 34, 65, 23, 18, 44, 32].all? { |element| element >= 18 } # метод .all? позволяет убедиться что все элементы удовлетворяют требованиям (true если все значения больше или равны 18(лет))

[false, false, false, true, false].any? { |element| element == true } # метод .any? позволяет узнать есть ли в массиве хоть одно совпадение (в данном случае: true), и выведет в случае успеха - true, если нет - false)
[false, false, false, true, false].find_index { |element| element == true } # метод .find_index показываете индекс искомого элемента в массиве - 3, в данном случае

-------------------------------------------------------------------------------------------------------------------------------------------------
# Передача опций в методы
# Conventional method (обычный метод)
def total_weight(soccer_ball_count, tennis_ball_count, golf_ball_count)
  #...
end

x = total_weight(3, 2, 1)

# Хеш с параметрами, вызов этого метода без параметров выдаст ошибку
def total_weight(options)
  a = options[:soccer_ball_count]
  b = options[:tennis_ball_count]
  c = options[:golf_ball_count]
  puts a 
  puts b 
  puts c  
  #...
end

params = { soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1 }
x = total_weight(params)
--------------------------------------------------------------------------------

# Хеш с опциями по умолчанию
def total_weight(options={})
    a = options[:soccer_ball_count]
    b = options[:tennis_ball_count]
    c = options[:golf_ball_count]
    puts a 
    puts b 
    puts c  
    #...
  end

  x = total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1)
--------------------------------------------------------------------------------

# если в хеше options значение не указано (nil), то переменной будет присвоено значение "0", и ошибки не будет

def total_weight(options={})
    a = options[:soccer_ball_count] || 0
    b = options[:tennis_ball_count] || 0
    c = options[:golf_ball_count] || 0
    puts a 
    puts b 
    puts c  
    # (a * 410) + (b * 58) + (c * 45) + 29  # 29 - вес коробки
  end

  x = total_weight(soccer_ball_count: 3, tennis_ball_count: 2)
  puts x
--------------------------------------------------------------------------------
# пример применения метода initialize

class Car 
  def initialize
    puts 'hello from constructor!'
  end
end

car1 = Car.new

-------------------------------------------------------------------------------
# пример конструктора в JS
class Car {
  constructor() {
    console.log('hello from constructor!');
  }
}

let car1 = new Car();
-------------------------------------------------------------------------------
# пример тестов rspec: файл shipment_spec.rb

require './lib/shipment'                        # подключаем юнит
                                                # специальный синтаксис, который дословно говорит:
describe Shipment do                            # "описываем Shipment (отправление)"
  it 'should work without options' do           # специальный синтаксис, который дословно говорит: "это должно работать без опций". То что в кавычках - это строка, мы сами её пишем, слово "it" служебное.
    expect(Shipment.total_weight).to eq(29)     # ожидаем, что общий вес отправления будет равен 29 (eq от англ. "equal")
  end

  it 'should calculate shipment with only one item' do    # пример теста проверки для только одной вещи каждого вида в корзине
    expect(Shipment.total_weight(soccer_ball_count: 1)).to eq(410 + 29)
    expect(Shipment.total_weight(tennis_ball_count: 1)).to eq(58 + 29)
    expect(Shipment.total_weight(golf_ball_count: 1)).to eq(45 + 29)
  end

  it 'should calculate shipment with multiple items' do # пример теста проверки для нескольких вещей в корзине
    expect(
      Shipment.total_weight(soccer_ball_count: 3, tennis_ball_count: 2, golf_ball_count: 1)
    ).to eq(1420)
  end
end
-----------------------------------------------------------------------------------------------------------------
# Отложенная интерполяция
# использование eval
str = '#{name} - моё имя, а #{nation} - моя страна.'
name, nation = "Стивен Дедал", "Ирландия"
s1 = eval('"' + str + '"')
--------------------------------------------------------------------------------------------
# использование proc
str = proc do |name, nation|
  "#{name} - моё имя, а #{nation} - моя страна."
end
s2 = str.call("Гулливер Фойл", "Терра")
--------------------------------------------------------------------------------------------
# Символы
# Чаще всего символы применяются для определения атрибутов класса:
class MyClass
  attr_reader :alpha, :beat
  attr_writer :gamma, :delta
  attr_accessor :epsilon
  # ...
end
# применение символов
class SomeClass
  attr_accessor :whatever    # чтобы добавить в класс аттрибут, допускающий чтение и изменение
end
# это же можно выразить иначе
class SomeClass
  def whatever
    @whatever
  end
  def whatever=(val)
    @whatever = val 
  end
end
--------------------------------------------------------------------------------------------
# преобразование строки в символ и обратно с помощью методов to_str и to_sym
a = "foobar"
b = :foobar
a == b.to_str  # true
b == a.to_sym  # true
--------------------------------------------------------------------------------------------
# проверка принадлежности к диапазону с помощью метода include?
r1 = 23456..34567
x = 14142
y = 31416
r1.include?(x)  # false
r1.include?(y)  # true
--------------------------------------------------------------------------------------------
# преобразование диапазона в массив
r = 3..12
arr = r.to_a   # [3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
--------------------------------------------------------------------------------------------
# определение порядкового номера дня в году
t = Time.now
day = t.yday   # 146
--------------------------------------------------------------------------------------------
# как открывать файлы для чтениия и записи
file1 = File.new("one")         # Открыть для чтения
file2 = File.new("two", "w")    # Открыть для записи
-----------------------------------------------------------------------------
# закрытие файла с методом close
out = File.new("captains.log", "w")
  # обработка файла...
out.close

# Имеется также метод open. В простейшей форме это просто синоним new:
trans = File.open("transactions", "w")
-----------------------------------------------------------------------------
# автоматическое закрытие файла с методом open
File.open("somefile", "w") do |file|
  file.puts "Строка 1"
  file.puts "Строка 2"
  file.puts "Третья и последняя строка"
end
# теперь файл закрыт

# Метод reopen ассоциирует с объектом-получателем новый поток. В примере ниже мы отключаем запись на
# стандартный вывод для ошибок, а затем снова включаем:
save = STDERR.dup
STDERR.reopen("/dev/null")
# Работаем молча...
STDERR.reopen(save)

-----------------------------------------------------------------------------
# обновление файла
# чтобы открыть файл для чтения и записи, достаточно добавить знак (+) в строку задания режима
f1 = File.new("file1", "r+")
# Чтение/запись, от начала файла.

f2 = File.new("file2", "w+")
# Чтение/запись; усечь существующий файл или создать новый.

f3 = File.new("file3", "a+")
# Чтение/запись; перейти в конец существующего файла или создать новый.

# Дописывание в конец файла. Чтобы дописать данные в конец существующего файла, нужно указать строку
# задания режима "а" (см. раздел 10.1.1)
logfile = File.open("captains_log", "a")
# Добавить строку в конец и закрыть файл.
logfile.puts "Stardate 47824.1: Our show has been canceled."
logfile.close

# Прямой доступ к файлу
# Для чтения из файла в произвольном порядке, а не последловательно, можно воспользоваться методом seek,
# который класс File наследует от IO. Проще всего перейти на байт в указанной позициию Номер позиции
# отсчитывается от начала файла, причем самый первый байт находится в позиции 0
# myfile содержит строку: abcdefghi
file = File.new("myfile")
file.seek(5)
str = file.gets                       # "fghi"

# Если все строки в файле имеют одинаковую длину, то можно перейти сразу в начало нужной строки:
# Предполагается, что все строки имеют длину 20.
# Строка N начинается с байта (N-1)*20
file = File.new("fixedlines")
file.seek(5*20)                        # Шестая строка!

# Для выполнения относительного поиска воспользуйтесь вторым параметром.
# Константа IO::SEEK_CUR означает, что смещение задано относительно текущей позиции (и может быть отрицательным):
file = File.new("somefile")
file.seek(55)                          # Позиция 55
file.seek(-22, IO::SEEK_CUR)           # Позиция 33
file.seek(47, IO::SEEK_CUR)            # Позиция 80

# Можно также искать относительно конца файла, в таком случае смещение может быть только отрицательным:
file.seek(-20, IO::SEEK_END)           # двадцать байтов от конца файла

# Есть еще и третья константа IO::SEEK_SET, но это значение по умолчанию (поиск относительно начала файла).
# Метод tell возвращает текущее значение позиции в файле, у него есть синоним pos:
file.seek(20)
pos1 = file.tell                       # 20
file.seek(50, IO::SEEK_CUR)            
pos2 = file.pos                        # 70
# Метод rewind устанавливает указатель файла в начало. Его название восходит ко временам использования лент.
# Для выполнения прямого доступа файл часто открывается в режиме обновления (для чтения и записи). Этот 
# режим обозначается знаком + в начале строки задания режима (см. раздел 10.1.2)

# Работа с двоичными файлами.
# В двоичном режиме можно читать байты и производить над ними такие манипуляции, которые
# при наличии кодировки были бы недопустимымы:
File.write("invalid", "\xFC\x80 \x80\x80\xAF")
File.read("invalid", mode: "r").split(" ")
# invalid byte sequence in UTF-8 недопустимая последовательность байтов в UTF-8
File.read("invalid", mode: "rb").split(" ")
# ["\xFC\x80", "\x80\xAF"]

# В Windows двоичный режим означает также, что пару символов r\n\(возврат каретки и перевод строки),
# завершающую строку, не следует преобразовывать в один символ \n.
# Еще одно важное отличие - интерпретация символа Ctrl+Z как конца файла в текстовом режиме:
# myfile содержит "12345\0326789\r".
# Обратите внимание на восьмеричное 032 (^Z)
File.open("myfile", "rb") {|f| str = f.sysread(15) }.size       # 11
File.open("myfile", "r") {|f| str = f.sysread(15) }.size        # 5

# В следующем фрагменте показано, что на платформе Windows символ возврата каретки не преобразуется в двоичном режиме:
# Входной файл содержит всего одну строку: Строка 1.
file = File.open("data")
line = file.readline                # "Строка 1.\n"
puts "#{line.size} символов."       # 10 символов
file.close

file = File.open("data", "rb") 
line = file.readline                # "Строка 1.\r\n"
puts "#{line.size} символов."       # 11 символов
file.close

# Отметим, что упомянутый в коде метод binmode переключает поток в двоичный режим.
# После переключения вернуться в текстовый режим невозможно.
file = File.open("data")
file.binmode
line = file.readline                # "Строка 1.\r\n"
puts "#{line.size} символов."       # 11 символов
file.close

# При необходимости выполнить низкоуровневый ввод-вывод можно воспользоваться методами sysread и syswrite.
# Первый принимает в качестве параметра число подлежащих чтению байтов, второй принимает строку и возвращает число
# написанных байтов.
input = File.new("infile")
output = File.new("outfile")
instr = input.sysread(10);
bytes = output.syswrite("Это тест.")
# Отметим, что метод sysread возбуждает исключение EOFError при попытке вызвать его, когда достигнут
# конец файла (но не в том случае, когда конец файла встретился в ходе успешной операции чтения).
# Оба метода возбуждают исключение SystemCallError при возникновении ошибки ввода-вывода.
# При работе с двоичными данными могут оказаться полезны метод pack из класса Array и метод unpack из класса String.

# Блокировка файлов.
# В тех операционных системах, которые поддерживают такую возможность, метод flock класса File блокирует и разблокирует файл.
# Вторым параметром может быть одна из констант File::LOCK_EX, File::LOCK_NB, File::LOCK_SH, File::LOCK_UN 
# или их объединение с помощью оператора ИЛИ. Понятно, что многие комбинации не имеют смысла,
# чаще всего употребляется флаг, задающий неблокирующий режим.
file = File.new("somefile")

file.flock(File::LOCK_EX)                 # Монопольная блокировка; никакой другой
                                          # процесс не может обратиться к другому файлу.
file.flock(File::LOCK_UN)                 # Разблокировать.

file.flock(File::LOCK_SH)                 # Разделяемая блокировка (другие
                                          # процессы могут сделать то же самое).

file.flock(File::LOCK_UN)                 # Разблокировать.

locked = file.flock(File::LOCK_EX  File::LOCK_NB)
# Пытаемся заблокировать файл, но не приостанавливаем программу, если
# не получилось; в таком случае переменная locked будет равна false.

# Простой ввод-вывод. 
# Кроме методов gets, puts, print, printf и p, есть еще метод putc.
# Метод putc выводит один символ
# Если параметроа является объект String, то печатается первый символ строки.
putc(?\n)           # Вывести символ новой строки
putc("X")           # Вывести букву X

# Весь вывод, формируемыц методами из Kernel направляется в глобальную переменную $stdout
# Она инициализирована значением STDOUT, так что данные отправляются на стандартный вывод.
# В любой момент переменной $stdout можно присвоить другое значение, являющееся объектом IO.
diskfile = File.new("foofile", "w")
puts "Привет..."                     # Выводится на stdout
$stdout = diskfile
puts "Пока!"                         # выводится в файл "foofile"
diskfile.close
$stdout = STDOUT                     # восстановление исходного значения
puts "Это все."                      # выводится на stdout
# Помимо метода gets, в модуле Kernel есть также методы ввода readline и readlines.
# Первый аналогичен gets в том смысле, что возбуждает исключение EOFError при попытке читать за концом
# файла, а не просто возвращает nil. Последний эквивалентет методу IO.readlines(то есть считывает весь файл в память).
# Откуда мы получаем ввод? Есть переменная $stdin, которая по умолчанию равна STDIN. Точно также
# существует поток стандартного вывода для ошибок ($stderr, по умолчанию равен STDERR).
# Еще имеется интересный глобальный объект ARGF, представляющий конкатенацию всех файлов, указанных
# в командной строке. Это не объект класса File, хотя и напоминает таковой. По умолчанию ввод связан
# именно с этим объектом, если в командной строке задан хотя бы один файл.
# cat.rb
# Прочитать все файлы, а затем вывести их
puts ARGF.read
# А при таком способе более экономно расходуется память:
puts ARGF.readline until ARGF.eof?
# Пример: ruby cat.rb file1 file2 file3

# Чтение из стандартного ввода (STDIN) происходит в обход методов Kernel. 
# Поэтому можно обойти (или не обходить) ARGF, как показано ниже:
# Прочитать строку из стандартного ввода
str1 = STDIN.gets
# Прочитать строку из ARGF
str2 = ARGF.gets
# А теперь снова из стандартного ввода
str3 = STDIN.gets

# Существует возможность читать как на уровне символов, так и на уровне байтов. 
# В случае однобайтовой кодировки разница только в том, что байт имеет тип Fixnum, а символ - это односимвольная строка:
c = input.getc
b = input.getbyte
input.ungetc                     # Эти две операции не всегда
input.ungetbyte                  # возможны.
b = input.readbyte               # Как getbyte, но может возбуждать EOFError

# Буферизованный и небуферизованный ввод-вывод
# В некоторых случаях Ruby осуществляет буферизацию самостоятельно. Рассмотрим следующий фрагмент:
print "Привет..."
sleep 10
print "Пока!\n"
# Если запустить программу, то можно увидеть, что сообщения "Привет" и "Пока" появляются одновременно, 
# после завершения sleep. При этом первое сообщение не завершается символом новой строки.
# Это можно исправить, вызвав метод flush для опустошения буфера ввода.
# В данном случае вывод идет в поток $defout (подразумеваемый по умолчанию для всех методов Kernel,
# которые занимаются выводом). И поведение оказывается ожидаемым, т.е. первое сообщение появляется раньше второго.
print "Привет... "
STDOUT.flush
sleep 10
print "Пока!\n"
# Буферизацию можно отключить (или включить) методом sync=, а метод sync позволяет узнать текущее состояние.
buf_flag = $defout.sync           # true
STDOUT.sync = false
buf_flag = STDOUT.sync            # false
# Есть также еще по крайней мере один низкий уровень буферизации, который не виден. Если метод getc
# возвращает символ и продвигает вперед указатель файла или потока, то метод ungetc возвращает символ назад в поток.
ch = mystream.getc                # ?A
mystream.ungetc(?C)
ch = mystream.getc                # ?C
# Тут следует иметь ввиду три вещи. Во-первых, только что упомянутая буферизация не имеет отношения
# к механизму буферизации, о котором мы говорили выше в этом разделе. Иными словами, предложение
# sync=false не отключает ее. Во-вторых, вернуть в поток можно только один символ, при попытке вызвать
# метод ungetc несколько раз будте возвращен только символ, прочитанный последним. И, в-третьих, 
# метод ungetc не работает для принципиально небуфиризуемых операций (например, sysread).

# Манипулирование правами владения и разрешениями на доступ к файлу.
# Для определения владельца и группы файла (это целые числа), класс File::Stat предоставляет методы экземпляра uid и gid:
data = File.stat("somefile")
owner_id = data.uid
group_id = data.gid
# В классе File::Stat есть также метод экземпляра mode, который возвращает текущий набор разрешений для файла.
perms = File.stat("somefile").mode
# В классе File имеется метод класса и экземпляра chown, который позволяет изменить идентификаторы владельца и группы.
# Метод класса принимает произвольное число файлов. Если идентификатор не нужно изменять, можно передать nil или -1.
uid = 201
gid = 10
File.chown(uid, "alpha", "beta")
f1 = File.new("delta")
f1.chown(uid, gid)
f2 = File.new("gamma")
f2.chown(nil, gid)                        # Оставить идентификатор владельца без изменения
# Разрешения можно изменить с помощью метода chmod (у него есть два варианта: метод класса и метод экземпляра).
# Традиционно разрешения представляют восьмеричным числом, хотя это и не обязательно.
File.chmod(0644, "epsilon", "theta")
f = File.new("eta")
f.chmod(0444)
# Процесс всегда работает от имени какого-то пользователя (возможно, root), поэтому с ним связан идентификатор пользователя
# (мы сейчас говорим о действующем идентификаторе пользователя). Часто нужно знать, имеет ли этот пользователь право читать,
# писать или исполнять данный файл. В классе File::Stat есть методы экземпляра для получения такой информации.
info = File.stat("/tmp/secrets")
rflag = info.readable?
wflag = info.writable?
xflag = info.executable?
# Иногда нужно отличить действующий идентификатор пользователя от реального. На этот случай предлагаются методы экземпляра
# readable_real?, writable_real? и executable_real?.
info = File.stat("/tmp/secrets")
rflag2 = info.readable_real?
wflag2 = info.writable_real?
xflag2 = info.executable_real?
# Можно сравнить владельца файла с действующим идентификатором пользователя (и идентификатором группы) текущего процесса.
# В классе File::Stat для этого есть методы owned? и grpowned?.
# Отметим, что многие из этих методов можно найти также в модуле FileTest:
rflag = FileTest::readable?("pentagon_files")
# Прочие методы: writable? executable? readable_real?
# writable_real? executable_real? owned? grpowned?
# Отсутствую здесь: uid gid mode

# Маска umask, ассоциированная с процессомм, определяет начальные разрешения для всех созданных им файлов.
# Стандартные разрешения 0777 логически пересекаются (AND) с отрицанием umask, то есть биты, поднятые в маске, "маскируются"
# или сбрасываются. Если вам удобнее, можете представлять себе эту операцию как вычитание (без занимания).
# Следовательно, если задана маска 022, то все файлы создаются с разрешениями 0755.
# Получить или установить маску можно с помощью метода umask класса File. Если ему передан параметр, то он становится
# новым значением маски (при этом метод возвращает старое значение).
File.umask(0237)                       # Установить umask
current_umask = File.umask             # 0237
# Некоторые биты режима файла (например, бит фиксации (sticky bit)) не имеют прямого отношенияя к разрешениям.

# Получение и установка временных меток
# Ruby понимает три таких метки: время модификации, время доступа и время изменения. Получить эту информацию можно тремя разными способами.
# Методы mtime, atime и ctime класса File возвращают временные метки, не требуя предварительного открытия или даже создания объекта File.
t1 = File.mtime("somefile")
# Thu Jan 04 09:03:10 GMT-6:00 2001
t2 = File.atime("somefile")
# Thu Jan 09 10:03:34 GMT-6:00 2001
t3 = File.ctime("somefile")
# Sun Nov 26 23:48:32 GMT-6:00 2000

# Если файл, представленный экземпляром File, уже открыт, то можно воспользоваться методами этого экземпляра.
myfile = File.new("somefile")
t1 = myfile.mtime
t2 = myfile.atime
t3 = myfile.ctime
# А если имеется экземпляр класса File::Stat, то и у него есть методы, позволяющие получить ту же информацию:
myfile = File.new("somefile")
info = myfile.stat
t1 = info.mtime
t2 = info.atime
t3 = info.ctime
# Отметим, что объект File::Stat возвращается методом класса (или экземпляра) stat из класса File. Метод класса lstat
# (или одноименный метод экземпляра) делает то же самое, но возвращает информацию о состоянии самой ссылки, а не файла,
# на который она ведет. Если имеется цепочка из нескольких ссылок, то метод следует по каждой из них, кроме последней.
# Для изменения времени доступа и модификации применяется метод utime, которому можно передать несколько файлов.
# Время можно создать в виде объекта Time или числа секунд, прошедших с точки отсчета.
today = Time.now
yesterday = today - 86400
File.utime(today, today, "alpha")
File.utime(today, yesterday, "beta", "gamma")
# Поскольку обе временные метки изменяются одновременно, то при желании оставить одну без изменения, ее сначала следует получить и сохранить.
mtime = File.mtime("delta")
File.utime(Time.now, mtime, "delta")

# Проверка существования и получение размера файла
# Часто необходимо знать, существует ли файл с данным именем. Это позволяет выяснить метод exist? из модуля FileTest:
flag = FileTest::exist?("LochNessMonster")
flag = FileTest::exists?("UFO")
# exists? является синонимом exist?

# Чтобы узнать есть ли в файле какие-нибудь данные, можно использовать метод zero?
# Метод zero? возвращает true, если длина файла равна нулю, и false в противном случае.
flag = File.new("somefile").stat.zero?
# Метод size? возвращает либо размер файла в байтах, если он больше нуля, либо nil для файла нулевой длины.
# Не сразу понятно, почему nil а не 0. Дело в том, то метод предполагалось использовать в качестве предиката,
# а значение истинности нуля в Ruby - true, тогда для nil оно равно false.
if File.size?("myfile")
  puts "В файле есть данные."
else
  puts "Файл пуст."
end
# Далее возникает вопрос: "Каков размер файла?". Мы уже видели, что для непустого файла метод size?
# возвращает длину. Но, если мы применяем его не в качестве предиката, то значение nil только путает.
# В классе File  для ответа на этот вопрос есть как метод класса, так и метод экземпляра:
size1 = File.size?("filename")                  # возвращает 0, если файл filename пуст
# Чтобы получить размер файла в блоках, а не в байтах, можно обратиться к методу blocks из класса File::Stat.
# Результат, конечно, зависит от операционной системы. (Метод blksize сообщает размер блока операционной системы.)
info = File.stat("somefile")
total_bytes = info.blocks * info.blksize

# Опрос специальных свойств файла
# У файла есть много свойств, которые можно опросить. 
# В некоторых операционных системах устройства подразделяются на блочные и символьные. Файл может ссылаться
# как на то, так и на другое, но не на оба сразу. Методы blockdev? и chardev? из модуля FileTest проверяют тип устройства:
flag1 = FileTest::chardev?("/dev/hdisk0")   # false
flag2 = FileTest::blockdev?("/dev/hdisk0")  # true
# Иногда нужно знать, ассоциирован ли данный поток с терминалом. Метод tty? класса IO (синоним isatty) дает ответ на этот вопрос:
flag1 = STDIN.tty?                          # true
flag2 = File.new("diskfile").isatty         # false
# Поток может быть связан с каналом (pipe) или сокетом. В модуле FileTest есть методы для опроса этих условий:
flag1 = FileTest::pipe?(myfile)
flag2 = FileTest::socket?(myfile)
# Напомним, что каталог - это частный случай файла. Поэтому нужно уметь отличать каталоги от обычных файлов, 
# для чего предназначены следующие два метода:
file1 = File.new("/tmp")
file2 = File.new("tmp/myfile")
test1 = file1.directory?                    # true
test2 = file.file?                          # false
test3 = file2.directory?                    # false
test4 = file2.file?                         # true
# В классе File есть также метод класса ftype, который сообщает вид потока, одноименный метод экземпляра
# находится в классе File::Stat. Этот метода возвращает одну из следующих строк:file, directory, blockSpecial,
# characterSpecial, fifo, link или socket(строка fifo относится к каналу).
this_kind = File.ftype("/dev/hdisk0")       # "blockSpecial"
that_kind = File.new("/tmp").stat.ftype     # "directory"
# В маске, описывающей режим файла, можно устанавливать или сбрасывать некоторые биты. Они не имеют прямого
# отношения к битам, обсуждавшимся в разделе 10.1.9. Речь идет о битах set-group-id, set-user-id, и бите
# фиксации (sticky bit). Для каждого из них есть свой метод.
file = File.new("somefile")
sticky_flag = file.sticky?
setgid_flag = file.setgid?
setuid_flag = file.setuid?
# На дисковый файл могут вести символические или физические ссылки (в тех операционных системах, где такой
# механизм поддерживается). Чтобы проверить, является ли файл символической ссылкой на другой файл, обратитесь
# к методу symlink?. Для подсчета числа физических ссылок на файл служит метод nlink (он есть только в классе File::Stat).
# Физическая ссылка не отличима от обычного файла, это просто файл, для которого есть несколько имен и записей в каталоге.
File.symlink("yourfile", "myfile")             # Создать ссылку
is_sym = File.symlink?("myfile")               # true
hard_count = File.new("myfile").stat.nlink     # 0
# Отметим попутно, что в предыдущем примере мы воспользовались методом класса symlink из класса File
# для создания символической ссылки.
# В редких случаях может понадобиться информация о файле еще более низкого уровня. В классе File::Stat есть
# еще три метода экземпляра, представляющих такую информацию. Метод dev возвращает целое число, идентифицирующее
# устройство, на котором расположен файл. Метод rdev возвращает целое число, описывающее тип устройства, 
# а для дисковых файлов метод ino возвращает номер первого индексного узла, занятого файлом.
file = File.new("diskfile")
info = file.stat 
device = info.dev
devtype = info.rdev
inode = info.ino
------------------------------------------------------------------------------
# Каналы
# Ruby поддерживает разные способы читать из канала и писать в него. Метод класса IO.popen открывает канал
# и связывает с возвращенным объектом стандартные ввод и вывод процесса. Часто с разными концами канала работают
# разные потоки, но в примере ниже запись и чтение осуществляет один и тот же поток:
check = IO.popen("spell", "r+")
check.puts("T was brillig, and the slithy toves")
check.puts("Did gyre and gimble in the wabe.")
check.close_write
list = check.readlines
list.collect! { |x| x.chomp }
# list равно %w[brillig gimble gyre slithy toves wabe]
# Отметим, что вызов close_write обязателен, иначе мы никогда не достигнем конца файла при чтении из канала.
# Существует также блочная форма:
File.popen("/usr/games/fortune") do |pipe|
  quote = pipe.gets
  puts quote
  # На чистом диске можно искать бесконечно. - Том Стил
end
#  Если задана строка "-", то запускается новый экземпляр Ruby. Если при этом задан еще и блок, то он работает
# в двух разных процессах, как в результате разветвления (fork); блоку в процессе-потомке передается nil, 
# а в процессе-родителе объект iO, с которым связан стандартный ввод или стандартный вывод.
IO.popen("-") do |mypipe|
  if mypipe
    puts "Я родитель: pid = #{Process.pid}"
    listen = mypipe.gets
    puts listen
  else
    puts "Я потомок: pid = #{Process.pid}"
  end
end

# Печатается:
# Я родитель: pid = 10580
# Я потомок: pid = 10582

# Метод pipe возвращает также два конца канала, связанных между собой. В следующем примере мы создаем два потока,
# один из которых передает сообщение другому (то самое сообщение, которое Сэмьюел Морзе послал по телеграфу).
pipe = IO.pipe
reader = pipe[0]
writer = pipe[1]

str = nil
thread1 = Thread.new(reader,writer) do |reader,writer|
  # writer.close_write
  str = reader.gets
  reader.close
end

thread2 = Thread.new(reader,writer) do |reader,writer|
  # reader.close_read
  writer.puts("What hath God wrougth?")
  writer.close
end

thread1.join
thread2.join

puts str                 # What hath God wrought?

# Неблокирующий ввод-вывод
string = input.read(64)                    # читать 64 байта
buffer = ""
input.read(64, buffer)                     # необязательный буфер
# По достижении конца файла возбуждается исключение EOFError. Если возникло исключение EWOULDBLOCK, то
# в следующий раз метод можно вызывать только после того, как станут доступны данные. Например:
begin
  data = input.read_nonblock(256)
rescue Errno::EWOULDBLOCK
  IO.select([input])
  retry
end
# Аналогично метод write_nonblock обращается к системному вызову write(2) (и возбуждает соответствующие исключения).
# Он принимает в качестве аргумента строку и возвращает количество записанных байтов (которое может оказаться
# меньше длины строки). Исключение EWOULDBLOCK следует обрабатывать так же, как в случае описанного выше метода read_nonblock

# Применение метода readpartial
# Метод readpartial упрощает ввод-вывод в поток, например в сокет.
# Параметр "максимальная длина" (max length) обязателен. Если задан параметр buffer, то он должен ссылаться на строку, в которой будут храниться данные.
data = sock.readpartial(128)              # Читать не более 128 байтов

# Манипулирование путевыми именами
# Основными методами для работы с путевыми именами являются методы класса File.dirname и File.basename;
# они работают, как одноименные команды UNIX, то есть возвращают имя каталога и имя файла соответственно.
# Если вторым параметром методу basename передана строка с расширением имени файла, то это расширение исключается.
str = "/home/dave/podbay.rb"
dir = File.dirname(str)                     # "/home/dave"
file1 = File.basename(str)                  # "podbay.rb"
file2 = File.basename(str, ".rb")           # "podbay"
# Хотя это методы класса File, на самом деле они просто манипулируют строками.
# Упомянем также метод File.split, который возвращает обе компоненты (имя каталога и файла) в массиве из двух элеметов:
info = File.split(str)                      # ["/home/dave/","podbay.rb"]
# Метод класса expand_path преобразует относительное путевое имя в абсолютный путь.
# Если операционная система понимает сокращения ~ и ~user, то они тоже учитываются.
# Необязательный второй аргумент задает путь, начиная от которого следует производить расширение; часто
# в этом качестве указывают путь к текущему каталогу __FILE__.
Dir.chdir("/home/poole/personal/docs")
abs = File.expand_path("../../misc")                # "/home/poole/misc"
abs = File/expand_path("misc", "/home/poole")       # "/home/poole/misc"
# Если передать методу экземпляра path открытый файл, то он вернет путевое имя, по которому файл открыт.
File.new("../../foobar").path                       # "../../foobar"
# Константа File::Separator равна символу, применяемому для разделения компонентов путевого имени (в Windows
# это обратная косая черта, а в UNIX - прямая косая черта). Имеется синоним File::SEPARATOR
# Метод класса join использует этот разделитель для составления полного путевого имени из переданного списка компонентов:
path = File.join("usr", "local", "bin", "someprog")
# path равно "usr/local/bin/someprog"
# Обратите внимание, что в начале имени разделитель не добавляется!
# Не думайте, что методы File.join и File.split взаимно обратны. Это не так.

# Класс Pathname
# Следует знать о стандартной библиотеке pathname, которая предоставляет класс Pathname.
# По существу, это обертка вокруг классов Dir, File и FileUtils, поэтому он комбинирует многие их 
# функции логичным и интуитивно понятным способом.
path = Pathname.new("/home/hal")
file = Pathname.new("file.txt")
p2 = path + file

path.directory?                      # true
path.file?                           # false
p2.directory?                        # false
p2.file?                             # true

parts = path2.split                  # [Pathname:/home/hal, Pathname:file.txt]
ext = path2.etxname                  # .txt
# Также имеется ряд вспомогательных методов. Метод root? пытается выяснить, относится ли данный путь к корневому каталогу,
# но его можно "обмануть", так как он просто анализирует строку, не обращаясь к файловой системе.
# Метод parent? возвращает путевое имя родительского каталога данного пути. Метод children возвращает
# непосредственных потомков каталога, заданного своим путевым именем, в их число включаются как файлы,
# так и каталоги, но рекурсивного спуска не производится.
p1 = Pathname.new("//")              # странно, но допустимо
p1.root?                             # true
p2 = Pathname.new("/home/poole")
p3 = p2.parent                       # Путевое имя:/home
items = p2.children                  # массив объектов Pathname (все файлы и каталоги, находящиеся непосредственно в каталоге poole)
# Как и следовало ожидать, методы relative и absolute пытаются определить, является ли путь относительным
# или абсолютным (проверяя, есть ли в начале имени косая черта):
p1 = Pathname.new("/home/dave")
p1.absolute?                         # true
p1.relative?                         # false
# Многие методы. например size, unlink и прочие, просто делегируют работу классам File и FileUtils;
# повторно функциональность не реализуется.

# Манипулирование файлами на уровне команд
# Часто приходится манипулировать файлами так, как это делается с помощью командной строки: копировать, удалять и т.д.
# Многие из этих операций реализованы встроенными методами, некоторые находятся в модуле FileUtils из библиотеки fileutils.
# Имейте в виду, что раньше функциональность модуля FileUtils подмешивалась прямо в класс File, 
# теперь эти методы помещены в отдельный модуль.
# Для удаления файла служит метод File.delete или его синоним File.unlink:
File.delete("history")
File.unlink("toast")
# Переименовать файл позволяет метод File.rename:
File.rename("Ceylon", "SriLanka")
# Создать ссылку на файл (физическую или символическую) позволяют методы File.link и File.symlink соответственно:
File.link("/etc/hosts", "/etc/hostfile")                   # физическая ссылка
File.symlink("/etc/hosts", "/tmp/hosts")                   # символическая ссылка
# Файл можно усечь до нулевой длины (или до любой другой), воспользовавшись методом экземпляра truncate:
File.truncate("myfile", 1000)                # Теперь не более 1000 байтов
# Два файла можно сравнить с помощью метода compare_fille. У него есть синонимы cmp и compare_stream:
require "fileutils"

same = FileUtils.compare_file("alpha", "beta")      # true
# Метод copy копирует файл в другое место, возможно, с переименованием. У него есть необязательный файл, 
# говорящий, что сообщения об ошибках нужно направлять на стандартный вывод для ошибок. Синоним - привычное
# для программистов UNIX имя cp.
require "fileutils"

# Скопировать файл epsilon в theta с протоколированием ошибок.
FileUtils.copy("epsilon", "theta", true)
# Файл можно перемещать методом move (синоним mv). Как и copy, этот метод имеет необязательный параметр, включающий вывод сообщений об ошибках.
FileUtils.move("/tmp/names", "/etc")                # Переместить в другой каталог
FileUtils.move("colours", "colors")                 # Просто переименовать

# Метод safe_unlink удаляет один или несколько файлов, предварительно пытаясь сделать их доступными
# для записи, чтобы избежать ошибок. Если последний параметр равен true или false, он интерпретируется как флаг,
# задающий режим вывода сообщений об ошибках.
require "fileutils"

FileUtils.safe_unlink("alpha", "beta", "gamma")
# Протоколировать ошибки при удалении следующих двух файлов
FileUtils.safe_unlink("delta", "epsilon", true)

# Наконец, метод install делает практически то же, что syscopy, но снаала проверяет, что целевой файл либо
# не существует, либо содержит такие же данные.
require "fileutils"

FileUtils.install("foo.so", "/usr/lib")
# Существующий файл foo.so не будет перезаписан, если он не отличается от нового.

# Ввод символов с клавиатуры
# В данном случае мы имеем в виду небуферизованный ввод, когда символ обрабатывается сразу после нажатия клавиши,
# не дожидаясь, пока будет введена вся строка.
# Это можно сделать и в UNIX, и в Windows, но, к сожалению, совершенно по разному.
# Версия для UNIX прямолинейна. Мы переводим терминал в режим прямого ввода (raw mode) и обычно одновременно отключаем эхо-контроль.
def getchar
  system("stty raw -echo")         # Прямой ввод без эхо-контроля
  char = STDIN.getc
  system("stty -raw echo")         # Восстановить режим терминала
  char
end
# На платформе Windows придется написать расширение на C. Альтернативой является использование одной
# из функций в библиотеке Win32API.
require 'Win32API'

def getchar
  char = Win32API.new("crtdll", "_getch", [], 'L').call
end
# Поведение в обоих случаях идентично.

# Чтение всего файла в память
# Чтобы прочитать весь файл в массив, не нужно его даже предварительно открывать. 
# Все сделает метод IO.readlines: откроет файл, прочитает и закроет.
arr = IO.readlines("myfile")
lines = arr.size
puts "myfile содержит #{lines} строк."

longest = arr.collect {|x| x.length}.max
puts "Самая длинная строка содержит #{longest} символов."
# Можно также воспользоваться методом IO.read (который возвращает одну большую строку, а не массив строк).
str = IO.read("myfile")
bytes = arr.size 
puts "myfile содержит #{bytes} байтов."

longest=str.collect {|x| x.length}.max    # строки - перечисляемые объекты!
puts "Самая длинная строка содержит #{longest} символов."
# Поскольку класс IO является предком File, то можно вместо этого написать File.readlines и File.read.

# Построчное чтение из файла
# Чтобы читать по одной строке из файла, можно обратиться к методу класса IO.foreach или методу экземпляра each.
# В первом случае файл не нужно явно открывать.
# Напечатать все строки, содержащие слово "target"
IO.foreach("somefile") do |line|
  puts line if line =~ target
end

# Другой способ...
file = File.new("somefile")
file.each do |line|
  puts line if line =~ /target/
end
# Отметим, что each_line - синоним each. Он также позволяет получить перечислитель:
lines = File.new("somefile").each_line
lines.find{|line| line =~ /target/}        # Используется как перечислитель

# Побайтное и посимвольное чтение из файла
# Для чтения из файла по одному байту служит метод экземпляра each_byte.
# Он передает в блок один байт (то есть объект типа Fixnum из диапазона 0..255):
a_count = 0
File.new("myfile").each_byte do |byte|
  a_count += 1 if byte == 97            # строчная буква в коде ASCII
end
# Можно читать также посимвольно (символ - это в действительности односимвольная строка).
# В зависимости от используемой кодировки символ может состоять из одного байта (как в ASCII) или из нескольких.
a_count = 0
File.new("myfile").each_char do |char|
  a_count += 1 if char == "a"
end
# Метод each_char также возвращает обычный перечислитель.

# Работа со строкой как с файлом
# Иногда возникает необходимость рассматривать строку как файл. Что под этим понимается, зависит от конкретной задачи.
# Oбъект определяется, прежде всего, своими методами. В следующем фрагменте показано, как к объекту source
# применяется итератор; на каждой итерации выводится одна строка. Можете ли вы что-нибудь сказать о типе 
# объекта source, глядя на этот код?
source.each do |line|
  puts line
end
# Это мог бы быть как файл, так и строка, содержащая внутри символы новой строки. В таких случаях строку
# можно трактовать как файл без всякого труда.
# Класс StringIO представляет многие методы класса IO, которых нет у обычной строки.
# В нем есть метод доступа string, ссылающийся на содержимое самой строки.
ios = StringIO.new("abcdefghijkl\nABC\n123")

ios.seek(5)
ios.puts("xyz")
puts ios.tell                    # 9
puts ios.string.inspect          # "abcdexyz\njkl\nABC\n123"

puts ios.getc                    # j
ios.ungetc(?w)                  
puts ios.string.inspect          # "abcdexyz\nwkl\nABC\n123"

s1 = ios.gets                    # "wkl"
s2 = ios.gets                    # "ABC"

# Копирование потока
# Метод класса copy_stream служит для копирования потока. Все данные копируются из начального объекта в конечный.
# Начальный и конечный объекты могут быть объектами IO или именами файлов. Третий (необязательный) параметр -
# количество подлежащих копированию байтов (по умолчанию, естественно, предполагается, что нужно копировать все байты из источника).
# Четвертый параметр - смещение от начала источника (в байтах):
src = File.new("garbage.in")
dst = File.new("garbage.out")
IO.copy_stream(src, dst)

IO.copy_stream("garbage.in", "garbage.out", 1000, 80)
# В конечный поток копируется 1000 байтов, начиная со смещения 80

# Чтение данных, встроенных в текст программы
# Распечатать все строки "задом наперед"...
DATA.each_line do |line|
  puts line.reverse
end
__END__
A man, a plan, a canal... Panama!
Madam, I'm Adam.
,siht gnidaer er'uoy fI 
.evisserpmi si noitacided ruoy

# Чтение исходного текста программы
# Глобальная константа DATA - это объект класса IO, ссылающийся на данные, которые расположены после 
# директивы __END__. Но, если выполнить метод rewind, то указатель файла будет переустаановлен на начало текста программы.
# Следующая программа  выводит собственный текст, снабжая его номерами строк. Это не очень полезно, но, 
# быть может, вы найдете и другие применения такой техники.
DATA.rewind
DATA.each_line.with_inde do |line, i|
  puts "#{'%03d' % (i + 1)} #{line.chomp}"
end
__END__
# Отметим, что наличие директивы __END__ обязательно, без нее к константе DATA вообще нельзя обратиться.
# Другой способ прочитать исходный текст текущего файла - воспользоваться специальной переменной __FILE__.
# Она содержит полный путь к самому файлу, и из нее можно читать:
puts File.read(__FILE__)

# Получение и изменение текущего каталога
# Получить имя текущего каталога можно с помощью метода Dir.pwd (синоним Dir.getwd).
# Эти имена уже давно употребляются как сокращения от "print working directory"(печатать рабочий каталог)
# и "get working directory" (получить рабочий каталог).
# Для изменения текущего каталога служит метод Dir.chdir. В Windows в начале строки можно указывать букву диска.
Dir.chdir("/var/tmp")
puts Dir.pwd                   # "/var/tmp"
puts Dir.getwd                 # "/var/tmp"
# Этот метод также принимает блок в качестве параметра. Если блок задан, то текущий каталог изменяется только
# на время выполнения блока, а потом восстанавливается в первоначальное значение:
Dir.chdir("/home")
Dir.chdir("/tmp") do
  puts Dir.pwd                 # /tmp
  # какой то код...
end
puts Dir.pwd                   # /home

# Изменение текущего корня
# В большинстве систем UNIX можно изменить "представление" процесса о том, что такое корневой каталог /.
# Обычно это делается из соображений безопасности перед запуском небезопасной или непротестированной программы.
# Метод chroot делает указанный каталог новым корнем:
Dir.chdir("/home/guy/sandbox/tmp")
Dir.chroot("/home/guy/sandbox")
puts Dir.pwd                    # "/tmp"

# Обход каталога
# Метод foreach - это итератор, который последовательно передает в блок каждый элемент каталога.
# Точно так ведет себя метод экземпляра each.
Dir.foreach("/tmp") { |entry| puts entry }

dir = Dir.new("/tmp")
dir.each { |entry| puts entry }
# Оба фрагмента печатают одно и то же (имена всех файлов и подкаталогов в каталоге /tmp).

# Получение содержимого каталога
# Метод класса Dir.entries возвращает массив, содержащий все элементы указанного каталога:
list = Dir.entries("/tmp")            # w%[. .. alpha.txt beta.doc]
# Как видите, включаются и элементы, соответствующие текущему и родительскому каталогу. Если они вам не
# нужны, придется отфильтровать вручную.

# Создание цепочки каталогов
# Иногда необходимо создать глубоко вложенный каталог, причем промежуточные каталоги могут и не существовать.
# В UNIX мы воспользовались бы для этого командой mkdir -p
# В программе на Ruby такую операцию выполняет метод FileUtils.makedirs (из библиотеки fileutils):
require "fileutils"
FileUtils.makedirs("/tmp/these/dirs/need/not/exist")

# Рекурсивное удаление каталога
# В UNIX команда rm -rf dir удаляет все поддерево, начиная с каталога dir.
# Понятно, что применять ее надо с осторожностью.
# В классе Pathname имеется метод rmtree, решающий ту же задачу.
require 'pathname'
dir = Pathname.new("/home/poole/")
dir.rmtree
# В классе FileUtils есть метод rm_r, который делает то же самое:
require 'fileutils'
FileUtils.rm_r("/home/poole")

# Работа с временными файлами
# Для работы с временными файлами имеется библиотека Tempfile.
# Метод new (синоним open) принимает базовое имя в качестве начального значения и конкатенирует его с 
# идентификатором процесса и уникальным порядковым номером. Необязательный второй параметр - имя каталога
# в котором создается временный файл, по умолчанию оно равно значению первой из существующих переменных 
# окружения TMPDIR, TMP, или TEMP, а если ни одна из них не задана, то "/tmp".
# Возвращаемый объект IO можно многократно открывать и закрывать на протяжении времени работы программы,
# а по завершении временный файл будет автоматически удален.
# У метода close есть необязательный флаг, если он равен true, то файл удаляется сразу после закрытия
# (не дожидаясь завершения программы). Метод path возвращает полное имя файла, если оно вам по какой то причине понадобится.
require "tempfile"

temp = Tempfile.new("stuff")
name = temp.path                       # "/tmp/stuff17060.0"
temp.puts "Здесь был Вася"
temp.close

# Позже...
temp.open
str = temp.gets                        # "Здесь был Вася"
temp.close(true)                       # Удалить СЕЙЧАС

# Поиск файлов и каталогов
# В класе Dir имеется метод glob (синоним []), возвращающий массив файлов, имена которых соответствуют 
# заданной маске в смысле оболочки. В простых случаях этого достаточно для поиска нужного фала в каталоге:
Dir.glob("*.rb")                       # все файлы ruby в текущем каталоге
Dir["spec/**/*_spec.rb"]               # все файлы с именами, заканчивающимися на _spec.rb в каталоге spec/

# Для более сложных случаев имеется стандартная библиотека find, которая позволяет посетить каждый файл
# в указанном каталоге и всех его подкаталогах. Следующий метод находит в указанном каталоге файлы по имени
# (строке) либо регулярному выражению.
require "find"

def findfiles(dir, name)
  list = []
  Find.find(dir) do |path|
    Find.prune if [".",".."].incude? path
    case name
      when String
        list << path if File.basename(path) == name
      when Regexp
        list << path if File.basename(path) =~ name
      else
        raise ArgumentError
      end
    end
    list
  end

  findfiles "/home/hal", "toc.txt"
  # ["/home/hal/docs/toc.txt", "/home/hal/misc/toc.txt"]

  findfiles "/home", /^[a-z]+.doc/
  # ["/home/hal/docs/alpha.doc", "/home/guy/guide.doc", "/home/bill/help/readme.doc"]

  # Доступ к данным более высокого уровня
  # Простой маршаллинг
  # Простейший способ сохранить объект для последующего использования - подвергнуть его маршалингу.
  # Модуль Marshal позволяет сериализовать и десериализовать объекты в Ruby, представив их в виде строк,
  # которые уже можно записать в файл.
  # массив элементов [composer, work, minutes]
  works = [["Leonard Bernstein", "Overture to Candide", 11],
           ["Aaron Copland", "Symphony No. 3", 45],
           ["Jean Sibelius", "Finlandia", 20]]
  # Мы хотим сохранить его для дальнейшего использования...
  File.write "store", Marshal.dump("works")

  # Намного позже...
  works = Marshal.load File.read("store")
  
  # Первые два байта данных, порождаемых методом Marshal.dump - номер старшей и младшей версии.
  Marshal.dump("foo").bytes[0..1]  # [4, 8]
  # Ruby успешно загружает такие данные только в том случае, когда номера старших версий данных и метода
  # совпадают, и номер младшей версии данных не больше младшей версии метода.

  # "Глубокое копирование" с помощью метода Marshal
  # В Ruby нет операции "глубокого копирования". Например, методы dup и clone хэша не копируют ключи и 
  # значения, на которые в хэше есть ссылки. Если количество вложенных ссылок на объекты достаточно велико,
  # то операция копирования превращается в игру "собери палочки".
  # Ниже предлагается способ реализовать глубокое копирование с некоторыми ограничениями, обусловленными
  # тем, что наш подход основан на использовании класса Marshal со всеми присущими ему недостатками:
  def deep_copy(obj)
    Marshal.load(Marshal.dump(obj))
  end

  a = deep_copy(b)

  # Более сложный маршалинг
  # Иногда мы хотим настроить маршалинг под свои нужды. Для этого нужно создать методы marshal_load 
  # и marshal_dump. Если они существуют, то вызываются во время выполнения маршалинга, чтобы мы могла самостоятельно
  # реализовать преобразование данных в строку и обратно.
  # В следующем примере человек получает 5-процентный доход на начальный капитал с момента рождения. Мы
  # не храним ни возраст, ни текущий баланс, поскольку они являются функциями времени.
  class personal
    attr_reader :balance, :name
    
    def initialize(name, birthday, beginning)
      @name = name
      @birthdate = birthdate
      @deposit = deposit
      @age = (Time.now - @birthdate) / (365*86400)
      @balance = @deposit * (1.05 * @age)
    end

    def age
      @age.floor
    end

    def marshal_dump
      {name: @name, birthdate: @birthdate, deposit: @deposit}
    end

    def marshal_load(data)
      initialize(data[:name], data[:birthdate], data[:deposit])
    end
  end

  p1 = Person.new("Rudy", Time.now - (14 * 365 * 86400), 100)
  [p1.name, p1.age, p1.balance]         # ["Rudy", 14, 197.9931599439417]

  p2 = Marshal.load Marshal.dump(p1)
  [p2.name, p2.age, p2.balance]         # ["Rudy", 14, 197.9931599440351]
  # При сохранении объекта этого типа атрибуты age и balance не сохраняются. А когда объект восстанавливается
  # они вычисляются заново. Отметим, что метод marshal_load предполагает, то объект существует; это один
  # из немногих случаев, когда метод initialize приходится вызывать явно (обычно это делает метод new).
  
  # Маршалинг в формате YAML
  # Аббревиатура YAML означает "YAML Ain't Markup Language" (YAML - не язык разметки).
  # Это не что иное, как гибкий, понятный человеку формат обмена данными между программами, возможно, 
  # написанными на разных языках.
  # Если загружена библиотека yaml, то в нашем распоряжении оказываются методы YAML.dump и YAML.load, 
  # очень похожие на соответствующие методы из класса Marshal. Было бы поучительно сериализовать несколько
  # объектов в формате YAML и посмотреть, что получается:
  require 'yaml'

  Person = Struct.new(:name)

  puts YAML.dump("Hello, world.")
  puts YAML.dump({this: "is a hash",
        with: "symbol keys and string values"})
  puts YAML.dump([1, 2, 3])
  puts YAML.dump Person.new("Alice")

  # Выводится:
  # --- Hello, world.
  # ...
  # ---
  # :this: is a hash
  # :with: symbol keys and string values
  # ---
  # - 1
  # - 2
  # - 3
  # --- !ruby/struct:Person
  # name: Alice
  
  # Любой YAML-документ начинается строкой "---", за которой следуют сериализованные объекты в понятном человеку виде.
  # Использовать метод YAML.load для загрузки строки столь же просто. А метод YAML.load_file идет на шаг 
  # дальше и позволяет указать имя загружаемого файла. Пусть имеется такой файл data.yaml:
  ---
  - "Hello, world"
  - 237
  -
    - Jan
    - Feb
    - Mar
    - Apr
  -
    just a: hash.
    This: is
  # Это четыре элемента данных, сгруппированные в единый массив. Если загрузить этот файл, то получится массив:
  require 'yaml'
  p YAML.load_file("data.yaml")
  # Выводится:
  # ["Hello, world", 237, ["Jan", "Feb", "Mar", "Apr"],
  #  {"just a"=>"hash.", "This"=>"is"}]
  # В общем и целом, YAML - еще один способ выполнить маршалинг объектов. На верхнем уровне его можно
  # использовать для самых разных целей. Например, человек может не только читать данные в этом формате, 
  # но и редактировать их, поэтому его естественно применять для записи конфигурационных файлов и т.п.
  # Поскольку библиотека YAML умееет выполнять маршалинг объектов Ruby, к ней относятся высказанные ранее
  # предостережения. Никогда не загружайте YAML-файлы, полученные из внешнего источника. Однако метод
  # YAML.safe_load допускает загрузку не всех классов, поэтому его можно без опаски использовать для загрузки
  # данных из ненадежных источников.
  # YAML позволяет и многое другое, о чем мы не можем здесь рассказать. Дополнительную информацию см.
  # документацию по библиотеке Ruby stdlib или официальный сайт yaml.org.
  
  # Сохранение данных с помощью библиотеки JSON
  # Хотя акроним JSON означает "JavaScript Object Notation" (объектная нотация в JavaScript), в этом формате
  # можно представить в понятном человеку виде данные, составленные из нескольких простых типов, имеющихся
  # практически в каждом языке программирования.
  # В силу своей простоты и широкой распространенности JSON стал основным форматом для передачи данных
  # между программами в Интернете.
  # Стандартная библиотека JSON используется почти также, как YAML. Сериализовать можно только хэши, массивы,
  # числа, строки, а также значения true, false, nil. Объект любого другого класса будет преобразован в строку:
  require 'json'

  data = {
         string: "Hi there",
         array: [1, 2, 3],
         boolean: true,
         object: Object.new
  }

  puts JSON.dump(data)
  # Выводится: {"string":"Hi there", "array":[1,2,3],
  #             "boolean":true, "object":"#<Object:0x007fd61b890430>"}

  # Для преобразования объектов Ruby в формат JSON и обратно необходимо написать код по аналогии с рассмотренными
  # выше методами marshal_dump и marshal_load. Существует соглашение, берущее начало в Ruby on Rails, 
  # о реализации метода as_json для преобразования объекта в типы данных, поддерживаемые JSON.
  
  # Вот так можно реализовать метод as_json для преобразования объекта Person в формат JSON и обратно:
  require 'json'
  require 'time'

  class Person
    # остальные методы не изменились...

    def as_json
      {name: @name, birthdate: @birthdate.iso8601, deposit: @deposit}
    end

    def self.from_json(json)
      data = JSON.parse(json)
      birthdate = Time.parse(data["birthdate"])
      new(data["name"], birthdate, data["deposit"])
    end
  end

  p1 = Person.new("Rudy", Time.now - (14 * 365 * 85400, 100)
  p1.as_json      # {:name=>"Rudy", :deposit=>100,
                  # :birthdate=>"2000-07-23T23:25:02-07:00"}

  p2 = Person.from_json JSON.dump(p1.as_json)
  [p2.name, p2.age, p2.balance]      # ["Rudy", 14, 197.9931600356966]
  # Поскольку JSON не позволяет сохранять объекты типа Time, мы преобразуем их в строку методом iso8601,
  # а затем - при создании нового объекта Person - восстанавливаем из этой строки объект Time.
  # Как уже было показано, библиотека JSON не поддерживает сериализацию объектов Ruby, в отличие от Marshal
  # и YAML. А значит, можно без опаски вызывать метод JSON.load для загрузки JSON-документов из ненадежных
  # источников, что позволяет использовать JSON для обмена данными с системами, которые вы не контролируете.

  # Работа с данными в формате CSV
  # Начнем с создания файла. Чтобы вывести данные, разделенные запятыми, мы просто открываем файл для записи;
  # метод open передает объект-писатель в блок. Затем с помощью оператора добавления мы добавляем массивы данных
  # (при записи они преобразуются в формат CSV). Первая строка является заголовком.
  require 'csv'

  CSV.open("data.csv", "w") do |wr|
    wr << ["name", "age", "salary"]
    wr << ["mark", "29", "34500"]
    wr << ["joe", "42", "32000"]
    wr << ["fred", "22", "22000"]
    wr << ["jake", "25", "24000"]
    wr << ["don", "32", "52000"]
  end
  # В результате исполнения этого кода мы получаем такой файл data.csv:
  "name", "age", "salary"
  "mark", 29, 34500
  "joe", 42, 32000
  "fred", 22, 22000
  "jake", 25, 24000
  "don", 32, 52000
  # Другая программа может прочитать этот файл:
  require 'csv'
  
  CSV.open('data.csv', 'r') do |row|
    p row
  end

  # Выводится:
  # ["name", "age", "salary"]
  # ["mark", "29", "34500"]
  # ["joe", "42", "32000"]
  # ["fred", "22", "22000"]
  # ["jake", "25", "24000"]
  # ["don", "32", "52000"]
  # Этот фрагмент можно было бы записать и без блока, тогда метод open просто вернул бы объект-читатель. 
  # Затем можно было бы вызвать метод shift читателя (как если бы это был массив) для получения очередной строки.
  # Но блочная форма мне представляется более естественной.
  # Каким бы способой ни был создан CSV-файл, его можно загрузить в Excel и другие электронные таблицы и там модифицировать.
  
  # SQLite3 как SQL-хранилище данных
  # Интерфейс между Ruby и SQLite3 довольно прямолинеен. Класс SQLite::Database позволяет открыть файл базы
  # и выполнять SQL-запросы к ней. Ниже приведен просто пример кода:
  require "sqlite3"

  # Открыть новую базу данных
  db = SQLite::Database.new("library.db")

  # Создать таблицу для хранения книг
  db.execute "create table books (
    title varchar(1024), author varchar(256) );"

  # Вставить в таблицу записи
  {
    "Robert Zubrin" => "The Case for Mars",
  }.each do |author, title|
    db.execute "insert into books values (?, ?)", [title, author]
  end

  # Читать записи из таблицы с использованием блока
  db.execute("select title, author from books") do |row|
    p row
  end

  # Закрыть базу
  db.close

  # Выводится:
  # ["The Case for Mars", "Robert Zubrin"]
  # ["Democracy in America", "Alexis de Tocqueville"]
  # Если блок не задан, то метод execute возвращает массив массивов, и все строки можно обойти:
  rs = db.execute("select title, author from books")
  rs.each {|row| p row}           # Тот же результат,что и выше

  # Методы библиотеки могут возбуждать различные исключения. Все они являются подклассами класса SQLite::Exception,
  # так что легко перехватываются поодиночке или целой группой.
  # Хотя библиотека sqlite в достаточной мере функциональна, сама база SQLite не полностью реализует стандарт SQL92.
  # Если вам нужна полная база данных SQL, обратитесь к PostgreSQL или MySQL.
  
  # Подключение к внешним базам данных.
  # Подключение к базе данных MySQL
  # Метод класса Mysql2::Client.new принимает несколько строковых параметров, по умолчанию равных nil, 
  # и возвращает объект-клиент. Наиболее полезны параметры host,username,password,port и database.
  # Метод клиента query используется для взаимодействия с базой данных:
  require 'mysql2'

  client = Mysql2::Client.new(
    :host => "localhost",
    :username => "root"
  )

  # Создать базу данных
  client.query("CREATE DATABASE mailing_list")

  # Воспользоваться базой данных
  client.query("USE mailing_list")

  # Если база данных уже существует, команду USE можно опустить, указав параметр database:
  # Создать таблицу для хранения имен и почтовых адресов
  client.query("CREATE TABLE members (
    name varchar(1024), email varchar(1024))")

  # Вставить строки с описанием двух подписчиков на список рассылки
  client.query <<-SQL
         INSERT INTO members VALUES
         ('John Doe', 'jdoe@rubynewbie.com'),
         ('Fred Smith', 'smithf@rubyexpert.com')
  SQL
  # Вставляя данные, не забывайте экранировать значения! Злонамеренный пользователь может отправить специально
  # сконструированные данные, которые уничтожат базу данных или даже предоставят ему права администратора.
  # Чтобы предотвратить это, перед вставкой передавайте данные методу escape.
  escaped = ["Bod Howard", "bofh@laundry.gov.uk"].map do |value|
    "'#{client.escape(value)}'"
  end
  client.query("INSERT INTO members VALUES (#{escaped.join(",")})")

  # Если в ответ на запрос был отправлен результат, то возвращается экземпляр класса Mysql2::Result, к 
  # которому подмешан модуль Enumerable. Поэтому строки результата можно перебирать методом each или
  # любым другим, входящим в состав Enumerable.
  # Запросить данные и вернуть каждую строку в виде хэша
  client.query("SELECT * from members").each do |member|
    puts "Name: #{member["name"]}, Email: #{member["email"]}"
  end
  # Выводится:
  # Name: John Doe, Email: jdoe@rubynewbie.com
  # Name: Fred Smith, Email: smithf@rubyexpert.com
  # Name: Bob Howard, Email: bofh@laundry.gov.uk

  # Поддерживаются все типы данных MySQL, а строки, числа, время и другие типы автоматически преобразуются
  # в объекты соответствующих классов Ruby.
  # Объект Result отдает каждую строку результата в виде хэша. Ключи хэша по умолчанию являются строками,
  # но можно сделать их символами, если передать методу query параметр :symbolize_keys => true.
  # Из полезных методов Result назовем еще count (количество возвращенных строк) и fields (массив имен столбцов результата)
  # Метод each может также отдавать строки результата в виде массива значений, если передать ему параметр :as=>:array.
  # Запросить данные и вернуть каждую строку в виде массива
  result = client.query("SELECT * FROM members")
  puts "#{result.count} records"
  puts result.fields.join(" - ")
  result.each(:as => :array) {|m| puts m.join(" - ")}
  # Выводится:
  # 3 records
  # name - email
  # John Doe - jdoe@rubynewbie.com
  # Fred Smith - smithf@rubyexpert.com
  # Bob Howard - bofh@laundry.gov.uk

  # Имена существующих баз данных можно получить, воспользовавшись специфичной для MySQL командой SHOW DATABASES:
  client.query("SHOW DATABASES").to_a(:as => :array).flatten
  # ["information_schema", "mailing_list", "mysql",
  #  "perfomance_schema", "test"]

  # Наконец, для закрытия соединения с базой служит метод close:
  # Закрыть соединение с базой данных
  client.close
  
  # Подключение к базе данных PostgreSQL
  # Gem-пакет pg представляет интерфейс для подключения к базе данных PostgreSQL, он устанавливается
  # командой gem install или bundle install после того, как PostgreSQL и Ruby уже установлены.
  # Как и для других адаптеров баз данных, нужно загрузить модуль, установить соединение с базой данных
  # и начать работу с таблицами. Для установления соединения в классе PG имеется метод connect.
  # У объекта соединения есть методо exec (синоним query) для отправки SQL-запросов базе данных:
  require 'pg'

  # Создать базу данных
  PG.connect.exec("CREATE DATABASE pets")

  # Открыть соединение с созданной базой данных
  conn = PG.connect(dbname: "pets")
  # Отметим, что в отличие от MySQL, для смены базы данных необходимо создать новое соедниение, а не выполнить запрос.
  # Отправка запроса с помощью библиотеки pg делается так же, как и в любой другой библиотеке SQL:
  # Создать таблицу и вставить в нее данные
  conn.exec("CREATE TABLE pets (name varchar(255),
    species varchar(255), birthday date)")
  conn.exec <<-SQL
    INSERT INTO pets VALUES
      ('Spooky', 'cat', '2008-10-03'),
      ('Spot', 'dog', '2004-06-10')
  SQL
  # Экранирование вставляемых значений существенно упрощается благодаря методу exec_params, который
  # умеет экранировать переданные ему значения:
  # Экранировать данные при вставке
  require 'date'
  conn.exec_params("INSERT INTO pets VALUES ($1, $2, $3)",
    ['Maru', 'cat', Date.today.to_s])
  # Но, в отличие от gem-пакета mysql2 пакет pg не преобразует результаты запроса в объекты соответствующих
  # классов Ruby. Все результаты возвращаются в виде строк, при необходимости их нужно будет 
  # преобразовать самостоятельно. Ниже мы вызываем метод Date.parse для каждого присутствующего в результате поля даты:
  # Запросить данные:
  res = conn.query("SELECT * FROM pets")
  puts "There are #{res.count} pets."
  res.each do |pet|
    name = pet["name"]
    age = (Date.today - Date.parse(pet["birthday"]))/365
    species = pet["species"]
    puts "#{name} is a #{age.floor}-year-old #{species}."
  end

  # Выводится:
  # There are 3 pets.
  # Spooky is a 5-year-old cat.
  # Spot is a 10-year-old dog.
  # Maru is a 0-year-old cat.

  # Метод each всегда отдает строки результата в виде хэшей, но экземпляр класса PG::Result, возвращенный
  # после выполнения запроса, может предоставлять значения в виде массива строк, каждая из которых представляет
  # собой массив. Из других полезных методов отметим еще count (количество возвращенных строк) и fields
  # (массив имен столбцов результата).
  
  # Объектно-реляцонные отображения (ORM)
  # В gem-пакете activerecord это делается с помощью отдельного класса Ruby для каждой таблицы базы данных.
  # Он умеет выполнять некоторые запросы без привлечения SQL, представляет каждую строку в виде экземпляра
  # класса и позволяет добавлять предметную логику. Имена классов соответствуют именам таблиц, и все они
  # наследуют классу ActiveRecord::Base. Для всех классов нужно только одно соединение с базой данных.
  # Вот небольшой пример, демонстрирующий весь механизм в действии:
  require 'active_record'

  class Pet < ActiveRecord::Base
  end

  ActiveRecord::Base.establish_connection(
    :adapter => "postgresql", :database => "pets")
  
  snoopy = Pet.new(name: "Snoopy", species: "dog")
  snoopy.birthday = Date.new(1950, 10, 4)
  snoopy.save

  p Pet.all.map {|pet| pet.birthday.to_s}

  # Как видите, класс умеет выводить имена таблиц, представляет акцессоры атрибутов, основанные на именах
  # столбцов, и выполняет запрос в объектно-ориентированном стиле. Кроме того, он предлагает один и тот же
  # API, включающий преобразования типов данных, для любой базы данных SQL.
  
  # Подключение к хранилищу данных Redis
  # Для подключения к серверу Rediss применяется gem-пакет redis. Если сервер работает на той же машине, что и клиент, 
  # никакие параметры вообще не нужны:
  require 'redis'
  r = Redis.new
  # Один из полезных типовв хранимых данных - множество. Redis умеет быстро вычислять разность, пересечение и объединение
  # нескольких множеств. При этом результат либо возвращается, либо сохраняется с другим ключом.
  # Сохранить клички домашних животных в множестве
  r.sadd("pets", "spooky")
  # Полуxить элементы множества
  r.smembers("pets")         # ["spooky"]
  
  # Тип хэш позволяет читать несколько полей и записывать их с общим ключом, по одному или все сразу.
  # Использовать кличку домашнего животного как ключ хэша для других его аттрибутов
  r.hset("spooky", "species", "cat")
  r.hset("spooky", "birthday", "2008-10-03")

  # Получить одно значение из хэша
  Get a single hash value
  r.hget("spooky")            # {"species"=>"cat", "birthday"=>"2008-10-03"}

  # Получить весь хэш
  r.hgetall("spooky")         # {"species"=>"cat", "birthday"=>"2008-10-03"}

  # Отсортированное множество ассоциирует с каждым значением числовую оценку и предоставляет специальные команды для 
  # увеличения и уменьшения этих оценок, а также для извлечения значения в порядке следования оценок.
  # Использовать отсортированное множестов для хранения домашних животных, отсортированных по весу
  r.zadd("pet_weights", 6, "spooky")
  r.zadd("pet_weights", 12, "spot")
  r.zadd("pet_weights", 2, "maru")

  # Выбрать первое значение из множества, отсортированного в порядке убывания
  r.zrevrange("pet_weights", 0, 0)    # => ["spot"]
  # С помощью различных предоставляемых Redis типов данных возможны и другие сложные и оптимизированные операции.
  ------------------------------------------------------------------------------
  # ООП и динамические механизмы в Ruby
  # Рутинные объектно-ориентированныые задачи
  # Применение нескольких конструкторов
  # В следующем примере приведен исскуственный пример класса для представления прямоугольника, у которого есть две длины
  # сторон и три значения цвета. Мы создали дополнительные методы класса, предполагающие определенные умолчания для
  # каждого параметра. (Например, квадрат - это прямоугольник, у которого все стороны равны.)
  class ColoredRectangle

    def initialize(r, g, b, s1, s2)
      @r, @g, @b, @s1, @s2 = r, g, b, s1, s2
    end

    def self.white_rect(s1, s2)
      new(0xff, 0xff, 0xff, s1, s2)
    end

    def self.gray_rect(s1, s2)
      new(0xff, 0xff, 0xff, s1, s2)
    end

    def self.colored_square(r, g, b, s)
      new(r, g, b , s, s)
    end

    def self.red_square(s)
      new(0xff, 0, 0, s, s)
    end

    def inspect
      "#@r #@g #@b #@s1 #@s2"
    end
  end

  a = ColoredRectangle.new(0xff, 0xff, 0xff, 20, 30)
  b = ColoredRectangle.white_rect(15, 25)
  c = ColoredRectangle.red_square(40)
  # Таким образом, можно определить любое число методов, создающих объекты по различным спецификациям. 

  # Создание аттрибутов экземпляра
  # Имени атрибута экземпляра в Ruby всегда предшествует знак @. Это обычная переменная в стом смысле, что она начинает
  # существовать после первого присваивания.
  # В ОО-языках часто создаются методы для доступа к аттрибутам, чтобы обеспечить сокрытие данных. Мы хотим контролировать
  # доступ к "внутренностям" объекта извне. Обычно для этой цели применяются методы чтения и установки (getter и setter),
  # хотя в Ruby эта терминология не используется. Они просто читают (get) или устанавливают (set) значение аттрибута.
  # Можно, конечно, запрограммировать такие функции "вручную", как показано ниже:
  class Person
    
    def name 
      @name
    end

    def name=(x)
      @name = x
    end

    def age
      @age
    end

    # ...

  end
  
  # Но Ruby предоставляет более короткий способ. Метод attr принимает в качестве параметра символ и создает
  # соответствующий атрибут. Кроме того, он создает одноименный метод чтения, а если необязательный второй
  # параметр равен true, то и метод установки.
  class Person
    attr :name, true  # Создаются @name, name, name=
    attr :age         # Создаются @age, age
  end
  # Методы attr_reader, attr_writer и attr_accessor принимают в качестве параметров произвольное число
  # символов. Первый создает только "методы чтения" (для получения значения атрибута); второй - только
  # "методы установки", а третий - то и другое. Пример:
  class SomeClass
    attr_reader :a1, :a2         # Создаются @a1, a1, @a2, a2
    attr_writer :b1, :b2         # Создаются @b1, b1=, @b2, b2=
    attr_accessor :c1, :c2       # Создаются @c1, c1, c1=, @c2, c2, c2=
    # ...

    def initialize
      @a1 = 237
      @a2 = nil
    end

  end
  # Напомним, что для выполнения присваивания атрибуту необходимо указывать вызывающий объект, а внутри метода
  # нужно в качестве такого объекта указывать self.
  def update_ones(a1, b1, c1)
    self.a1 = a1
    self.b1 = b1
    self.c1 = c1
  end
  # Если не указать self, то Ruby просто создаст внутри метода локальную переменную с указанным именем,
  # а это совсем не то, что нам нужно.
  # Существует специальный метод, позволяющий узнать, определена ли уже переменная экземпляра:
  obj = SomeClass.new
  obj.instance_variable_defined?(:b2)       # true
  obj.instance_variable_defined?(:d2)       # true
  # Повинуясь нашему желанию использовать eval только в случае острой необходимости, Ruby предоставляет
  # также методы для чтения или присваивания значения переменной, имя которой задано в виде строки:
  class MyClass
    attr_reader :alpha, :beta

    def initialize(a, b, g)
      @alpha, @beta, @gamma = a, b, g
    end
  end

  x = MyClass.new(10, 11, 12)

  x.instance_variable_set("@alpha", 234)
  p x.alpha                                  # 234

  x.instance_variable_set("@gamma", 345)      # 345
  v = x.instance_variable_get("@gamma")       # 345
  # Прежде всего обратите внимание на знак @ в имени переменной: если его опустить, произойдет ошибка.
  # Если это кажется вам интуитивно неочевидным, вспомните, что методы типа attr_accessor на самом деле
  # принимают в качестве имени метода символ, поэтому-то в них и можно опускать знак @.
  
  # Более сложные конструкторы
  # Чтобы справиться со сложностью, можно передать методу initialize блок. Тогда инициализация выполняется
  # в процессе вычисления этого блока.
  class PersonalComputer
    attr_accessor :manufacturer,
                  :model, :processor, :clock,
                  :ram, :disk, :monitor,
                  :colors, :vres, :hres, :next

    def initialize(&block)
      instance_eval &block
    end

      # Прочие методы...
  end
  
  desktop = PersonalComputer.new do
    self.manufacturer = "Acme"
    self.model = "THX-1138"
    self.processor = "986"
    self.clock = 9.6                 # ГГц
    self.ram = 16                    # Гб
    self.disk = 20                   # ТБ
    self.monitor = 25                # дюймы
    self.colors = 16777216
    self.vres = 1280
    self.hres = 1600
    self.net = "ТЗ"
  end

  p desktop
  # Отметим, что мы пользуемся акцессорами для присваивания атрибутам значений. Кроме того, в теле блока
  # можно было бы сделать все что угодно. Например, вычислить одни поля по значениям других.
  # А если мы не хотим, чтобы у объекта были акцессоры для всех атрибутов? В таком случае можно было бы
  # воспользоваться методом instance_eval и сделать методы установки защищенными - protected. Этоо предотвратит
  # "случайное" присваивание значения атрибуту извне объекта.
  class library
    attr_reader :shelves

    def initialize(&block)
      instance_eval(&block)
    end

    protected

      attr_writer :shelves
  end

  branch = Library.new do
    self.shelves = 10
  end

  branch.shelves = 20
  # NoMethodError: protected method 'shelves=' called
  branch.shelves       # 10
  # Но даже при использовании instance_eval необходимо явно вызывать метод установки от имени self.
  # Метод установки всегда вызывается от имени явно указанного объекта, чтобы отличить его от присваивания локальной переменной.
  
  # Создание атрибутов и методов уровня класса
  # В следующем далеко не полном фрагменте предполагается, что мы создаем класс для проигрывания звуковых
  # файлов. Метод play естественно реализовать как метод экземпляра, ведь можно создать много объектов, каждый
  # из которых будет проигрывать свой файл. Но, у метода detect_hardware контекст более широкий;
  # в зависимости от реализации может оказаться, что создавать какие-либо объекты вообще не имеет смысла, 
  # если этот метод возвращает ошибку. Следовательно, его контекст - вся среда воспроизведения звука, а не
  # конкретный звуково файл.
  class SoundPlayer
    MAX_SAMPLE = 192

    def self.detect_hardware
      # ...
    end

    def play
      # ...
    end

  end
  # Есть еще один способ объявить этот метод класса. В следующем фрагменте делается практически то же самое:
  class SoundPlayer
    MAX_SAMPLE = 192

    def play
      # ...
    end

  end

  def SoundPlayer.detect_hardware
    # ...
  end
  # Единственная разница касается использования объявленных в классе констант. Если метод класса объявлен
  # вне объявления самого класса, то эти константы оказываются вне области видимости. Например, в первом
  # фрагменте метод detect_hardware может напрямую обращаться к константе MAX_SAMPLE, а во втором придется
  # пользоваться нотацией SoundPlayer::MAX_SAMPLE.
  # Не удивительно, что, помимо методов класса, есть еще и переменные класса. Их имена начинаются с 
  # двух знаков @, а областью видимости является весь класс, а не конкретный его экземпляр.
  # Традиционный пример использования переменных класса - подсчет числа экземпляров этого класса.
  # Но они могут применяться всегда, когда информация имеет смысл в контексте класса в целом, а не отдельного объекта
  class Metal
    @@current_temp = 70

    attr_accessor :atomic_number

    def self.current_temp(x)
      @@current_temp = x 
    end

    def delf.current_temp
      @@current_temp
    end

    def liquid?
      @@current_temp >= @melting
    end

    def initialize(atnum, melt)
      @atomic_number = atnum
      @melting = melt
    end

  end

  aluminum = Metal.new(13, 1236)
  copper = Metal.new(29, 1982)
  gold = Metal.new(79, 1948)

  Metal.current_temp = 1600

  puts aluminum.liquid?            # true
  puts copper.liquid?              # false
  puts gold.liquid?                # false

  Metal.current_temp = 2100

  puts aluminum.liquid?            # true
  puts copper.liquid?              # true
  puts gold.liquid?                # true

  # О переменных экземпляра класса
  # Данные класса и экземпляра
  class MyClass

    SOME_CONST = "alpha"           # Константа уровня класса

    @@var = "beta"                 # Переменная класса
    @var = "gamma"                 # Переменная экземпляра класса

    def initialize
      @var = "delta"               # Переменная экземпляра
    end

    def mymethod
      puts SOME_CONST              # (константа класса)
      puts @@var                   # (переменная класса)
      puts @var                    # (переменная экземпляра)
    end

    def self.classmeth1
      puts SOME_CONST              # (константа класса)
      puts @@var                   # (переменная класса)
      puts @@var                   # (переменная класса)
      puts @var                    # (переменная экземпляра класса)
    end

  end

  def MyClass.classmeth2
    puts MyClass::SOME_CONST       # (константа класса)
    # puts @@var                   # ошибка: вне области видимости
    puts @var                      # (переменная экземпляра класса)
  end
  myobj = MyClass.new
  MyClass.classmeth1               # alpha, beta, gamma
  MyClass.classmeth2               # alpha, gamma
  myobj.mymethod                   # alpha, beta, delta
  # Следует еще сказать, что метод класса можно сделать закрытым, воспользовавшись методом private_class_method.
  # Это аналог метода private на уровне экземпляра.

  # Наследование суперклассу
  # Можно унаследовать класс, воспользовавшись символом <:
  class Boojum < Shark
    # ...
  end
  # Это объявление говорит, что класс Boojum является подклассом класса Snark или - что то же самое - 
  # класс Snark является суперклассом класса Boojum. Всем известно, что каждый буюм является снарком, но
  # не каждый снарк - буюм.
  # Ясно, что цель наследования - расширить или специализировать функциональность. Мы хотим из общего нечто более специфическое.
  
  # Рассмотрим несколько более реалистичный пример. Пусть есть класс Person(человек), а мы хотим создать
  # производный от него класс Student(студент).
  # Определим класс Person следующим образом:
  class Person
  
    attr_accessor :name, :age, :sex

    def initialize(name, age, sex)
      @name, @age, @sex = name, age, sex
    end

    # ...

  end

  # А класс Student - так:
  class Student < Person

    attr_accessor :idnum, :hours

    def initialize(name, age, sex, idnum, hours)
      super(name, age, sex)
      @idnum = idnum
      @hours = hours
    end
    # ...

  end

  # Создать два объекта
  a = Person.new("Dave Bowman", 37, "m")
  b = Student.new("Franklin Poole", 36, "m", "000-13-5031", 24)
  # Посмотрим внимательно, что здесь сделано. Что за super, вызываемый из метода initialize класса Student?
  # Это просто вызов соответствующего метода родительского класса. А раз так, то ему передается три 
  # параметра (хотя наш собственный метод initialize принимает пять).
  # Если говорить об истинном смысле наследования, то оно, безусловно, описывает отношение "является".
  # Студент является человеком, как и следовало ожидать.
  # Если вызывается некий метод от имени объекта класса Student, то будем вызван метод, определенный в этом
  # классе, если он существует. А если нет, вызывается метод суперкласса и так далее вверх по иерархии наследования.
  # Мы говорим "и так далее", потому что у каждого класса (кроме BasicObject) есть суперкласс. Попутно отметим
  # что BasicObject - "чистая доска" в мире объектов, у него даже меньше методов, чем у Object.
  # А если мы хотим вызвать метод суперкласса, но, не из соответствующего метода подкласса?
  # Можно создать сначала в подклассе синоним:
  class Student                     # повторное открытие класса
    # Предполагается, что в классе Person есть метод say_hello...
    alias :say_hi :say_hello

    def say_hello
      puts "Привет."
    end

    def format_greeting
      # Поприветствовать так, как принято в суперклассе.
      say_hi
    end
  
  # Опрос класса объекта
  # Часто возникает вопрос: "Что за объект? Как он соотносится с данным классом?" Есть много способов получить тот или иной ответ.
  # Во-первых, метод экземпляра class всегда возвращает класс объекта. Применявшийся ранее синоним type объявлен устаревшим.
  s = "Hello"
  n = 237
  sc = s.class         # String
  nc = n.class         # Integer
  
# Не думайте, будто методы class или type возвращают строку, представляющую имя класса. На самом деле возвращается
# экземпляр класса Class! При желании мы могли бы вызвать метод класса, определяемый в этом типе, как если бы
# это был метод экземпляра класса Class (каковым он в дейтствительности и является)
s2 = "some string"
var = s2.class             # String
my_str = var.new("Hi...")  # Новая строка
# Можн сравнить такую переменную с константным именем класса и выяснить, равны ли они; можно даже использовать
# переменную в роли суперкласса и определить на ее основе подкласс! 
# Иногда нужно сравнить объект с классом, чтобы понять принадлежит ли данный объект указанному классу. 
# Для этого служит метод instance_of?, например:
puts (5.instance_of? Integer)        # true
puts ("XYZZY".instance_of? Integer)  # false
puts ("PLUGH".instance_of? String)   # true

# А если нужно принять во внимание еще и отношение наследования? К вашим услугам метод kind_of? (похожий на instance_of?)
# У него есть синоним is_a?, что вполне естественно, ибо мы описываем классическое отношение "является"
n = 9876543210
flag1 = n.instance_of? Bignum     # true
flag2 = n.kind_of? Bignum         # true
flag3 = n.is_a? Bignum            # true
flag4 = n.is_a? Numeric           # true
flag5 = n.is_a? Object            # true
flag6 = n.is_a? String            # false
flag7 = n.is_a? Array             # false
# Ясно, что метод kind_of? или is_a? более общий, чем instance_of?. Например, всякая собака - млекопитающее,
# но, не всякое млекопитающее - собака.

# Для новичков в Ruby приготовлен сюрприз. Любой модуль, подмешиваемый в класс, становится субъектом отношения
# "является" для экземпляров этого класса. Например, в класс Array подмешан модуль Enumerable;
# это означает, что всякий массив является перечисляемым объектом.
x = [1, 2, 3]
flag8 = x.kind_of? Enumerable     # true
flag9 = x.is_a? Enumerable        # true
# Для сравнения двух классов можно пользоваться также операторами сравнения. Интуитивно очевидно, что 
# оператор "меньше" обозначает наследование суперклассу.
flag1 = Integer < Numeric         # true
flag2 = Integer < Object          # true
flag3 = Object == Array            # false
flag4 = IO >= File                # true
flag5 = Float < Integer           # nil
# В любом классе обычно определен оператор "тройного равенства" ===. Выражение class === instance истинно,
# если экземпляр instance принадлежит классу Class. Этот оператор еще называют оператором ветвящегося равенства, 
# потому что он неявно используется в предложении case.
# Упомянем еще метод respond_to. Он используется, когда нам безразлично, какому классу принадлежит объект,
# но мы хотим знать, реализует ли он конкретный метод. Методу respond_to передается символ и необязательный
# флаг, который говорит, нужно ли включать в рассмотрение также и закрытые методы.
# Искать открытые методы
if wumpus.respond_to?(:bite)
  puts "У него есть зубы!"
else
  puts "Давай-ка подразним его."
end

# Необязательный второй параметр позволяет просматривать и закрытые методы.
if woozle.respond_to?(:bite, true)
  puts "Вузлы кусаются!"
else
  puts "Ага это не кусающийся вузл."
end

# Иногда нужно знать, является ли данный класс непосредственным родителем объекта или класса. Ответ на этот
# вопрос дает метод superclass класса Class.
array_parent = Array.superclass           # Object
fn_parent = 237.class.superclass          # Integer
obj_parent = Object.superclass            # BasicObject
basic_parent = BasicObject.superclass     # nil
# У любого класса кроме BasicObject, есть суперкласс.

# Проверка объектов на равенство, примеры:
flag1 = (1 == 1.0)          # true
flag2 = (1.eql?(1.0))       # false - метод eql? никогда не считает объекты разных типов равными.

# Любой объект реализует еще два метода сравнения. Метод === применяется для сравнения проверяемого значения
# в предложении case с каждым селектором: selector===target. Хотя правило на первый взгляд кажется сложным
# на практике оно делает предложения case в Ruby интуитивно очевидными. Например, можно выполнить ветвление
# по классу объекта:
case an_object
  when String
    puts "Это строка"
  when Numeric
    puts "Это число"
  else
    puts "Это что-то совсем другое"
end
# Эта конструкция работает, потому что в классе Module реализован метод ===, проверяющий, что параметр принадлежит
# тому же классу, что и вызывающий объект (или одному из его предков). Поэтому, если an_object - это строка
# "cat", то выражение String === an_object окажется истинным, и буте выбрана первая ветвь в предложении case.

# Управление доступом к методам
# В Ruby объект определяется, прежде всего, своим интерфейсом: теми методами, которые он раскрывает внешнему миру.
# Но при написании класса часто возникает необходимость во вспомогательных методах, вызываать которые извне
# класса опасно. Тут-то и приходит на помощь метод private класса Module.
# Использовать его можно двумя способами. Если в теле класса или модуля вы вызовите private без параметров, 
# то все последующие методы будут закрытыми в данном классе или модуле. Если же вы передадите ему список имен
# методов (в виде символов), то эти и только эти методы станут закрытыми. Ниже показаны оба варианта:
class Bank
  def open_safe
    # ...
  end

  def close_safe
    # ...
  end

  private :open_safe, :close_safe

  def make_withdrawal (amount)
    if access_allowed
      open_safe
      get_cash(amount)
      close_safe
    end
  end

  # остальные методы закрытые

  private

  def get_cash
    # ...
  end

  def access_allowed
    # ...
  end
end

# Поскольку методы из семейства attr просто определяют методы, то метод private определяет и видимость 
# атрибутов тоже. Реализация метода private может показаться странной, но на самом деле она весьма хитроумна.
# К закрытым методам нельзя обратиться, указав вызывающий объект, они вызываются только от имени неявно
# подразумеваемого объекта self. То есть вызвать закрытый метод из другого объекта не удастся, просто 
# не существует способа указать объект, от имени которого этт метод вызывается. Заодно то означает, что
# закрытые методы доступны подклассаам того класса, в котором определены, но опять же в рамках одного объекта.
# Модификатор доступа protected налагает меньше ограничений. Защищенные методы доступны только экземплярам того
# класса, в котором определены, и его подклассов. Выше мы видели, что модификатор protected позволяет вызывать
# методы установки от имени self (при наличии модификатора private это невозможно).
# К защищенным методам можно обращаться из других объектов (при условии, что вызывающиий и вызываемый объекты
# принадлежат одному классу). Обыно защищенные методы применяются для определения методов доступа, чтобы два
# объекта одного типа могли взаимодействавать. В следующем примере объекты класса Person можно сравнивать 
# по возрасту, но сам возраст недоступен вне класса Person. Закрытый атрибут pay_scale можно прочитать
# внутри класса, но извне класса он недоступен даже другим объектам того же класса:
class Person
  attr_reader :name, :age, :pay_scale
  protected   :age
  private     :pay_scale

  def initialize(name, age, pay_scale)
    @name, @age, @pay_scale = name, age, pay_scale
  end

  def <=>(other)
    age <=> other.age   # allowed by protected
  end

  def same_rank?(other)
    pay_scale == other.pay_scale  # not allowed by private
  end

  def rank 
    case pay_scale
    when 1..3
      "lower"
    when 4..6
      "middle"
    when 7..9
      "high"
    end
  end
end

# И чтобы довершить картину, модификатор public делает метод открытым. Неудивительно.
# И последнее: методы, определенные вне любого класса и модуля (то есть на верхнем уровне программы), по
# умолчанию закрыты. Поскольку они определены в классе Object, то видимы глобально, но обращаться к ним
# с указанием вызывающег метода нельзя.

# Копирование объектов.
# Встроенные методы Object#clone и #dup порождают копию вызывающего объекта. Различаются они объемом 
# копируемого текста. Метод #dup копирует только само содержимое объекта, тогда как clone сохраняет
# и такие вещи, как синглетные классы, ассоциированные с объектом.
s1 = "cat"

def s1.upcase
  "CaT"
end

s1_dup = s1.dup
s1_clone = s1.clone
s1                     #=> "cat"
s1_dup.upcase          #=> "CAT"  (синглетный метод не копируется)
s1_clone.upcase        #=> "CaT"  (синглетный метод используется)
# И dup и clone выполняют поверхностное копирование, то есть копируют лишь содержимое самого вызывающего объекта.
# Если вызывающий объект содержит ссылки на другие объекты, то последние не копируются, копия будет ссылаться
# на те же самые объекты. Проиллюстрируем это на примере. Объект arr2[2] не оказывает влияния на arr1.
# Но исходный массив и его копия содержат ссылку на один и тот же объект String, поэтому изменение строки
# через arr2 приведет к такому же изменению значения, на котрое ссылается arr1.
arr = [ 1, "flipper", 3]
arr2 = arr1.dup

arr2[2] = 99
arr2[1][2] = 'a'

arr1                        # [1, "flapper", 3]
arr2                        # [1, "flapper", 99]

# Метод initialize_copy
# При копировании объекта методом dup или clone конструктор не вызывается. Копируется вся информация о состоянии.
# Но, что делать если вам такое поведение не нужно? Рассмотрим пример:
class Document
  attr_accessor :title, :text
  attr_reader   :timestamp

  def initialize(title, text)
    @title, @text = title, text
    @timestamp = Time.now
  end
end

doc1 = Document.new("Random Stuff", File.read("somefile"))
sleep 300                         # Немного подождем...
doc2 = doc1.clone

doc1.timestamp == doc2.timestamp  # true
# Оп... временные штампы одинаковые!
# При создании объекта Document с ним ассоциируются временная метка. При копировании объекта копируется и его 
# временная метка. А как быть, если мы хотим запомнить время, когда было выполнено копирование?
# Для этого нужно определелить метод initialize_copy. Он вызывается как раз при копированиии объекта.
# Этот метод аналогичен initialize и позволяет полностью контролировать состояние объекта.
class Document                    # Повторно открываем определение класса
  def initialize_copy(other)
    @timestamp = Time.now
  end
end

doc3 = Document.new("More Stuff", File.read("otherfile"))
sleep 300                         # Немного подождем...
doc4 = doc3.clone

doc3.timestamp == doc4.timestamp  # false
# Теперь временные метки правильны.
# Отметим, что метод initialize_copy вызывается после того, как вся информация скопирована.
# Поэтому мы и опустили строку:
@title, @text = other.title, other.text
# Кстати, если метод initialize_copy пуст, то поведение будет такое же, как если бы он не был определен вовсе.

# Метод allocate
# Редко, но бывает, что нужно создать объект, не вызывая его конструктор (в обход метода initialize).
# Например, можеть статься, что состояние объекта полностью определяется методами доступа к нему, тогда 
# не нужно вызывать метода new (который вызывает метод initialize), разве что вы сами захотите это сделать.
# Представьте, что для инициализации состояния объекта вы собираете данные по частям, тогда начать следует
# с "пустого" объекта, а не получить все данные заранее, а потом вызвать конструктор.
# Метод allocate упрощает решение этой задачи. Он возвращает "чистый", еще не инициализированный объект класса.
class Person
  attr_accessor :name, :age, :phone

  def initialize(n, a, p)
    @name, @age, @phone = n, a, p 
  end
end

p1 = Person.new("John Smith", 29, "555-1234")

p2 = Person.allocate

p p1.age      # 29
p p2.age      # nil

# Модули
# Модуль это не класс, у него не может быть экземпляровв, а к методу экземпляра нельзя обратиться, не указав
# вызывающий объект. Но, оказывается, модуль может иметь методы экземпляра. Они становятся частью класса, 
# который включил модуль директивой include.
module myMod 

  def meth1
    puts "Это метод 1"
  end

end

class MyClass

  include myMod
  # ...
end

x = MyClass.new
x.meth1                   # Это метод 1
# Здесь модуль MyMod подмешан к классу MyClass, а метод экземпляра meth1 унаследован. Вы видели также,
# как директива include употребляется на верхнем уровне программы; в таком случае модуль подмешивается
# к классу Object.
# А что происходит с методами модуля, если таковые определены? Если вы думаете, что они становятся методами
# класса, то ошибаетесь. Методы модуля не подмешиваются.
# Но если такое поведение желательно, то его можно реализовать с помощью нехитрого трюка. Существует метод
# included, который можно переопределить. Он вызывается с параметром - "целевым" классом или модулем 
# (в который включается данный модуль). 
module MyMod

  def self.included(klass)
    def klass.module method 
      puts "Module (class) method"
    end
  end

  def method_1
    puts "Method 1"
  end

end

class MyClass

  include MyMod

  def self.class_method 
    puts "Class method"
  end

  def method_2
    puts "Method 2"
  end

end

x = MyClass.new 
                             # Выводится:
MyClass.class_method         # Class method
x.method_1                   # Method 1
MyClass.module_method        # Module (class) method
x.method_2                   # Method 2
# Этот пример заслуживает детального рассмотрения. Во-первых, надо понимать, что метод included вызывается
# в ходе выполнения include. При желании мы могли бы реализовать свой метод include, определив append_features,
# но такое решение встречается гораздо реже (да и вряд ли вообще желательно).
# Отметим также, что внутри тела included имеется еще одно определение метода. Выглядит оно необычно, но, 
# работает, поскольку вложенное определение порождает синглетный метод (уровня класса или модуля).
# Попытка определить таким образом метод экземпляра привела бы к ошибке Nested method error (Ошибка при определении
# вложенного метода).
# Модуль мог бы захотеть узнать, кто был инициатором примеси. Для этого тоже мможно воспользоваться методом
# included, потому что класс-инициатор передается ему в качестве параметра.
# Можно также подмешивать метды экземпляра модуля как методы класса с помощью метода include или extend.
module MyMod 
  
  def meth3
    puts "Метод экземпляра модуля meth3"
    puts "может стать методом класса."
  end

end

class MyClass

  class << self       # Здесь self - это MyClass
    include MyMod
  end

end

MyClass.meth3

# Выводится:
# Метод экземпляра модуля meth3
# может стать методом класса.
# Здесь полезен метод extend. Тогда можно записать так:
class MyClass
  extend MyMod
end
# Также можно подмешивать модуль к объекту, а не классу (например, метод extend).
# Важно понимать одну вещь. В вашем классе можно определить методы, которые будут вызываться из примеси.
# Это эффектный прием, знакомыц тем, кто пользовался интерфейсами в Java.
# Классический пример (с которым мы уже сталкивались ранее), - подмешивание модуля Comparable и определение
# метода <=>. Поскольку подмешанные методы могут вызывать метод сравнения, то мы получаем операторы 
# <,> <= и т.д.
# Другой пример подмешивание модуля Enumerable и определение метода <=> и итератора each. Тем самым мы
# получаем ряд полезных методов: collect, sort, min, max и select.

# Можно также определять и собственные модули, ведущие себя подобным образом. Возможности ограничены только
# вашим воображением.
# Иногда объект имеет нужный вид в нужное время, а иногда хочется преобразовать его во что-то другое или
# сделать вид, что он является чем-то, чем на самом деле не является. Всем известный пример - метод to_s
# Каждый объект можно тем или иным способом представить в виде строки. Но не каждый объект может успешно
# "прикинуться" строкой. Именно в этом и состоит различие между методами to_s и to_str. 
# Рассмотрим этот вопрос подробнее. При использованиии метода puts или интерполяции в строку
# (в контексте #{...}) ожидается, что в качестве параметра будет передан объект String.
# Если это не так, объект просят преобразовать себя в String, посылая ему сообщение to_s.
# Именно здесь вы можете определить, как объект следует отобразить, просто реализуйте метод to_s
# в своем классе так, чтобы он возвращал подходящую строку.
class Pet

  def initialize(name)
    @name = name
  end

  # ...

  def to_s
    "Pet: #@name"
  end

end
# Другие методы (например, оператор конкатенации строк +) не так требовательны, они ожидают получить нечто
# достаточно близкое к объекту String. В этом случае Матц решил, что интерпретатор не будет вызывать метод
# to_s для преобразования не-строковых аргументов, поскольку это могло бы привести к большому числу ошибок.
# Вместо этого вызывается более строгий метод to_str. Из всех встроенных классов только String и Exception
# реализуют to_str, и лишь String, Regexp и Marshal вызывают его. Увидев сообщение TypeError:Failed to convert
# xyz into String, можно смело сказать, что интерпретатор пытался вызвать to_str и потерпел неудачу.
# Можно реализовать метод to_str и самостоятельно, например, чтобы строку можно было конкатенировать с числом:
class Numeric

  def to_str
    to_s
  end

end

label = "Число " + 9       # "Число 9"
# Аналогично дело обстоит и для массивов. Для преобразования объекта в массив служит метод to_a, 
# а метод to_ary вызывается, когда ожидается массив и ничего другого, например, в случае множественного
# присваивания. Пусть есть предложение такого вида:
a, b, c = X
# Если x - массив трех элементов, оно будет работать ожидаемым образом. Но, если это не массив, интерпретатор
# попытается вызвать метод to_ary для преобразования в массив. В принципе, это может быть даже синглетный
# метод (принадлежащий конкретному объекту). На само преобразование не налагается никаких ограничений, 
# ниже приведен (нереалистичный) пример, когда строка преобразуется в массив строк:
class String
  
  def to_ary
    return self.split("")
  end

end

str = "UFO"
a, b, c = str              # ["U", "F", "O"]
# Метод inspect реализует другое соглашение. Отладчики, утилиты типа irb и метод отладочной печати p
# вызывают inspect, чтобы преобразовать объект к виду, пригодному для вывода на печать. Если вы хотите,
# чтобы во время отладки объект раскрывал свое внутренее устройство, то переопределите inspect.

# Классы, содержащие только данные (Struct)
# Иногда нужно просто сгруппировать взаимосвязанные данные. Поначалу кажется, что для этого достаточно 
# воспользоваться массивом или хэшем. Но такой подход хрупок - становится трудно изменить внутреннюю структуру
# класса или добавить методы акцессоры. Можно было бы попытаться решить проблему, создав такой класс:
class Address

  attr_accessor :street, :city, :Stardate

  def initialize(street, city, state)
    @street, @city, @state = street, city, state
  end

end

books = Address.new("411 Elm St", "Dallas", "TX")

# Такое решение годится, но каждый раз прибегать к нему утомительно, к тому же здесь слишком много повторов
# Тут то и приходит на помощь встроенный класс Struct. Если вспомогательные методы типа attr_accessor определяют
# методы доступа к атрибутам, то Struct определяет целый классс, который может содержать только атрибуты.
# Такие классы называют структурными шаблонами.
Address = Struct.new("Address", :street, :city, :state)
books = Address.new("411 Elm St", "Dallas", "TX")
# Зачем передавать первым параметрам конструктора имя создаваемой структуры и присваивать результат
# в константе (в данном случае Address)?
# При вызове Struct.new для создания нового структурного шаблона на самом деле создается новый класс внутри
# самого класса Struct. Этому классу присваивается имя, переданное первым  параметром, а остальные параметры
# становятся именами атрибутов. При желании к вновь созданному классу можно было бы полуить доступ,
# указав пространство имен Struct:
Struct.new("Address", :street, :city, :state)
books = Struct::Address.new("411 Elm St", "Dallas", "TX")
# Если первый аргумент Struct.new - символ, то все аргументы считаются именами атрибутов, и класс в 
# пространстве имен Struct не создается.
# При создании класса Struct можно определить дополнительные методы, передав конструктору Struct.new блок.
# Этот блок будет вычисляться тк, будто он является телом класса - практически так же, как в определении любого класса
# Создав стуктурный шаблон, мы вызываем его метод new для создания новых экземпляров данной конкретной 
# структуры. Необязательно присваивать значения всем атрибутам в конструкторе. Опущенные атрибуты получат 
# значение nil. После того как структура создана, к ее атрибутам можно обращаться с помощью обычного синтаксиса
# или указывая их имена в скобках в качестве индекса, как будто структура - это объект класса Hash.
# Кстати, не рекомендуется создавать структуру с именем Tms, так как уже есть предопределенный класс Struct::Tms.

# Замораживание объектов
# Иногда необходимо воспрепятствовать изменению объекта. Это позволяет сделать метод freeze (определенный в класс
# Object). По существу, он превращает объект в константу.
# Попытка модифицировать замороженный объект приводит к исключению TypeError.
str = "Это тест."
str.freeze

begin
  str << " Не волнуйтесь."               # Попытка модифицировать
rescue => err 
  puts "#{err.class} #{err}"
end

arr = [1, 2, 3]
arr.freeze

begin
  arr << 4
rescue => err
  puts "#{err.class} #{err}"
end

# Выводится:
# TypeError: can't modify frozen string
# TypeError can't modify frozen array

# Замораживание строк считается особым случаем. Интерпретатор создает единственный объект замороженной 
# строки и возвращает его при каждом обращении к этой строке. Это снижает потребление памяти, если, например,
# некая строка возвращается из метода, который вызывается многократно:
str1 = "Woozle".freeze
str2 = "Woozle".freeze

str1.object_id == str2.object_id    # true

# Но хотя замораживание и предотвращает модификацию, имейте в виду, что метод freeze применяется к ссылке
# на объект, а не к переменной! Это означает, что любая операция, приводящая к созданию нового объекта,
# завершится успешно. Иногда это противоречит интуиции. В примере ниже мы ожидаем, что операция += 
# не выполнится, но все работает нормально. Дело в том, что присваивание - не вызов метода. 
# Это операция воздействует на переменные, а не объекты, поэтому новый объект создается беспрепятственно.
# Старый объект по-прежнему заморожен, но переменная ссылается уже на него.
str = "counter-"
str.freeze 
str += "intuitive"                   # "counter-intuitive"

arr = [8, 6, 7]
arr.freeze 
arr += [5, 3, 0, 9]                  # [8, 6, 7, 5, 3, 0, 9]
# Почему так происходит? Предложение a += x семантически эквивалентно a = a + x.
# При вычислении выражения a + x создается новый объект, который затем присваивается переменной a!
# Все составные операторы присваивания работают подобным образом, равно как и другие методы. Всегда задавайте
# себе вопрос: "Что я делаю - создаю новый объект или модифицирую существующий?" И тогда поведение
# freeze не станет для вас сюрпризом.
# Существует метод frozen?, который сообщает, заморожен ли данный объект.
hash = {1 => 1, 2 => 4, 3 => 9}
hash.freeze
arr = hash.to_a 
puts hash.frozen?    # true
puts arr.frozen?     # false
hash2 = hash
puts hash2.frozen?   # true
# Как видно (на примере hash2), замораживается именно объект, а не переменная.

# Использование метода tap в цепочке методов
# Методу tap передается блок, из которого имеется доступ к значению выражения, вычисляемого другими операциями.
# (По-английски, слово "tap" означает прослушивание телефона или отвод от трубы).
# Например, так можно распечатывать промежуточные значения в ходе их обработки, потому что блоку
# передается объект, от имени которого метод tap вызван:
a = [1, 5, 1, 4, 2, 3, 4, 3, 2, 5, 2, 1]
p a.sort.uniq.tap{|x| p x}.map { |x| x**2 + 2*x + 7 }
# [1, 2, 3, 4, 5]
# [10, 15, 22, 31, 42]
# Наличие такого доступа полезно само по себе, но истинная мощь tap проявляется, когда нужно изменить 
# объект внутри блока. Это позволяет программе модифицировать объект и при этом вернуть исходный объект,
# а не результат последней операции:
def feed(woozle)
  woozle.tap do |w|
    w.stomach << Steak.new
  end
end
# Не будь здесь tap, метод feed вернул бы объект stomach (желудок), в котором теперь находится steak (стейк).
# А так возвращается покормленный (и, надо полагать, довольный) вузл.
# Эта техника особенно полезна в методах класса, которые конструируют объект, вызывают какие-то методы 
# нового объекта, а затем возвращают его. Удобна она и для реализации методов, которые планируют сцеплять.

# Посылка объекту явного сообщения
# Пусть, например, имеется массив объектов, который нужно отсортировать, причем в качестве ключей сортировки
# хотелось бы использовать разные поля. Не проблема, можно просто написать специализированные блоки для 
# сортировки. Но хотелось бы найти более элегантное решение, позволяющее обойти одной процедурой, способной
# выполнить сортировку по любому указанному ключу. Ниже такое решение приведено:
class Person
  attr_reader :name, :age, :height

  def initialize(name, age, height)
    @name, @age, @height = name, age, height
  end

  def inspect
    "#@name #@age #@height"
  end
end

class Array
  
  def map_by(sym)
    self.map { |x| send(sym) }
  end
end

people = {}
people << Person.new("Hansel", 35, 69)
people << Person.new("Gretel", 32, 64)
people << Person.new("Ted", 36, 68)
people << Person.new("Alice", 33, 63)

p1 = people.map_by(:name)                 # Hansel, Gretel, Ted, Alice
p2 = people.map_by(:age)                  # 35, 32, 36, 33
p3 = people.map_by(:height)               # 69, 64, 68, 63
# Этот код на самом деле излишен, потому то можно получить тот же результат, просто вызвав метод
# map(&:name), но мы хотели проиллюстрировать использование метода send.
# Отметим еще, что синоним __send__ делает в точности то же самое. Такое странное имя объясняется, конечно,
# опасением, что имя send уже может быть задействовано (случайно или намеренно) для определенного пользователем метода.
# С методом send связана одна проблема: он позволяет обойти модель закрытости в Ruby (в том смысле, что
# закрытый метод мможно вызвать косвенно, отправив объекту строку или символ методом send). Это не ошибка
# проектирования, а сознательное решение, но если вы чувствуете себя увереннее, "защитившись" от такого
# непреднамеренного использования, то можете обратиться к методу public_send.

# Специализация отдельного объекта
# Создание синглетного метода
# В следующем примере мы видим два объекта, оба строки. Для второго мы добавляем метод upcase, который
# переопределяет существующий метод с таким же именем.
a = "hello"
b = "goodbye"

def b.upcase              # создать синглетный метод
  gsub(/(.) (.)/) { $1.upcase = $2}
end

puts a.upcase             # HELLO
puts b.upcase             # GoOdBye
# Добавление синглетного метода к объекту порождает синглетный класс для данного объекта, если он еще 
# не был создан ранее. Родителем синглетного класса является исходный класс объекта. (Можно считать, что
# это анонимный подкласс исходного класса.) Если вы хотите добавить к объекту несколько методов, то можете
# создать синглетный класс явно:
b = "goodbye"

class << B
  
  def upcase              # создать синглетный класс
    gsub(/(.) (.)/) { $1.upcase + $2 }
  end

  def upcase!
    gsub!(/(.) (.)/) { $1.upcase + $2 }
  end

end

puts b.upcase             # GoOdBye
puts b                    # goodbye
b.upcase!
puts b                    # GoOdBye
# У более "примитивных" объектов (например, Fixnum) не может быть добавленных синглетных методов. Связано
# это с тем что такие объекты хранятся как непосредственные значения, а не как ссылки. Впрочем, реализация
# подобной функциональности планируется в будущих версиях Ruby.
# Если вам приходилось разбираться в коде библиотек, то наверняка вы сталкивались с идиоматическим использованием
# синглетных классов. В определении класса иногда встречается такой код:
class SomeClass
  
  # Какой-то код...

  class << self
    # еще какой-то код...
  end

  # ... продолжение.

end
# В теле определения класса слово self обозначает сам определяемый класс, поэтому создание наследуещего
# ему синглета модифицирует класс этого класса.
# Можно сказать, что методы экземпляра синглетного класса извне выглядят как методы самого класса.
class TheClass
  class << self
    def hello
      puts "hi"
    end
  end
end

# вызвать метод класса
TheClass.hello                 # hi
# Еще одно распространенное применение данной техники - определение на уровне класса вспомогательных функций,
# к которым можно обращаться из других мест внутри определения класса. Например, мы хотим определить несколько
# функций доступа, которые преобразуют результат своей работы в строку. Можно, конечно, написать отдельно
# код каждой такой функции. Но, есть более элегантное решение - определить функцию уровня класса 
# accessor_string, которая сгенерирует необходимые нам функции. Пример ниже:
class MyClass

  class << self

    def accessor_string(*names)
      names.each do |name|
        class_eval <<-EOF
          def #{name}
            @#{name}.to_s
          end
        EOF
      end
    end
  end

  def initialize
    @a = [1, 2, 3]
    @b = Time.now
  end

  accessor_string :a, :begin
end

o = MyClass.new
puts o.a                         # 123
puts o.b                         # 2014-07-26 00:45:12 -0700

# Метод extend подмешивает к объекту модуль. Методы экземпляра, определенные в модуле, становятся методами
# экземпляра объекта. 
module Quantifier
  def two?
    2 == self.select { |x| yield x }.size
  end

  def four?
    4 == self.select { |x| yield x }.size
  end

end

list = [1, 2, 3, 4, 5]
list.extend(Quantifier)

flag1 = list.two? { |x| x > 3 }                    # => true
flag2 = list.two? { |x| x >= 3 }                   # => false
flag3 = list.four? { |x| x <= 4 }                  # => true
flag4 = list.four? { |x| x % 2 == 0 }              # => false
# В этом примере к массиву list подмешаны методы two? и four?.

# Создание параметрических классов
# Предположим, что нужно создать несколько классов, отличающихся только начальными значениями переменных
# уровня класса. Напомним, что переменная класса обычно инициализируется в самом определении класса.
class Terran

  @@home_planet = "Earth"

  def Terran.home_planet
    @@home_planet
  end

  def Terran.home_planet=(x)
    @@home_planet = x 
  end

  # ...

end
# Все замечательно, но что если нам нужно определить несколько подобных классов. Новичок подумает:
# "Так я просто определю суперкласс"
class IntelligentLife          # Неправильный способ решения задачи!

  @@home_planet = nil

  def IntelligentLife.home_planet
    @@home_planet
  end

  def IntelligentLife.home_planet=(x)
    @@home_planet = x 
  end

  # ...
end

class Terran < IntelligentLife
  @@home_planet = "Earth"
  # ...
end

class Martian < IntelligentLife
  @@home_planet = "Mars"
end
# Но это работать не будет. Вызов Terran.home_planet напечатает не "Earth" а "Mars"!
# Почему так? Дело в том, что переменные класса на деле не вполне переменные класса; они принадлежат не одному
# классу, а всей иерархии наследования. Переменная класса не копируется из родительского класса, а разделяется
# с родителем (и, стало быть, со всеми братьями).
# Можно было бы вынести определение переменной класса в базовый класс, но тогда перестали бы работать определенные
# нами методы класса! Можно было бы исправить и это, перенеся определения в дочерние классы, но это губит
# первоначальную идею, ведь таким образом объявляются отдельные классы без какой бы то ни было "параметризации"

# Мы предлагаем другое решение. Отложим вычисление переменной класса до моментна выполнения, воспользовавшись 
# методом class_eval.
class IntelligentLife

  def IntelligentLife.home_planet
    class_eval("@@home_planet")
  end

  def IntelligentLife.home_planet=(x)
    class_eval("@@home_planet = #{x}")
  end

  # ...
end

class Terran < IntelligentLife
  @@home_planet = "Earth"
  # ...
end

class Martian < IntelligentLife
  @@home_planet = "Mars"
  # ...
end

puts Terran.home_planet                            # Earth
puts Martian.home_planet                           # Mars
# Не стоит и говорить, что механизм наследования здесь по-прежнему работает. Все методы и переменные
# экземпляра, определенные в классе IntelligentLife, наследуются классами Terran и Martian.
# В следующем решении предложено, наверное, наилучшее решение. В нем используются только переменные экземпляра,
# а от переменных класса мы вообще отказались:
class IntelligentLife
  class << self
    attr_accessor :home_planet
  end

  # ...
end

class Terran < IntelligentLife
  self.home_planet = "Earth"
  # ...
end

class Martian < IntelligentLife
  self.home_planet = "Mars"
end

puts Terran.home_planet                    # Earth
puts Martian.home_planet                   # Mars
# Здесь мы открываем синглетный класс и определяем метод доступа home_planet.
# В двух подклассах определяются собственные методы доступа и устанавливается переменная. Теперь методы
# доступа работают строго в своих классах. 
# В качестве небольшого усовершенствования добавим еще вызов метода private в синглетный класс:
private :home_planet=
# Сделав метод установки закрытым, мы запретили изменять значение вне иерархии данного класса.
# Как всегда, private реализует "рекомендательную" защиту, которая легко обходится. Но объявление метода
# закрытым по крайней мере говорит, что мы не хотели, чтобы метод вызывался вне определенного контекста.

# Хранение кода в виде объектов Proc
# В этом разделе рассмотрим объкты Proc и лямбда-выражения.
# Встроенный класс Proc позволяет обернуть блок в объект. Объекты Proc, как и блоки, являютя замыканиями,
# то есть запоминают контекст, в котором были определены. Метод proc - просто сокращенная запись Proc.new
local = 12
myproc = Proc.new { |a| puts "Параметр равен is #{a}, local равно #{local}" }
myproc.call(99)                    # Параметр равен 99б local равно 12
# Кроме того, Ruby автоматически создает объект Proc, когда метод, последний параметр которого помечен
# амперсандом, вызывается с блоком в качестве параметра:
def take_block(x, &block)
  puts block.class
  x.times { |i| block[i, i*i] }
end

take_block(3) { |n, s| puts "#{n} в квадрате равно #{s}" }
# В этом примере демонстрируется также применение квадратных скобок как синонима метода call. 
# Вот что выводится в результате выполнения:
Proc
0 в квадрате равно 0
1 в квадрате равно 1
2 в квадрате равно 4
# Объект Proc можно передавать методу, который ожидает блок, предварив имя знаком &:
myproc = proc { |n| print n, "... " }
(1..3).each(&myproc)                        # 1... 2... 3...

# Возможность передавать объект Proc методу, безусловно, полезна, но если внутри Proc встретится предложение
# return, то произойдет выход из всего метода. Специальная разновидность объектов Proc - лямбда-выражение, 
# или просто лямбда - позволяет вернуть управление только из блока:
def greet(&block)
  block.call
  "Всем доброе утро."
end

philippe_proc = Proc.new { return "Слишком рано, Филипп!" }
philippe_lambda = lambda { return "Слишком рано, Филипп!" }
p greet(philippe_proc)          # Слишком рано, Филипп!
p greet(philippe_lambda)        # Всем доброе утро.
# Для создания лямбда-выражений применяется не только ключевое слово lambda, но и нотация ->.
# Но, помните, что при использовании оператора -> аргументы блока указываются во внешних фигурных скобках:
non_stabby_lambda = lambda { |king| greet(king) }
stabby_lambda = -> (king) { stab(king) }

# Хранение кода в виде объектов Method
# Ruby позволяет также превратить метод в объект непосредственно с помощью метода Object#method, который
# создает объект класса Method как замыкание, связанное с тем объектом, из которого он был создан.
str = "cat"
meth = str.method(:length)

a = meth.call                            # 3 (длина "cat")
str << "erpillar"
b = meth.call                            # 11 (длина "caterpillar")

str = "dog"
c = meth.call                            # 11 (длина "caterpillar")
# Обратите внимание на последний вызов call! Переменная str теперь ссылается на новый объект ("dog"),
# но meth по-прежнему связан со старым объектом.
# Метод public_method работает аналогично, но, как следует из названия, ищет только открытые методы 
# объекта-получателя.
# Чтобы получить метод, который можно будет использовать для любого экземпляра конкретного класса, 
# можно применить метод Module#instance_method для создания объектов UnboundMethod. Прежде чем вызывать
# объект UnboundMethod, нужно связать его с каким то объектом. Результатом операции связывания является
# объект Method, который можно вызывать как обычно:
umeth = String.instance_method(:length)

m1 = umeth.bind("cat")
m1.call                                # 3

m2 = umeth.bind("caterpillar")
m2.call                                # 11
# Связывание метода с неподходящим классом приведет к ошибке, но возможность связывания с другими объектами
# делает объект UnboundMethod интуитивно немного более понятным, чем Method.

# Использование символов в качестве блоков
# Если параметру предшествует знак амперсанда, то Ruby считает его блоком. Как мы уже видели, можно создать
# объект Proc, присвоить его переменной, а затем передать в качестве блока методу, принимающему блок.
# Однако в разделе 11.2.1 было сказано, что можно вызывать методы, принимающие блок, но только при условии
# что им передается символ, которому предшествует знак амперсанда. Как такое возможно? Ответ кроется в методе to_proc.
# Неочевидный побочный эффект передачи блока в качестве аргумента состоит в том, то если аргумент не является
# объектом Proc, то Ruby сделает попытку преобразовать его в такой, вызвав метод to_proc.
# Изобретательные программисты поняли, что этим можно воспользоваться, чтобы упростить обращения к методу map,
# и начали определять метод to_proc в классе Symbol. Реализация выглядит так:
class Symbol 
  def to_proc
    Proc.new { |obj| obj.send(self) }
  end
end

# Что позволяет вызывать map следующим образом:
%w[A B C].map(&:chr)    # [65, 66, 67]
# Этот прием оказался настолько популярным, что был включен в сам язык Ruby, и теперь им можно воспользоваться везде.

# Как работает включение модулей?
# Когда модуль включается в класс, Ruby на самом деле создает прокси-класс,являющийся непосредственным 
# родителем данного класса. Возможно, вам это покажется интуитивно очевидным, возможно, нет. Все методы
# включаемого модуля "маскируются" методами, определенными в классе.
module MyMod
  def meth
    "из модуля"
  end
end

class ParentClass
  def meth
    "из родителя"
  end
end

class ChildClass < ParentClass
  include MyMod
  def meth
    "из потомка"
  end
end

x = ChildClass.new
p x.meth                        # из потомка
# Выгляидит это как настоящее наследование: все, что потомок переопределил, становится действующим определением
# вне зависимости от того, вызывается ли include до или после переопределения.
# Вот похожий пример, в котором метод потомка вызывает super, а не просто возвращает строку.
# Модуль MyMod и класс ParentClass не изменились
class ChildClass < ParentClass
  include MyMod
  def meth
    "из потомка: super = " + super
  end
end

x = ChildClass.new
p x.meth                         # из потомка: super = из модуля
# Отсюда видно, что модуль действительно является новым родителем класса.
# А что если мы точно также вызовем super из модуля?
module MyMod
  def meth
    "из модуля: super = " + super
  end
end
# ParentClass не изменился

class ChildClass < ParentClass
  include MyMod
  def meth
    "из потомка: super= " + super
  end
end

x = ChildClass.new
p x.meth                       # из потомка: super = из модуля: super = из родителя

# У модулей припасен еще один козырь в рукаве - метод prepend. Он позволяет вставить метод модуля выше
# метода включающего класса:
# MyMod и ParentClass не изменились.

class ChildClass < ParentClass
  prepend MyMod
  def meth
    "из потомка: super " = super
  end
end

x = ChildClass.new
p x.meth    # из модуля: super из потомка: super из родителя
# Эта особенность Ruby позволяет модулям изменять поведение методов, даже если метод класса-потомка 
# не вызывает super.
# Вне зависимости от того, как включен модуль - методом include или prepend, - метод meth, определенный
# в модуле MyMod, может вызвать super только потому, что в суперклассе (точнее, хотя бы в одном из его предков)
# действительно есть метод meth. А что произошло бы, вызови мы этот метод при других обстоятельствах?
module MyMod
  def meth
    "из модуля: super = " + super
  end
end

class Foo
  include MyMod
end

x = Foo.new
x.meth
# При выполении этого кода мы получили бы ошибку NoMetodError (или обращение к методу method_missing,
# если бы таковой существовал).

# Опознание параметров, заданных по умолчанию
# Однажды Ян Макдоналд задал в списке рассылки вопрос: "Можно ли узнать, был ли параметр задан вызывающей
# программой или взято значение по умолчанию?" Интересный вопрос. 
# Было предложено по меньшей мере три решения. Самое удачное и простое нашел Нобу Накада. Вот оно:
def meth(a, b=(flag=true; 345))
  puts "b равно #{b}, а flag равно #{flag.inspect}"
end

meth(123)                             # b равно 345, а flag равно true
meth(123,345)                         # b равно 345, а flag равно nil
meth(123,456)                         # b равно 456, а flag равно nil
# Как видим, этот подход работает, даже если вызывающая программа явно указала значение параметра, совпадающее
# с подразумеваемым по умолчанию. Трюк становится очевидным, едва вы его увидите: выражение в скобках
# устанавливает локальную переменную flag в true, а затем возвращает значение по умолчанию 345.
# Это дань могуществу Ruby.

# Делегирование или перенаправление
# В Ruby есть две библиотеки, которые предлагают решение задачи о делегировании или перенаправлении 
# вызовов методов другому объекту. Они называются delegate и forwardable; мы рассмотрим обе.
# Библиотека delegate предлагает три способа решения задачи.
# Класс SimpleDelegator полезен, когда объект, которому делегируется управление (делегат), может изменяться
# на протяжении времени жизни делегирующего объекта. Чтобы выбрать объект-делегат, используется метод __setobj__.
# Метод верхнего уровня DelegateClass принимает в качестве параметра класс, которому делегируется управление.
# Затем он создает новый класс, которому мы можем унаследовать. Вот пример создания класса Queue, 
# который делегирует объекту Array:
require 'delegate'
class MyQueue < DelegateClass(Array)

  def initialize(arg=[])
    super(arg)
  end

  alias_method :enqueue, :push
  alias_method :dequeue, :shift
end

mq = MyQueue.new

mq.enqueue(123)
mq.enqueue(234)

p mq.dequeue              # 123
p mq.dequeue              # 234

# Можно также унаследовать класс Delegator и реализовать метод __getobj__;
# именно таким образом реализован класс SimpleDelegator. При этом мы получаем больший контроль над делегированием.
# Но если вам необходим больший контроль, то, вероятно, вы все равно осуществляете делегирование на уровне
# отдельных методов, а не класса в целом. Тогда лучше воспользоваться библиотекой forwardable.
# Вернемся к примеру очереди:
require 'forwardable'

class MyQueue
  extend Forwardable

  def initialize(obj=[])
    @queue = obj              # делегировать этому объекту
  end

  def_delegator :@queue, :push, :enqueue
  def_delegator :@queue, :shift, :dequeue

  def delegators :@queue, :clear, :empty?, :length, :size, :<<

  # Прочий код...
end

# Как видно из этого примера, метод def_delegator ассоциирует вызов метода (скажем, enqueue)
# с объектом-делегатом @queue и одним из методов этого объекта (push). Иными словами, когда мы вызываем метод
# enqueue для объекта MyQueue, производится делегирование методу push объекта @queue (который обычно является массивом)
# Обратите внимание, мы пишем :@queue, а не :queue. Объясняется это тем как написан класс Forwardable; 
# можно было сделать по-другому.
# Иногда нужно делегировать методы одного объекта одноименным методам другого объекта. Метод def_delegators
# позволяет задать произвольное число таких методов. Например, в примере выше показано, то вызов метода
# length объекта MyQueue приводит к вызову метода length объекта @queue.
# В отличие от первого примера, остальные методы делегирующим объектом просто не поддерживаются. Иногда
# это хорошо. Ведь не хотите же вы вызывать метод [] или []= для очереди; если вы так поступаете, то очередь
# перестает быть очередью.
# Отметим еще, что показанный выше код позволяет вызывающей программе передавать объект конструктору (для
# использования в качестве объекта-делегата). В полном соответствии с духом динамической типизации это 
# означает, что я могу выбирать вид объекта, которому делегировать управление, коль скоро он поддерживает
# те методы, которые вызываются в программе.
# Например, все приведенные ниже вызовы допустимы. (В последних двух предполагается, что предварительно было 
# выполнено предложение require 'thread'.)
q1 = MyQueue.new                                # используется любой массив
q2 = MyQueue.new(my_array)                      # используется конкретный массив
q3 = MyQueue.new(Queue.new)                     # используется Queue (thread.rb)
q4 = MyQueue.new(SizedQueue.new)                # используется SizedQueue (thread.rb)
# Так, объекты q3 и q4 волшебным образом становятся потокобезопасными, поскольку делегируют управление 
# потокобезопасному объекту (если, конечно, какой-нибудь не показанный здесь код не нарушит эту гарантию).
# Существует также класс SingleForwardable, который воздействует на один экземпляр, а не на класс в целом.
# Это полезно, если вы хотите, что какой-то конкретный объект делегировал управление другому объекту, 
# а все остальные объекты того же класса этого не делали.
# И последний вариант - ручное делегирование. В Ruby очень просто обернуть один объект другим, и это
# позволяет реализовать очередь следующим образом:
class MyQueue
  def initialize(obj=[])
    @queue = obj                                 # делегировать этому объекту
  end

  def enqueue(arg)
    @queue.push(arg)
  end

  def dequeue(arg)
    @queue.shift(arg)
  end

  %i[clear empty? length size <<].each do |name|
    define_method(name) {|*args| @queue.send(name, *args) }
  end

  # Прочий код...
end
# Как видите, в некоторых случаях использование для делегирования библиотеки не дает заметного выигрыша 
# по сравнению с написанием собственного простого кода.

# Автоматическое определение методов чтения и установки на уровне класса
# Мы уже рассматривали методы attr_reader, attr_accessor, которые немного упрощают определение методов 
# чтения и установки атрибутов экземпляра. А как же быть с атрибутами уровня класса?
# В Ruby нет аналогичных средств для их автоматического создания. Но можно написать нечто подобное
# самостоятельно. Нужно лишь открыть синглетный класс и воспользоваться в нем семейством методов attr.
# Получающиеся переменные экземпляра для синглетного класса станут переменными экземпляра класса. Часто
# это оказывается лучше, чем переменные класса, поскольку они принадлежат данному и только данному классу,
# не наспространяясь вверх и вниз по иерархии наследования.
class MyClass

  @alpha = 123                             # Инициализировать @alpha

  class << self
    attr_reader :alpha                     # MyClass.alpha()
    attr_writer :beta                      # MyClass.beta()
    attr_accessor :gamma                   # MyClass.gamma() и MyClass.gamma=()
  end

  def MyClass.look
    puts "#@alpha, #@beta, #@gamma"
  end

  #...
end

puts MyClass.alpha                         # 123
MyClass.beta = 456 
MyClass.gamma = 789
puts MyClass.gamma                         # 789

MyClass.look                               # 123, 456, 789
# Как правило, класс без переменных экземпляра бесполезен. Но здесь их для краткости опустили.

# Динамическая интерпретация кода
# Глобальная функция eval компилирует и исполняет строку, содержащую код на Ruby. Это очень мощный (и вместе
# с тем опасный) механизм, поскольку позволяет строить подлежащий исполнению код во время работы программы.
# Например, в следующем фрагменте считываются строки вида "имя = выражение", затем каждое выражение вычисляется,
# а результат сохраняется в хэше, индексированном именем переменной.
parameters = {}

ARGF.each do |line|
  name, expr = line.split(/\s*=\s*/, 2)
  parameters[name] = eval expr
end
# Пусть на вход подаются следующие строки:
a = 1
b = 2 + 3
c = 'date'
# Тогда в результате мы получим такой хэш: {"a"=>1, "b"=>5, "c"=>"Sat Jul 26 00:51:48 PDT 2014\n"}
# На этом примере демонстрируется также опасность вычисления с помощью eval строк, содержимое которых
# вы не контролируете; злонамеренный пользователь может подсунуть строку d = `rm *` и стереть все сделанное вами за день.

# Можно инкапсулировать текущую привязку в объекте с помощью метода Kernel#binding. Тогда вы сможете
# передать привязку в виде второго параметра методу eval, установив контекст исполнения для 
# интерпретируемого кода.
def some_method
  a = 'local variable'
  return binding
end

the_binding = some_method
eval "a", the_binding      # "local variable"
# Интересно, что информация о наличии блока, ассоциированного с методом, сохраняется как часть 
# привязки, поэтому возможны такие трюки:
def some_method
  return binding
end

the_binding = some_method { puts "hello" }
eval "yield", the_binding                          # hello

# Метод const_get
# Метод const_get получает значение константы с заданным именем из модуля или класса, которому она принадлежит
str = "PI"
Math.const_get(str)                                # Значение равно Math::PI
# Это способ избежать обращения к методу eval, которое иногда считается неэлегантным. Такой подход дешевле
# с точки зрения потребления ресурсов и безопаснее. Есть и другие аналогичные методы: instance_variable_set,
# instance_variable_get и define_method.
# Метод const_get действительно работает быстрее, чем eval. В неформальных тестах - на 350% быстрее, хотя у вас
# может получиться другой результат. Но так ли это важно? Ведь в тестовой программе на 10 миллионов итераций
# цикла все равно ушло менее 30 секунд.
# Истинная ценность метода const_get в том, что его проще читать, он более специфичен и лучше самодокументировван.
# Даже если бы он был всего лишь синонимом eval, все равно это стало бы большим шагом вперед.

# Получение класса по имени
# Следующий вопрос мы встречали многократно. Пусть дана строка, содержащая имя класса, как можно создать
# экземпляр этого класса?
# Имена классов в Ruby - константы в "глобальном" пространстве имен, то есть члены класса Object.
# Это означает, то правильный способ - воспользоваться методом const_get, который мы только что рассмотрели.
classname = "Array"
klass = Object.const_get(classname)
x = klass.new(4, 1)                    # [1, 1, 1, 1]
# Если константа определена внутри пространства имен, то достаточно задать строку, в которой это пространство
# имен отделено от имени константы двумя двоеточиями (как если бы вы писали прямо на Ruby):
class Alpha
  class beta
    class Gamma 
      FOOBAR = 237 
    end
  end
end

str = "Alpha::Beta::Gamma::FOOBAR"
val = Object.const_get(str)                 # 237

# Метод define_method
# Помимо ключевого слова def, единственный нормальный способ добавить метод в класс или объект - воспользоваться
# методом define_method, причем он позволяет сделать это во время выполнения.
# Конечно, в Ruby практически все происходит во время выполнения. Если окружить определение метода обращениями
# к puts, как в примере ниже, вы это сами увидите.
class MyClass
  puts "до"

  def meth
    #...
  end

  puts "после"
end

# Но внутри тела метода или в другом аналогичном месте нельзя заново открыть класс (если только это не
# синглетный класс). В таком случае в прежних версиях Ruby приходилось прибегать к помощи eval, теперь
# же у нас есть метод define_method. Он принимает символ (имя метода) и блок (тело метода).
# Отметим, однако, что define_method - закрытый метод. Это означает, что обращение к нему из определения
# класса или метода работает нормально:
class MyClass
  define_method(:body_method) { puts "Тело класса." }

  def self.new_method(name, &block)
    define_method(name, &block)
  end
end

MyClass.new_method(:class_method) { puts "Метод класса."}

x = MyClass.new
x.body_method                                # Печатается "Тело класса."
x.class_method                               # Печатается "Метод класса."

# Можно даже создать метод экземпляра, который будет динамически определять другие методы экземпляра:
class MyClass
  def new_method(name, &block)
    self.class.send(:define_method, name, &block)
  end
end

x = MyClass.new
x.new_method(:instance_method) { puts "Метод экземпляра." }
x.mymeth                                      # Печатается "Метод экземпляра."
# Здесь метод экземпляра тоже определен динамически. Изменился только способ реализации метода new_method
# Обратите внимание на трюк с send, позволивший нам обойти закрытость метода define_method. 
# Он работает, потому что метод send позволяет вызывать закрытые методы. (Некоторые сочтут это "дыркой";
# как бы то ни было, пользоваться этим механизмом следует с осторожностью.)
# По поводу метода define_method нужно сделать еще одно замечание. Он принимает блок, а в Ruby блок - замыкание.
# Это означает, что в отличие от обычного определения метода, мы запоминаем контекст, в котором метод был 
# определен. Следующий пример практически бесполезен, но этот момент иллюстрирует:
class MyClass
  def self.new_method(name, &block)
    define_method(name, &block)
  end
end

a, b = 3,79

MyClass.new_method(:compute) { a*b }
x = MyClass.new 
puts x.compute                        # 237

a,b = 23,24
puts x.compute                        # 552
# Смысл здесь в том, что новый метод может обращаться к переменным в исходной области видимости блока, 
# хотя сама эта область более не существует и никаким другим способом не доступна. Иногда это бывает полезно,
# особенно в случае метапрограммирования или при разработке графических интерфейсов, когда нужно определить
# методы обратного вызова, реагирущие на события.
# Отметим, что замыкание имеет доступ только к переменным с такими же именами. Изредка из-за этого могут
# возникать сложности. Ниже мы воспользовались методом define_method, чтобы предоставить доступ к переменной
# класса (вообще-то это следует делать не так, но для иллюстрации подойдет):
class SomeClass
  @@var = 999

  define_method(:peek) { @@var }
end

x = SomeClass.new 
p x.peek                              # 999
# А теперь попробуем проделать этот трюк с переменной экземпляра класса:
class SomeClass
  @var = 999

  define_method(:peek) { @var }
end

x = SomeClass.new
p x.peek                              # печатается nil
# Мы ожидали, что будет напечатано 999, а получили nil. С другой стороны, такой код работает правильно:
class SomeClass
  @var = 999

  x = @var
  
  define_method(:peek) { x }
end

x = SomeClass.new
p x.peek                              # 999
# Так что же происходит? Да, замыкание действительно запоминает переменные в текущем контексте. Но хотя
# замыкание и знает о переменных в своей облисти видимости, контекст метода - это контекст объекта, а не
# самого класса.
# Поскольку имя @eval в контексте экземпляра относится к переменной экземпляра объекта, а не класса, то
# переменная экземпляра класса оказывается скрыта переменной экземпляра объекта, хотя последняя никогда
# не использовалась и технически не существует.
# При работе с отдельными объектами удобной альтернативой открытию синглетного класса и определению в нем 
# метода является метод define_singleton_method.
# Работает он аналогично define_method.
# Хотя определять методы во время выполнения с помощью eval разрешено, лучше этого не делать. Во всех 
# таких случаях может и должен использоваться метод define_method. Некоторые тонкости, вроде рассмотренной 
# выще, не должны вас останавливать.

# Получение списка определенных сущностей
# API отражения в Ruby позволяет опрашивать классы и объекты во время выполения. Рассмотрим методы, 
# имеющиеся для этой цели в Module, Class и Object.
# В модуле Module есть метод constants, который возвращает массив всех констант, определенных в системе
# (включая имена классов и модулей). Метод nesting возвзращает массив всех вложенных модулей, видимых в
# данной точке программы.
# Метод экземпляра Module#ancestors возвращает массив всех предков указанного класса или модуля.
list = Array.ancestors              # [Array, Enumerable, Object, Kernel, BasicObject]
# Метод constants возвращает список всех констант, доступных в данном модуле. Включаются также его предки.
list = Math.constants  # [:DomainError, :PI, :E]
# Метод class_variables возвращает список всех переменных класса в данном классе и его суперклассах. 
# Метод included_modules возвращает список модулей, включенных в класс.
class Parent 
  @@var1 = nil
end
class Child < Parent
  @@var2 = nil
end

list1 = Parent.class_variables           # ["@@var1"]
list2 = Array.included_modules           # [Enumerable, Kernel]

# Методы instance_methods и public_instance_methods класса Class - синонимы; они возвращают список открытых
# методов экземпляра, определенных в классе. Методы private_instance_methods и protected_instance_mehtods
# ведут себя аналогично. Любой из них принимает необязательный флаг, по умолчанию равный true, если его 
# значение равно false, то суперклассы не учитываются, так что список получается меньше.
n1 = Array.instance_methods.size                      # 174
n2 = Array.public_instance_methods.size               # 174
n3 = Array.public_instance_methods(false).size        # 90
n4 = Array.private_instance_methods.size              # 84
n5 = Array.protected_instance_mehtods.size            # 0
# В классе Object есть аналогичные методы, применяющиеся к экземплярам. Метод methods возвращает список всех
# методов, которые можно вызывать для данного объекта. Метод public_methods возвращает список открытых методов
# и принимает параметр, равный по умолчанию true, который говорит, нужно ли включать также методы суперклассов.
# Методы private_methods, protected_methods и singleton_methods тоже принимают такой параметр и возвращают
# именно то что что и ожидается.
class SomeClass

  def initialize
    @a = 1
    @b = 2
  end

  def mymeth
    #...
  end

  protected :mymeth

end

x = SomeClass.new

def x.new_method
  # ...
end
iv = x.instance_variables                        # ["@b", "@a"]

p x.methods.size                                 # 61

p x.public_methods.size                          # 60

p x.public_instance_methods(false).size          # 1

p x.private_methods.size                         # 85
p x.private_methods(false).size                  # 1

p x.protected_methods.size                       # 1
p x.singleton_methods.size                       # 1

# Удаление определений.
# Радикальный способ уничтожить определение - воспользоваться ключевым словом undef (неудивительно, что его
# действие противоположно действию def). Уничтожать можно определения методов локальных переменных и констант
# на верхнем уровне. Хотя имя класса - тоже константа, удалить определение класса таким способом невозможно.
def asbestos
  puts "Теперь не огнеопасно"
end

tax = 0.08

PI = 3

asbestos
puts "PI=#{PI}, tax=#{tax}"

undef asbestos
undef tax
undef PI
# Любое обращение к этим трем именам теперь приведет к ошибке.
# Внутри определения класса, можно уничтожать определения методов и констант в том же контексте, в котором
# они были определены. Нельзя применять undef внутри определения метода, а также к переменной экземпляра.
# Существуют (определены в классе Module) также методы remove_method и undef_method. Разница между ними
# тонкая: remove_method удаляет текущее (или ближайшее) определение метода, а undef_method удаляет его также из всех
# суперклассов, не оставляя от метода даже следа.
class Parent

  def alpha
    puts "alpha: родитель"
  end

  def beta
    puts "beta: родитель"
  end
end

class Child < Parent

  def alpha
    puts "alpha: потомок"
  end

  remove_method :alpha            # Удалить "этот" alpha
  undef_method :beta              # Удалить все beta

end

x = Child.new

x.alpha                           # alpha: родитель
x.beta                            # Ошибка!
# Метод remove_const удаляет константу.
module Math

  remove_const :PI

end

# PI больше нет!

# Отметим, что таким образом можно удалить и определение класса (потому что идентификатор класса - это
# просто константа):
class BriefCandle
  #...
end

out_out = BriefCandle.new
class Object
  remove_const :BriefCandle
end

BriefCandle.new                            # NameError: uninitialized constant BriefCandle
out_out.class.new                          # Еще один экземпляр BriefCandle
# Такие методы, как remove_const и remove_method являются закрытыми (что и понятно). Поэтому во всех примерах
# они вызываются изнутри определения класса или модуля, а не снаружи.

# Ссылки на несуществующие константы
# Метод const_missing вызывается при попытке обратиться к неизвестной константе. В качестве параметра ему
# передается символ, ссылающийся на константу. Ситуация аналогична методу method_missing, который мы рассмотрим далее.
# Чтобы перехватывать обращения к отстутствующим константам глобально, определите следующий метод в самом
# классе Module (это родитель класса Class).
class Module
  def const_missing(x)
    "из Module"
  end
end

class X 
end

p X::BAR             # "из Module"
p BAR                # "из Module"
p Array::BAR         # "из Module"

# Можено выполнить в нем любые действия: вернуть фиктивное значение константы, вычислить его и т.д.
# Воспользуемся классом Roman из главы 6, чтобы трактовать любые последовательности римских цифр, как 
# числовые константы:
class Module
  def const_missing(name)
    Roman.decode(name)
  end
end

year1 = MCMLCCIV                     # 1974
year2 = MMXIV                        # 2014
# Если такая глобальность вам не нужна, определите этот метод на уровне конкретного класса. 
# Тогда он будет вызываться из этого класса и его потомков.
class Alpha
  def self.const_missing(sym)
    "В Alpha нет #{sym}"
  end
end

# В конечном итоге будет вызван method_missing, определенный в классе Object, который и возбудит исключение.
# Чтобы использование метода method_missing было безопасным, всегда определяйте метод respond_to_missing?.
# В этом случае Ruby сможет предоставить результаты как методу respond_to?, так и методу method.
# Ниже приведен пример такой техники:
class CommandWrapper                            # повторно открыть класс

  def respond_to_missing?(method, include_all)
    system("which #{method} > /dev/null")
  end

end

cw = CommandWrapper.new
cw.respond_to?(:foo)                  # false
cw.method(:echo)                      # #<Method: CommandWrapper#echo>
cw.respond_to?(:echo)                 # true
# Второй параметр (include_all) определяет, должен ли метод просматривать также закрытые и защищенные методы.
# В данном примере ни тех, ни других нет, поэтоу их можно игнорировать.
# Хотя метод respond_to_missing? является логическим дополнением к method_missing, Ruby относится к нему 
# безучастно. Можно написать только один из двух методов, если вас не смущает крайне непоследовательное поведение.

# Повышение безопасности с помощью taint
# Многие базовые методы (и, прежде всего eval) ведут себя по-другому или возбуждают исключение, если им
# передают запятнанные данные при повышенном уровне безопасности. Рассмотрим следующие примеры использования строк:
str1 = "puts 'Ответ: "
str2 = ARGV.first.dup                  # "3*79" (продублирована, чтобы разморозить)
str1.tainted?                          # false
str2.tainted?                          # true

str1.taint                             # При желании мы можем изменить состояние запятнанности
str2.untaint

eval(str1)                             # Печатается: Ответ:
puts eval(str2)                        # Печатается: 237

$SAFE = 1

eval(str1)                             # Возбуждается SecurityError: Insecure operation
puts eval(str2)                        # Печатается: 237

# Определение чистильщиков для объектов
# Можно написать код, который будет вызываться, когда сборщик мусора уничтожает объект.
a = "hello"
puts "Для строки 'hello' ид объекта равен #{a.id}"
ObjectSpace.define_finalizer(a) { id puts "Уничтожается #{id}" }
puts "Нечего убирать"
GO.start 
a = nil
puts "Исходная строка - кандидат на роль мусора"
GO.start 
# Этот код выводит следующее:
Для строки 'hello' ид объекта равен 547684890
Нечего убирать
Исходная строка - кандидат на роль мусора
Уничтожается 547684890
# Подчеркнем, что к моментуу вызова чистильщика объект уже фактически уничтожен. Попытка преобразовать 
# идентификатор в ссылку на объект с помощью метода ObjectSpace._id2ref приведет к исключению RangeError с сообщением
# о том, что вы пытаетесь воспользоваться уничтоженным объектом.
# Имейте также в виду, что в Ruby применяется консервативный механизм сборки мусора. Нет гарантии, что любой
# объект будет убран до завершения программы. Однако все это может окзаться ненужным. В Ruby существует
# стиль программирования, в котором для инкапсуляции работы с ресурсами служат блоки. В конце блока ресурс
# освобождается, и жизнь продолжается без помощи чистильщиков.
# Рассмотрим, например, блочную форму метода File.open:
File.open("myfile.txt") do |file|
  line1 = file.gets
  # ...
end
# Здесь в блок передается объект File, а по выходе из блока файл закрывается, причем все это делается под
# контролем метода open. Метод File.open ради эффективности написан на C, но на чистом Ruby он мог выглядеть
# так:
def File.open(name, mode = "r")
  f = os_file_open(name, mode)
  if block_given?
    begin
      yield f 
    ensure
      f.close 
    end
    return nil
  else
    return f 
  end
end
# Мы проверяем наличие блока. Если блок был передан, то мы вызываем его, передавая открытый файл. Делается 
# это в контексте секции begin-end, которая гарантирует, что файл будет закрыт по выходе из блока, 
# даже если произойдет исключение.

# Обход пространства объектов
# Исполняющая система Ruby должна отслеживать все известные объекты (хотя бы для того, чтобы убрать мусор,
# когда на объект больше нет ссылок). Информацию о них можно получить с помощью метода ObjectSpace.each_object.
# Если задать класс или модуль в качестве параметра each_object, то будут возвращены лишь объекты указанного типа:
ObjectSpace.each_object do |obj|
  printf "%20s: %s\n", obj.class, obj.inspect
end

# Печатается:
# Bignum: 2352398269582698756298745692875692384756923
# Bignum: 208450285028750234875023487

# Если вас интересует лишь количество созданных объектов каждого типа, то метод count_objects вернет хэш, 
# в котором ключом является тип объекта, а значением - счетчик.
require 'pp'
p ObjectSpace.count_objects
# {:TOTAL=>33013, :FREE=>284, :T_OBJECT=>2145, :T_CLASS=>901,
   :T_MODULE=>32, :T_FLOAT=>4, :T_STRING=>18999, >T_REGNUM=>167,
   :T_ARRAY=>4715, :T_HASH=>325, :T_STRUCT=>2, :T_BIGNUM=>4,
   :T_FILE=>8, :T_DATA=>1518, :T_MATCH=>205, :T_COMPLEX=>1,
   :T_NODE=>3663, :T_ICLASS=>40}
# Модуль ObjectSpace полезен также для определения чистильщиков объектов.

# Просмотр стека вызовов
# Иногда необходимо знать, кто вызвал метод. Эта информация полезна, если, например, произошло неисправимое
# исключение. Метод caller, определенный в модуле Kernel, дает ответ на этот вопрос.
# Он возвращает массив строк, в котором первый элемент соответствует вызвавшему методу, следующий -
# методу, вызвавшему этот метод, и т.д.
def func1
  puts caller[0]
end

def func2
  func1
end

# Отслеживание изменений в определении класса или объекта
# А зачем собственно? Кому интересны изменения, которым подвергался класс?
# Одна возможная причина - желание следить за состоянием выполняемой программы на Ruby. Быть может,
# мы реализуем графический отладчик, который должен обновлять список методов, добавляемых "на лету".
# Другая причина: мы хотим вносить соответствующие изменения в другие классы. Например, мы разрабатываем
# модуль, который можно включить в определение любого класса. С момента включения будут трассироваться 
# любые обращения к методам этого класса. Возможная реализация такого модуля показана ниже:
module Tracing

  def self.hook_method(const, meth)
    const.class_eval do
      alias_method "untraced_#{meth}", "#{meth}"
      define_method(method) do |*args|
        puts "вызван метод #{meth} с параметрами (#{args.join(', '})"
        send("untraced_#{meth}", *args)
      end
    end
  end

  def self.included(const)
    const.instance_methods(false).each do |m|
      hook_method(const, m)
    end

    def const.method_added(name)
      return if @disable_method_added
      puts "Метод #{name} добавлен в класс #{self}"
      @disable_method_added = true
      Tracing.hook_method(self, name)
      @disable_method_added = false
    end

    if const.is_a?(Class)
      def const.inherited(name)
        puts "Класс #{name} унаследован от #{self}"
      end
    end

    if const.is_a?(Module)
      def const.extended(name)
        puts "Класс #{name} расширил себя с помощью #{self}"
      end

      def const.included(name)
        puts "Класс #{name} включил в себя #{self}"
      end
    end

    def const.singleton_method_added(name, *args)
      return if @disable_singleton_method_added
      return if name == :singleton_method_added

      puts "Метод класса #{name} добавлен в класс #{self}"
      @disable_singleton_method_added = true
      singleton_class = (class << self; self; end)
      Tracing.hook_method(singleton_class, name)
      @disable_singleton_method_added = false
    end
  end
end
# В этом модуле два основных метода. Первый, trace_method, работает прямолинейно. При добавлении метода
# ему сразу назначается синоним untraced_name. Исходный метод заменяется кодом трассировки, который выводит
# имя и параметры метода, а затем вызывает метод, к которому было обращение.
# Обратите внимание на использование конструкции alias_method. Работает она почти так же, как alias, 
# но только для методов (да и сама является методом, а не ключевым словом). Принимает имена методов в виде
# символов или строк.
# Второй метод, included, вызывается при каждой вставке модуля в класс. Наша версия делает несколько вещей
# для отслеживания будущих вызовов метода и изменений в классе.
# Во-вторых, она вызывает метод trace_method для каждого метода, уже определенного в целевом классе.
# Это дает возможность трассировать методы, которые были определены до включения модуля Tracing. Затем она
# определяет метод класса method_added. В результате любой добавленный позже метод будет обнаружен и протрассирован.
class MyClass
  def first_meth
  end
end

class MyClass 
  include Tracing

  def second_meth(x, y)
  end

  # Выводится: метод second_meth добавлен в класс MyClass
end

m = MyClass.new
m.first_meth
# Выводится: вызван метод first_meth с параметрами ()
m.second_meth(1, 'cat')
# Выводится: вызван метод second_meth с параметрами (1, 'cat)

# Далее следуют условные предложения, к которым мы вернемся чуть позже. Наконец, модуль обнаруживает добавление
# новых синглетных методов, для чего определяет метод singleton_method_added в трассирующем классе.
# (Напомним, что синглетный метод - то, что мы обычно называем методом класса, поскольку Class - это объект.)
class MyClass
  def self.a_class_method(options)
  end
end

MyClass.a_class_method(green: "super")

# Выводится:
# Метод класса a_class_method добавлен в класс MyClass
# Метод a_class_method вызван с параметрами ({:green=>"super"})

# Обратный вызов singleton_method_added определен последним, чтобы не печаталась трассировка других методов
# класса, добавленных модулем Tracing. Отметим также, что (быть может, вопреки ожиданиям) модуль может
# отслеживать добавление в класс самого себя, следовательно, мы должны явно исключить его из трассировки.
# В первом условном предложении определяется метод inherited для каждого целевого класса Class.
# Впоследствии он будет вызываться каждый всякий раз, как этому классу наследует какой то другой:
class MySubClass < MyClass
end

# Выводится: Класс MySubClass унаследован от MyClass

# Наконец, в условном предложении для целей типа Module определяются обратные вызовы included и extended,
# чтобы можно было трассировать операции включения и расширения целевого модуля:
module MyModule
  include Tracing
end

class MyClass
  include MyModule
  extend MyModule
end

# Выводится:
# Класс MyClass включил в себя MyModule
# Класс MyClass расширил себя с помощью MyModule

# Мониторинг выполнения программы
# Программа на Ruby может следить за собственным выполнением. У этой возможности есть много применений:
# большая часть их с связана с профилированием и отладкой и будет рассмотрена далее.
# В некоторых случаях библиотеки вообще не нужны, потому что задачу можно решить на Ruby, воспользовавшись
# интроспекцией. Такой подход резко снижает производительность (и потому в режиме  эксплуатации не рекомендуется)
# но, тем не менее, класс TracePoint позволяет вызвать написанный нами код при возникновении интересующего 
# события. В примере ниже трассируются вызовы и возвраты из методов, а глубина вложенности обозначается отступами:
def factorial(n)
  (l..n).inject(:*) || 1
end

@call_depth = 0

TracePoint.trace(:a_call) do |tp|
  @call_depth += 1
  print "#{tp.defined}:#{sprintf("%-4d", tp.lineno) } #{" " * @depth}"
  puts "#{tp.defined_class}##{tp.method_id} => #{tp.return_value}"
  @call_depth -= 1
end

factorial(4)

# Здесь мы воспользовались методом TracePoint.trace, это просто сокращенный способ вызвать new, а затем
# enable. Можно также трассировать одиночный блок кода, передав его методу TracePoint#enable.
# При выполнении этой программы будет напечатано следующее:
factorial.rb:12  #<Class:TracePoint>#trace
factorial.rb:12  #<Class:TracePoint>#trace =>
                   #<TracePoint:0x007ffe8a893f10>
factorial.rb:1   Object#factorial
factorial.rb:2     Enumerable#inject
factorial.rb:2       Range#each
factorial.rb:2         Fixnum#*
factorial.rb:2         Fixnum#* => 2
factorial.rb:2         Fixnum#*
factorial.rb:2         Fixnum#* => 6
factorial.rb:2         Fixnum#*
factorial.rb:2         Fixnum#* => 24
factorial.rb:2       Range#each => 1..4
factorial.rb:2     Enumerable#inject => 24
factorial.rb:3   Object#factorial => 24
# С этим методом тесно связан метод Kernel#trace_var, который вызывает указанный блок при каждом присваивании
# значения глобальной переменной.
# Если вы хотите трассировать все вообще, то вместо тогоо чтобы писать свои трассировщики, можете затребовать
# стандартную библиотеку tracer. Ниже показана программа factorial.rb:
def factorial(n)
  (l..n).inject(:*) || 1
end

factorial(4)

# Имея эту программу, мы можем просто загрузить tracer из командной строки:
$ ruby -disable-gems -r tracer factorial.rb
# 0:factorial.rb:1::-: def factorial(n)
# 0:factorial.rb:5::-: factorial(4)
# 0:factorial.rb:1:Object:>: def factorial(n)
# 0:factorial.rb:2:Object:-:  (l..n).inject(:*) || 1
# 0:factorial.rb:2:Object:-:  (l..n).inject(:*) || 1
# 0:factorial.rb:3:Object:<: end

# Библиотека tracer выводит номер потока, имя файла и номер строки, имя класса, тип события и исполняемую
# строку исходного текста трассируемой программы. Бывают следующие типы событий: '-' - исполняется строка
# исходного текста, '>' - вызов, '<' - возврат, 'C' - класс, 'E' - конец. (Если вы не отключили Rubygems
# или затребовали еще какую то библиотеку, то будет напечатано много дополнительных строк.)
# Описанные приемы можно использовать для построения весьма развитых средств отладки и инструментовки.

# Создание потоков и манипулирование ими
# В любой программе есть по меньшей мере один поток - начальный поток управления, который мы называем "главным"
# Программа становится многопоточной, когда запускает дополнительные потоки.
# Создать поток в Ruby просто. Достаточно вызвать метод new и присоединить блок, который будет исполняться в потоке:
thread = Thread.new do
  # Предложения, исполняемые в потоке...
end
# Синонимом new является метод fork, поэтому для создания потока можно было бы написать Thread.fork вместо
# Thread.new. Вне зависимости от имени возвращается экземпляр класса Thread. С его помощью можно управлять
# потоком. А если нужно передать потоку параметры? Достаточно передать их методу Thread.new:
thread2 = Thread.new(99, 100) do |a, b|
  # начальное значение параметра a равно 99
  # начальное значение параметра b равно 100
end
# Таким образом, блок в этом примере принимает два параметра, a и b, которые в начальный момент равны 99 и 100.
# Поскольку в основе потоков лежат обычные блоки кода, поток может обращаться к переменным из той области
# видимости, в которой был создан. Это значит, что следующий поток может изменять значения x и y, поскольку
# эти переменные находились в области видимости, когда создавался ассоциированный с потоком блок.
x = 1
y = 2

thread3 = Thread.new(99, 100) do |a, b|
  # x и y видимы и могут быть изменены!
  x = 10
  y = 11
end

puts x, y 
# Опасность таких действий таится в ответе на вопрос: когда. Когда именно изменяютя значения x и y?
# Мы можем быть уверены, что это происходит после начала выполнения потока thread3, но это и все что можно
# Начав рааботать, поток живет своей жизнью, и если не предпринять каких то мер по синхронизации, вы никогда
# не узнаете, как быстро он продвигается вперед. Из-за этой непредсказуемости невозможно сказать, что будет
# напечатано в примере выше. Если thread3 завершается очень быстро, то, возможно, будут напечатаны значения
# 10 и 11. Наоборот, если thread3 задержался на старте, то могут быть напечатаны 1 и 2ю Существует даже шанс
# хотя и небольшой, что мы увидим значение 1, а сразу за ним 11, - если thread3 и главный поток идут ноздря
# в ноздрю. В реальных программах мы всеми силами стремимся избежать такого неопределенного поведения.

-----------------------------------------------------------------------
# простейшее Rack-приложение на основе класса
class MyRackApp
  def call(env)
    [200, {'Content-type' => 'text/plain'}, ["Welcome to Rack!"]]
  end
end

# Предполагается приведенное выше определение
app = MyRackApp.new
run app
-----------------------------------------------------------------------------
# определение размера массива с методами length и size
x = ["a", "b", "c", "d"]
a = x.length              # 4
b = x.size                # 4

# Сравнение массивов
# Массивы сравниваются поэлементно, первая же пара несовпадающих элементов определяет результат для сравнения (-1 или 0 или 1)
a = [1, 2, 3, 9, 9]
b = [1, 2, 4, 1, 1]
c = a <=> b                # -1 (то есть a < b)

# Сортировка массив в помощью метода sort
words = %w(the quick brown fox)
list = words.sort     # ["brown", "fox", "quick", "the"]
# Или отсортировать на месте
words.sort!           # ["brown", "fox", "quick", "the"]

# В подобных случаях можно воспользоваться также блочной формой того же метода (если у каждого элемента есть метод to_s):
a = [1, 2, "three", "four", 5, 6]
b = a.sort { |x,y| x.to_s <=> y.to_s}
# b равно [1, 2, 5, 6, "four", "three"]

# Чтобы отсортировать массив в порядке убывания, достаточно просто изменить порядок сравнения:
x = [1, 4, 3, 5, 2]
y = x.sort { |a,b| b <=> a}         # [5, 4, 3, 2, 1]


------------------------------------------------------------------------------
# использование метода grep для сопоставления
a = %w[January February March April May]
a.grep(/ary/)       # ["January", "February"]
b = [1, 20, 5, 7, 13, 33, 15, 28]
b.grep(12..24)      # [20, 13, 15]
------------------------------------------------------------------------------
# Продолжение предыдущего примера...
# Будем сохранять длины строк
a.grep(/ary/) {|m| m.length}    # [7, 8]
# Будем сохранять квадраты исходных элементов
b.grep(12..24) {|n| n*n}        # {400, 169, 225}

# Метод reject - полная противоположность select
# Он исключает из массива элементы, для которых блоок возвращает значение true
# Имеется также вариант reject! для модификации массива "на месте":
c = [5, 8, 12, 9, 4, 30]
d = c.reject { |e| 3 % 2 == 0 }        # [5, 9]
c.reject! { |e| e % 3 == 0 }
# c равно [5, 8, 4]

# Методы min и max ищут минимальное и максимальное значение в массиве
a = %w[Eldond Galadriel Aragorn Saruman Legolas]
b = a.min                                 # "Aragorn"
c = a.max                                 # "Saruman"
d = a.min {|x,y| x.reverse <=> y.reverse} # "Elrond"
e = a.max {|x,y| x.reverse <=> y.reverse} # "Legolas"

# Чтобы найти индекс минимального или максимального элемента используется метод index
# Продолжение предыдущего примера...
i = a.index a.min    # 2
j = a.index a.max    # 3

------------------------------------------------------------------------------
# Разбиение строки на лексемы. Метод split разбивает строку на части и возвращает массив лексем.
s1 = "Была темная грозовая ночь"
words = s1.split                    # ["Была", "темная", "грозовая", "ночь"]

s2 = "яблоки, груши, персики"
list = s2.split(", ")               # ["яблоки", "груши", "персики"]

s3 = "львы и тигры и медведи"
zoo = s3.split(/ и /)             # ["львы", "тигры", "медведи"]
------------------------------------------------------------------------------
# controlling Uppercase and Lowercase
s1 = "Boston Tea Party"
s2 = s1.downcase            # "boston tea party"
s3 = s2.upcase              # "BOSTON TEA PARTY"

# the capitalize method capitalizes the first character of a string while forcing all the remaining characters to lowercase
s4 = s1.capitalize          # "Boston tea party"
s5 = s2.capitalize          # "Boston tea party"
s6 = s3.capitalize          # "Boston tea party"

# the swapcase method exchanges the case of each letter in a string
s7 = "THIS IS AN ex-parrot."
s8 = s7.swapcase            # "this is an EX-PARROT."
-----------------------------------------------------------------------------
# конкатенация строк с оператором <<
str = "A"
str << [1, 2, 3].to_s << " " << (3.14).to_s
# str теперь равно "A123 3.14"
-----------------------------------------------------------------------------

# получение длины строки
str1 = "Карл"
x = str1.length   # 4
str2 = "Дойль"
x = str2.size     # 5
-----------------------------------------------------------------------------
# Построчная обработка
str = "Когда-то\nдавным-давно...\nКонец\n"
num = 0
str.each_line do |line|
    num += 1
    print "Строка #{num}: #{line}"
end

# результат...
# Строка 1: Когда-то
# Строка 2: давным-давно...
# Строка 3: Конец
-----------------------------------------------------------------------------
# побайтовая обработка
str = "ABC"
str.each_byte { |byte| print byte, " "}
puts
# результат 65 66 67
-----------------------------------------------------------------------------
# подсчет числа определенных символов в строке
s1 = "abracadabra"
a = s1.count("c")     # 1
b = s1.count("bdr")   # 5

c = s1.count("^a")    # 6
d = s1.count("^bdr")  # 6

e = s1.count("a-d")   # 9
f = s1.count("^a-d")  # 2
-----------------------------------------------------------------------------
# обращение строки
s1 = "Star Trek"
s2 = s1.reverse          # "kerT ratS"
s1.reverse!              # s1 теперь равно "kerT ratS"

# обращение порядка слов, а не символов
phrase = "Now here's a sentence"
phrase.split(" ").reverse.join(" ")   # "sentence a here's Now"
-----------------------------------------------------------------------------
# Удаление дубликатов. Цепочки повторящихся символов можно сжать до одного методом squeeze
s1 = "bookkeeper"
s2 = s1.squeeze      # "bokeper"
s3 = "Hello..."
s4 = s3.squeeze      # "Helo."
# Если указан параметр, то будут удаляться только дубликаты заданных в нем символов
s5 = s3.squeeze(".") # "Hello."
-----------------------------------------------------------------------------
# Удаление заданных символов
s1 = "To be, or not to be"
s2 = s1.delete("b")           # "To e, or not to e"
s3 = "Veni, vidi, vici!"      
s4 = s3.delete(",!")          # "Veni vidi vici"
-----------------------------------------------------------------------------
# Generating Successive Strings Генерирование последовательности строк
droid = "R2D2"
improved = droid.succ            # "R2D3"
pill = "Vitamin B"
pill2 = pill.succ                # "Vitamin C"
-----------------------------------------------------------------------------
# Вычленение и замена подстрок
str = "Шалтай-Болтай"
sub1 = str[7,4]                # "Болт"
sub2 = str[7,99]               # "Болтай" (выход за границу строки допускается)
sub3 = str[10,-4]              # nil (отрицательная длина)
# если индекс отрицательный, то отсчет ведется от конца строки (в этом случае индекс начинается с единицы, а не с нуля)
str1 = "Алиса"
sub1 = str1[-3, 3]             # "иса"
str2 = "В Зазеркалье"         
sub3 = str2[-8, 6]             # "зеркал"

# Можно задавать диапазон. Он интерпретируется как диапазон позиций внутри строки
str = "Уинстон Черчилль"
sub1 = str[8..13]       # "Черчил"
sub2 = str[-4..-1]      # "илль"
sub3 = str[-1..-4]      # nil
sub4 = str[25..30]      # nil

# Если задано регулярное выражение, то возвращается строка по образцу, если нет соответствия, то nil
str = "Alistair Cooke"
sub1 = str[/l..t/]      # "list"
sub2 = str[/s.*r/]      # "stair"
sub3 = str[/foo/]       # nil

# Если задана строка, то она и возвращается, если встречается в качестве подстроки в исходной строке, в противном случае возвращается nil
str = "theater"
sub1 = str['heat']      # "heat"
sub2 = str["eat"]       # "eat"
sub3 = str["ate"]       # "ate"
sub4 = str["beat"]      # nil
sub5 = str["cheat"]     # nil

str = "Aaron Burr"
ch1 = str[0]            # "A"
ch2 = str[1]            # "a"
ch3 = str[99]           # nil

# важно понимать, что все описанные выше способы могут использоваться не только для досупа к построке, но, и для ее замены
str1 = "Шалтай-Болтай"
str1[7,3] = "Хва"                         # "Шалтай-Хватай"

str2 = "Алиса"
str2[-3,3] = "ександра"                   # "Александра"

str3 = "В Зазеркалье"
str3[-9, 9] = "стеколье"                  # "В Застеколье"

str4 = "Уинстон Черчилль"
str4[8..11] = "Х"                         # "Уинстон Хилль"

str5 = "Alistair Cooke"
str[/e$/] = "ie Monster"                  # "Alistair Cookie Monster"

str6 = "theater"
str6["er"] = "re"                         # "theatre"

str7 = "Aaron Burr"
str7[0] = "B"                             # "Baron Burr"
# присваивание выражения, равного nil, не оказывает никакого действия

------------------------------------------------------------------------------
# метод sub заменяет первое вхождение строки, соответствующей образцу другой строкой или результатом вычисления блока
s1 = "spam, spam, and eggs"
s2 = s1.sub(/spam/, "bacon")
# "bacon, spam, and eggs"

s3 = s2.sub(/(\w+), (\w+),/,'\2, \1,')
# "spam, bacon, and eggs"

s4 = "Don't forget the spam."
s5 = s4.sub(/spam/) { |m| m.reverse }
# "Don't forget the maps"

s4.sub!(/spam/) { |m| m.reverse }
# s4 is now "Don't forget the maps."

# метод gsub (глобальная подстановка) отличается от sub тем, что заменяет все вхождения, а не только первое
s5 = "alfalfa abracadabra"
s6 = s5.gsub(/a[bl]/, "xx")        # "xxfxxfa xxracadxxra"
s5.gsub!(/[lfdbr]/) { |m| m.upcase + "-" }
# s5 теперь равно "aL-F-aL-F-a aB-R-acaD-aB-R-a"
-----------------------------------------------------------------------------
# поиск в строке
# метод index возвращает начальную позицию заданной построки, символа или регулярного выражения
str = "Albert Einstein"
pos1 = str.index(?E)            # 7
pos2 = str.index("bert")        # 2
pos3 = str.index(/in/)          # 8
pos4 = str.index(?W)            # nil
pos5 = str.index("bart")        # nil
pos6 = str.index(/wein/)        # nil

# метод rindex начинает поиск с конца строки, но, номера позиций отсчитываются, тем не менее, от начала
str = "Albert Einstein"
pos1 = str.rindex(?E)          # 7
pos2 = str.rindex("bert")      # 2
pos3 = str.rindex(/in/)        # 13 (найдено самое правое соответствие)
pos4 = str.rindex(?W)          # nil
pos5 = str.rindex("bart")      # nil
pos6 = str.rindex(/wein/)      # nil

# метод include? сообщает, встречается ли в данной строке указанная подстрока или один символ

str1 = "mathematics"
flag1 = str1.include? ?e       # true
flag2 = str1.include? "math"   # true
str2 = "Daylight Saving Time"
flag3 = str2.include? ?s       # false
flag4 = str2.include? "Savings" # false

# метод scan многократно просматривает строку в поисках указанного образца
# будучи вызван внутри блока, он возвращает массив
# если образец содержит несколько (заключенных в скобки) групп, то массив окажется вложенным
str1 = "abracadabra"
sub1 = str1.scan(/a./)
# sub1 теперь рано ["ab","ac","ad","ab"]
str2 = "Acapulco, Mexico"
sub2 = str2.scan(/(.)(c.)/)
# sub2 теперь равно [ ["A", "ca"], ["l", "co"], ["i", "co"]]

# если при вызове задан блок, то метод поочередно передает этому блоку найденные значения
str3 = "Kobayashi"
str3.scan(/[^aeiou]+[aeiou]/) do |x|
  print "Слог: #{x}\n"
end
# код выше выведет такой результат:
Слог: Ko 
Слог: ba 
Слог: ya 
Слог: shi 
-------------------------------------------------------------------------------
# Преобразование символов в коды ASCII и обратно
# одиночные символы в Ruby возвращаются в виде односимвольных строк:
str = "Martin"
print str[0]          # "M"

# В классе Integer имеется метод chr, который преобразует целое число в символ
# в классе String имеется метод ord, выполняющий противоположное действие.
str = 77.chr          # "M"
s2 = 233.chr("UTF-8") # "e"
num = "M".ord         # 77

-------------------------------------------------------------------------------
# Удаление хвостовых символов новой строки и прочих
# Метод chop удаляет последний символ строки (\n) и символ перевода каретки (\r) если он стоит перед ним.
str = gets.chop            # Прочитать, удалить символ новой строки
s2 = "Some string\n"       # "Some string" (нет символа новой строки)
s3 = s2.chop!              # s2 теперь тоже равно "Some string"
s4 = "Other string\r\n"    
s4.chop!                   # "Other string" (нет символа новой строки)
# при вызове варианта chop! операнд-источник модифицируется

# важно отметить, что при использовании метода chop последний символ удаляется даже если это не символ новой строки
str = "abcxyz"
s1 = str.chop              # "abcxy"

# поскольку символ новой строки присутствует не всегда, иногда удобнее применять метод chomp
str = "abcxyz"
str2 = "123\n"
str3 = "123\r"
str4 = "123\r\n"
s1 = str.chomp             # "abcxyz"
s2 = str2.chomp            # "123"
# если установлен стандартный разделитель записей, то удаляется не только \n, но также \r и \r\n
s3 = str3.chopm            # "123"
s4 = str4.chomp            # "123"

# если методу chomp передана строка-параметр, то удаляются перечисленные в ней символы, а не подразумеваемый по умолчанию разделитель записей
str1 = "abcxyz"
str2 = "abcxyz"
s1 = str1.chomp("yz")      # "abcx"
# кстати, если разделитель записей встречается в середине строки, то он удаляется:
s2 = str2.chomp("x")       # "abcxyz"
-----------------------------------------------------------------------------------
# Убирание лишних пропусков (пробелов, символов табуляции и перехода на новую строку)
# Метод strip удаляет пропуски в начале и в конце строки, а вариант strip! делает то же самое "на месте"
str1 = "\t \nabc \t\n"
str2 = str1.strip          # "abc"
str3 = str1.strip!         # "abc"
# str1 теперь тоже равно "abc"

# чтобы удалить пропуски только в начале или только в конце строки, применяются методы lstrip и rstrip
str = " abc "
s2 = str.lstrip            # "abc "
s3 = str.rstrip            # " abc"
# имеются также варианты lstrip! и rstrip! для удаления "на месте".
-----------------------------------------------------------------------------------
# Повтор строк
# Если строку умножить на n, то получится строка, состоящая из n конкатенированных копий исходной:
etc = "Etc. " * 3          # "Etc. Etc. Etc. "
ruler = "+" + ("." * 4 + "5" + "." * 4 + "+") * 3
# "+....5....+....5....+....5....+"
-----------------------------------------------------------------------------------
# Включение выражений в строку с помощью синтаксической конструкции #{}
# Нет нужды думать о преобразовании, добавлении и конкатенации, нужно лишь интерполировать переменную или выражение в любое место строки:
puts "#{temp_f} по Фаренгейту равно #{temp_c} по Цельсию"
puts "Значение определителя равно #{b*b - 4*a*c}."
puts "#{word} это #{word.reverse} наоборот"

# Внутри фигурных скобок могут находиться даже полные предложения. При этом возвращается результат вычисления последнего выражения
str = "Ответ равен #{ def factorial(n)
                        n == ? 1 : n*factorial(n-1)
                      end

                      answer = factorial(3) * 7}, of course."
# Ответ равен 42, естественно.

# При интерполяции глобальных переменных, а также переменных класса и экземпляра фигурные скобки можно опускать:
puts "$gvar = #$gvar и ivar = #@ivar."
----------------------------------------------------------------------------------
# Возведение в степень обозначается оператором **, эта операция подчиняется обычным математическим правилам.
a = 64**2          # 4096
b = 64**0.5        # 8.0
c = 64**0          # 1
d = 64**-1         # 0.015625

# При делении одного целого числа на другое в Ruby дробная часть отбрасывается
# если один и операндов с плавающей точкой, то результат также будет с плавающей точкой
3 / 3              # 1
5 / 3              # 1
3 / 4              # 0
3.0 / 4            # 0.75
3 / 4.0            # 0.75
3.0 / 4.0          # 0.75

# Если вы работаете с переменными и сомневаетесь относительно их типа, воспользуйтесь приведением типа к Float или методом to_f:
z = x.to_f / y
z = Float(x) / y
-----------------------------------------------------------------------------------------------
# Округление чисел с плавающей точкой
# Метод round округляет число с плавающей точкой до целого:
pi = 3.14159
new_pi = pi.round        # 3
temp = -47.6
temp2 = temp.round       # -48

# В случае, когда надо округлить не до целого, а до заданного числа знаков после запятой, можно воспользоваться
# функциями sprintf (которая умеет округлять) и eval
pi = 3.1415926535
pi6 = eval (sprintf("%8.6f",pi))       # 3.141593
pi5 = eval (sprintf("%8.5f",pi))       # 3.14159
pi4 = eval (sprintf("%8.4f",pi))       # 3.1416
# Это не слишком красиво. Поэтому инкапсулируем оба вызова функций в метод, который добавим в класс Float:
class Float

  def roundf(places)
    temp = self.to_s.length
    sprintf("%#{temp}.#{places}f",self).to_f
  end

end
--------------------------------------------------------------------------------------
# Диапазоны
# Открытые и замкнутые диапазоны
# Диапазон называют замкнутым, если он включает конечную точку и открытым, в противном случае
r1 = 3..6       # замкнутый
r2 = 3...6      # открытый
a1 = r1.to_a    # [3,4,5,6]
a2 = r2.to_a    # [3,4,5]
# нельзя сконструировать диапазон, который не включал бы начальную точку. Можно считать это ограничением языка Ruby.

# Нахождение границ диапазона
# Методы first и last возвращают соответственно левую и правую границу диапазона. У них есть синонимы begin и end
r1 = 3..6
r2 = 3...6
r1a, r1b = r1.first, r1.last        # 3, 6
r1c, r1d = r1.begin, r1.end         # 3, 6
r2a, r2b = r1.begin, r1.end         # 3, 6

# метод exclude_end? сообщает, включена ли в диапазон конечная точка:
r1.exclude_end?   # false
r2.exclude_end?   # true

# обход диапазона:
(3..6).each { |x| puts x}           # печатаются четыре строки
                                    # скобки обязательны
# Проверка принадлежности к диапазону
r1 = 23456..34567
x = 14142
y = 31416
r1.include?(x)              # false
r1.include?(y)              # true
# у этого метода есть также синоним member?

# Преобразование в массив
r = 3..12
arr = r.to_a    # [3,4,5,6,7,8,9,10,11,12]

# Обратные диапазоны
r = 6..3
x = r.begin                 # 6
y = r.end                   # 3
flag = r.end_excluded?      # false
------------------------------------------------------------------------------------------
# Определение текущего момента времени
t0 = Time.new 
# Синонимом служит Time.now
t0 = Time.now

------------------------------------------------------------------------------------------
# Определение дня недели
# Способ с методом to_a. Можно обратиться к седьмому элементу массива (от 0 до 6), который соответствует дню недели (0 - воскресенье, а 6 - суббота)
time = Time.now
day = time.to_a[6]          # 2 (вторник)
# Еще лучше воспользоваться методом экземпляра wday:
day = time.wday             # 2 (вторник)
# Но оба вышеописанные методы не очень удобны. Есть еще один метод - strftime, который распознает около 20 спецификаторов
# позволяя по-разному форматировать дату и время
day = time.strftime("%A")        # "Tuesday"
# можно получить и сокращенное название
tln = time.strftime("%a")       # "Tue"

# Определение порядкового номера дня в году:
t = Time.now
day = t.yday                    # 315

# Определение часового пояса
z1 = Time.gm(2000,11,10,22,5,0).zone            # "UTC"
z2 = Time.local(2000,11,10,22,5,0).zone         # "PST"

# Прибавление интервала к моменту времени
t0 = Time.now
t1 = t0 + 60       # Ровно одна минута с момента t0
t2 = t0 + 3600     # Ровно один час с момента t0
t3 = t0 + 86400    # Ровно один день с момента t0

# можно вычислить интервал между двумя моментами времени
# в результате вычитания одного объекта Time из другого получаем количество секунд:
today = Time.local(2014,11,10)
yesterday = Time.local(2014,11,9)
diff = today - yesterday                  # 86400 секунд

# Преобразование часовых поясов, в случае если заранее известна разница во времени:
mississipi = Time.local(2014,11,13,9,35)        # 9:35 am CST
calofornia = mississipi - 2*3600                # Минус два часа

time1 = mississipi.strftime("%X CST")           # 09:35:00 CST
time2 = california.strftime("%X PST")           # 07:35:00 PST

# Если нужно часто преобразовывать время из одного часового пояса в другой, то можно воспользоваться
# расширением класса Time, предоставляемое gem-пакетом ActiveSupport
require 'active_support/time'
Time.zone = -8
Time.zone.name          # "Тихоокеанское время (США и Канада)"
Time.zone.now           # Wed, 25 Jun 2014 12:20:35 PDT -07:00
Time.zone.now.in_time_zone("Hawaii")  # 09:20:36 HST -10:00
----------------------------------------------------------------------------------------
# Выборка массива по заданному критерию
# Метод detect находит не больше одного элемента. Он принимает блок (которому элементы передаются последовательно)
# и возвращает первый элемент, для которого значение блока оказывается равным true
x = [5, 8, 12, 9, 4, 30]
# найти первый элемент, кратный 6
x.detect { |e|  e % 6 == 0}           # 12
# найти первый элемент, кратный 7
x.detect { |e| e % 7 == 0}           # nil

# Метод find - синоним detect, метод find_all возвращает несколько элементов, а не один единственный,
# а select - синоним find_all
# Продолжение предыдущего примера...
x.find { |e| e % 2 == 0}           # 8
x.find_all { |e| e % 2 == 0}       # [8, 12, 4, 30]
x.select { |e| e % 2 == 0}         # [8, 12, 4, 30]

# Массивы. Объединение и пересечение (операторы | (или) и &)
a = [1, 2, 3, 4, 5]
b = [3, 4, 5, 6, 7]
c = a | b                   # [1, 2, 3, 4, 5, 6, 7]
d = a & b                   # [3, 4, 5]

# Дубликаты удаляются...
e = [1, 2, 2, 3, 4]
f = [2, 2, 3, 4, 5]
g = e & f                   # [2, 3, 4]

# Для объединения множеств можно использовать и оператор конкатенации (+),
# но он не удаляет дубликаты
# Метод (-) позволяет удалить все одинаковые элементы множеств и оставить только те, которые не повторялись
a = [1, 2, 3, 4, 5]
b = [4, 5, 6, 7]
c = a - b                 # [1, 2, 3]
# Отметим, что наличие элементов 6 и 7 не отражается на результате

# Чтобы проверить входит ли некий элемент в множество, пользуйтесь методом include? или member?
x = [1, 2, 3]
if x.include? 2
  puts "yes"              # Печатается "yes"
else
  puts "no"
end
# Еще вариант:
class Object

  def in(other)
    other.include? self
  end

end

x = [1, 2, 3]
if 2.in x 
  puts "yes"              # Печатается "yes"
else
  puts "no"
end
---------------------------------------------------------------------------------------------------------
# Рандомизация массива
# Чтобы поставить элементы массива в случайном порядке можно воспользоваться методом shuffle:
x = [1, 2, 3, 4, 5]
y = x.shuffle               # [3, 2, 4, 1, 5]
x.shuffle!                  # x равно [3, 5, 4, 1, 2]

# Выбрать случайный элемент массива можно с помощью метода sample:
x = [1, 2, 3, 4, 5]
x.sample                    # 4
x.sample(2)                 # [5, 1]

# Удаление элементов, равных nil из массива
# Метод compact (и его вариант compact! для модификации на месте) удаляет из массива элементы, равные nil, оставляя все остальные без изменения:
a = [1, 2, nil, 3, nil, 4, 5]
b = a.compact                 # [1, 2, 3, 4, 5]
a.compact!                    # a равно [1, 2, 3, 4, 5]

# Удаление заданных элементов из массива
# Чтобы удалить элемент с известным индексом, достаточно вызвать метод delete_at:
a = [10, 12, 14, 16, 18]
a.delete_at(3)                # Возвращает 16
# a равно [10, 12, 14, 18]
a.delete_at(9)                # Возвращает nil (вне диапазона)

# Все элементы с заданным значением поможет удалить метод delete
# Он возвращает значения удаленных элементов или nil, если искомый элемент не найден:
b = %w(spam spam bacon spam eggs ham spam)
b.delete("spam")                           # Возвращает "spam"
# b равно ["bacon", "eggs", "ham"]
b.delete("caviar")                         # Возвращает nil

# Метод delete принимает также блок. Это не вполне согласуется с интуицией; если объект не найден, происходит
# вычисление блока (при этом могут выполняться различные операции) и возвращается вычисленное значение.
c = ["alpha", "beta", "gamma", "delta"]
c.delete("delta") { "Nonexistent"}
# Возвращается "delta" (блок не вычисляется)
c.delete("omega") { "Nonexistent"}
# Возвращается "Nonexistent"

# Метод delete_if передает каждый элемент массива в блоок и удаляет те элементы
# для которых вычисление блока дает true
email = ["job offer", "greetings", "spam", "news items"]
# удалить слова из четырех букв
email.delete_if { |x| x.length == 4 }
# email равно ["job offers", "greetings", "news items"]

# Метод slice! получает доступ к тем же элементам, что и slice, но, помимо
# возврата их значений, еще и удаляет из массива:
x = [0, 2, 4, 6, 8, 10, 12, 14, 16]
a = x.slice!(2)                       # 4
# x равно [0, 2, 6, 8, 10, 12, 14, 16]
b = x.slice!(2, 3)                    # [6, 8, 10]
# x равно [0, 2, 12, 14, 16]
c = x.slice!(2..3)                    # [12, 14]
# x равно [0, 2, 16]

# Для удаления элементов массива можно также пользоваться методами shift и pop
x = [1, 2, 3, 4, 5]
x.pop                                 # Удалить последний элемент
# x равно [1, 2, 3, 4]
x.shift                               # Удалить первый элемент
# x равно [2, 3, 4]

# Метод reject принимает блок и формирует новый массив без тех элементов, для которых блок возвращает true:
arr = [1, 2, 3, 4, 5, 6, 7, 8]
odd = arr.reject { |x| x % 2 == 0}             # [1, 3, 5, 7]

# Наконец метод clear удаляет из массива все элементы:
x = [1, 2, 3]
x.clear
# x равно []

# Конкатенирование массивов и добавление в конец массива
# Оператор << добавляет объект в конец массива, в качестве значения он возвращает сам массив, поэтому можно объединять
# в цепочку несколько таких операций:
x = [1, 5, 9]
x << 13                  # x равно [1, 5, 9, 13]
x << 17 << 21            # x равно [1, 5, 9, 13, 17, 21]

# Аналогичную операцию выполняют методы unshift и push, которые добавляют элемент в начало и в конец массива соответственно:
x = [1, 5, 9]
x.push *[2, 6, 10]                 # x равно [1, 5, 9, 2, 6, 10]
x.unshift 3                        # x равно [3, 1, 5, 9, 2, 6, 10]

# Массивы можно конкатенировать методом concat или с помощью операторов + b +=:
x = [1, 2]
y = [3, 4]
z = [5, 6]
b = y + z                      # [3, 4, 5, 6]
b += x                         # [3, 4, 5, 6, 1, 2]
z.concat y                     # z равно [5, 6, 3, 4]

# Оператор += всегда создает новый объект. Также не забываем, что оператор << добавляет в конец новый элемент, который сам может быть массивом:
a = [1, 2]
b = [3, 4]
a += b                         # [1, 2, 3, 4]

a = [1, 2]
b = [3, 4]
a << b                         # [1, 2, [3, 4]]

a = [1, 2]
b = [3, 4]
a = a.concat(b)                # [1, 2, 3, 4]
-------------------------------------------------------------------------------------------------------------
# Обход массива делается с помощью стандартного итератора each, однако есть и другие полезные итераторы, например - reverse_each,
# который обходит массив в обратном порядке:
words = %w(Son I am able she said)
str = ""
words.reverse_each { |w| str += "#{w} "}
# str равно "said she able am I Son "

# Итератор each_with_index (подмешанный из модуля Comparable) передает в блок как сам элемент, так и его индекс:
x = ["alpha", "beta", "gamma"]
x.each_with_index do |x, i|
  puts "Элемент #{i} равен #{x}"
end
# выводится три строки

# Предположим, что нужно обойти массив в случайном порядке. Ниже представлен итератор random_each (который просто вызывает метод shuffle)
class Array

# Предполагается, что метод randomize определен

  def random_each
        self.shuffle.each { |x| yield x}
  end

end

dwarves = %w(Sleepy Dopey Happy Sneezy Grumpy Bashful Doc)
list = ""
dwarves.random_each {|x| list += "#{x} "}
# list равен:
# "Bashful Dopey Sleepy Happy Grumpy Doc Sneezy"
# (На вашей машине порядок может быть другим.)

# Часто бывает необходимо вставить разделители между элементами массива, но не перед первым и не после последнего
# Для этого предназначен метод join и оператор *
been_there = ["Veni", "vidi", "vici."]
journal = been_there.join(", ")                 # "Veni, vidi, vici."

letters = ["Phi", "Mu", "Alpha"]
musicians = letters.join(" ")                   # "Phi Mu Alpha"

people = ["Bob", "Carol", "Ted", "Alice"]
movie = people * " and "
# movie равно "Bob and Carol and Ted and Alice"

# Если необходимо последний элемент обрабатывать особым образом, например, вставить перед ним слово "and",
# то можно сделать это вручную:
list = %w[A B C D E F]
with_commas = list[0..-2] *", " + ", and " + list[-1]
# with_commas равно "A, B, C, D, E, and F"

# Чередование массивов
# Предположим, что есть два массива и надо построить из них третий, который содержит массивы из двух элементов, взятых из 
# соответствующих позиций исходных массивов. Это делает метод zip из модуля Enumerable:
a = [1, 2, 3, 4]
b = ["a", "b", "c", "d"]
c = a.zip(b)
# c равно [[1,"a"], [2,"b"], [3,"c"], [4, "d"]]

# Чтобы устранить вложенность - воспользуемся методом flatten:
d = c.flatten
# d равно [1, "a", 2, "b", 3, "c", 4, "d"]

# Если задан блок, то создаваемые подмассивы будут один за другим передаваться ему:
a.zip(b) { |x1, x2| puts x2 + "-" + x1.to_s}
# Печатается: a-1
#             b-2
#             c-3
#             d-4
# и возвращается nil

# Вычисление частоты различных значений в массиве
# Для массивов нет метода count, как для строк. Поэтому создадим свой собственный:
class Array

  def count
    each_with_object(Hash.new(0)){|x,h| h[x] += 1}
  end

end

meal = %w[spam spam eggs ham eggs spam]
items = meal.counts
# items равно {"ham" => 1, "spam" => 3, "eggs" => 2}
spams = items["spam"]                    # 3
# Обратите внимание, что метод возвращает хэш
-----------------------------------------------------------------------------------------
# Инвертирование массива для получения хэша
class Array

  def invert
    each_with_object({}).with_index{|(x,h),i| h[x] = i}
  end

end

a = ["red", "yellow", "orange"]
h = a.invert        # {"orange"=>2, "yellow"=>1, "red"=>0}
------------------------------------------------------------------------------------------
# Создание нового хэша
# Как и в случае класса Array, для создания хэша слушит специальный метод класса []
# Данные, перечисленные в квадратных скобках, образуют ассоциированные пары
# Ниже показаны шесть способов вызвать этот метод (все хэши содержат одни и те же данные)
a1 = Hash.[]("flat",3, "curved", 2)
a2 = Hash.[]("flat"=>3, "curved"=>2)
b1 = Hash["flat", 3, "curved", 2]
b2 = Hash["flat"=>3, "curved"=>2]
c1 = {"flat", 3, "curved", 2}                  # Почему то выдает ошибку, возможно устарел синтаксис
c2 = {"flat"=>3, "curved"=>2}
# Для a1, b1, c1: число элементов должно быть четным.

# Существует также альтернативный синтаксис для задания литерального хэша в частном случае, когда ключами являются символы
# Начальное двоеточие в нем опускается, а стрелка заменяется двоеточием:
h1 = {:alpha => 123, :beta => 456}
h2 = {alpha: 123, beta: 456}
h1 == h2 # true

# Имеется также метод класса new, который может принимать параметр, задающий значение по умолчанию
# Это значение не является частью хэша, оно просто возвращается вместо nil
d = Hash.new                          # Создать пустой хэш
e = Hash.new(99)                      # Создать пустой хэш
f = Hash.new("a"=>3)                  # Создать пустой хэш
e["angled"]                           # 99
e.inspect                             # "{}"
f["b"]                                # {"a"=>3} (значением по умолчанию)
                                      # является тоже хэш
f.inspect                             # "{}"

# Наконец, упомянем о методе to_h из класса Array, он преобразует произвольный массив двухэлементных массивов в хэш,
# состоящий из ключей и значений:
g = [["a", 1]].to_h  # {"a" => 1}

# Задание значения по умолчанию для хэша
# Значением по умолчанию для хэша является объект, возвращаемый вместо nil в случае, когда указанный ключ не найден
# Это полезно, если вы планируете вызывать для возвращенного значения методы, которые для nil не определены.
# Задать значение по умолчанию можно в момент создания хэша или позже с помощью метода default=
a = Hash.new("missing")                # объект по умолчанию - строка "missing"
a["hello"]                             # "missing"
a.default="nothing"
a["hello"]                             # "nothing"
a["good"] << "bye"                     # "nothingbye"
a.default                              # "nothingbye"

# В отличие от метода default, блок позволяет задать свое значение вместо каждого отсутствующего ключа.
# Типичная идиома - хэш, для которого значением по умолчанию является массив, так что элементы можно добавлять,
# не проверяя явно, что значение отсутствует, и не создавая пустой массив:
a = Hash.new{|h, key| h[key] = []}            # Значением по умолчанию является new []
a["hello"]                                    # []
a["good"] << "bye"                            # {"good" => ["bye"]}

# Имеется также специальный метод экземпляра fetch, который возбуждает исключение IndexError, если в объекте
# типа Hash нет указанного ключа. Он принимает также второй параметр, играющий роль значения по умолчанию.
# Кроме того, методу fetch можно передать необязательный блок, который выработает значение по умолчанию, если ключ
# не будет найден. Принцип здесь такой же, как при создании значений по умолчанию блоком.
a = {"flat" => 3, "curved" => 2, "angled" => 5}
a.fetch("pointed")                               # IndexError
a.fetch("curved", "na")                          # 2
a.fetch("x", "na")                               # "na"
a.fetch("flat") {|x| x.upcase }                  # 3
a.fetch("pointed") {|x| x.upcase }               # "POINTED"

# Доступ к парам ключ-значение и добавление новых пар.
# В классе Hash есть методы класса [] и []=
# Используются они почти так же, как одноименные методы в классе Array, но принимают лишь один параметр.
# В качестве параметра может выступать любой объект, а не только строка (хотя строки используются чаще всего)
a = {}
a["flat"] = 3                       # {"flat"=>3}
a.[]=("curved", 2)                  # {"flat"=>3, "curved"=>2}
a.store("angled", 5)                # {"flat"=>3, "curved"=>2, "angled"=>5}
# Метод store - просто синоним []=, оба могут принимать два аргумента, как показано в примере выше.
# Метод [] аналогичен методу fetch, но не возбуждает исключение IndexError, когда ключи отсутствует, а возвращает nil
a.fetch("flat")                     # 3
a.[]("flat")                        # 3
a["flat"]                           # 3
a["bent"]                           # nil

# Предположим, что мы не уверены, существует ли объект Hash, но хотели бы избежать очистки имеющегося хэша.
# Очевидное решение - проверить, определен ли интересующий нас объект:
a = {} unless defined? a 
a["flat"] = 3
# Но есть и другой, более идиоматический, способ:
a ||= {}
a["flat"] = 3
# Или даже так:
(a ||= {})["flat"] = 3
# Тот же вопрос можно поставить для отдельных ключей, когда новое значение следует присваивать лишь, если такого ключа еще нет:
a = Hash.new(99)
a[2]                           # 99
a                              # {}
a[2] ||= 5                     # 99
a                              # {}
b=Hash.new
b                              # {}
b[2]                           # nil
b[2] ||= 5                     # 5
b                              # {2=>5}
# Отметим, что nil может выступать и в качестве ключа, и в качестве значения:
b={}
b[2]                           # nil
b[3]=nil                           
b                              # {3=>nil}
b[2].nil?                      # true
b[3].nil?                      # true
b[nil]=5                       
b                              # {3=>nil, nil=>5}
b[nil]                         # 5
b[b[3]]                        # 5

# Удаление пар ключ-значение
# Удалить пары ключ-значение из хэша можно с помощью методов clear, delete, delete_if, reject! и shift.
# Метод clear удаляет из хэша все пары. Метод shift удаляет незаданную пару ключ-значение и возвращает ее в виде
# массива из двух элементов или nil, если никаких ключей не осталось.
a = {1=>2, 3=>4}
b = a.shift                    # [1, 2]
# a равно {3=>4}

# Метод delete удаляет конкретную пару ключ-значение. Он принимает в качестве параметра ключ и возвращает ассоциированное
# с ним значение, если такой ключ существовал (и был удален). В противном случае возвращается значение по умолчанию.
# Метод также принимает блок, который вырабатывает уникальное значение по умолчанию вместо того, чтобы возвращать ссылку на общий объект.
a = {1=>1, 2=>4, 3=>9, 4=>16}
a.delete(3)                    # 9
# a равно {1=>1, 2=>4, 4=>16}
a.delete(5)                    # в этом случае nil
a.delete(6) { "не найдено" }   # "не найдено"

# Обход хэша.
# В классе Hash имеется стандартный итератор each, а кроме него итераторы each_key, each_pair и each_value (each_pair синоним each)
{"a" => 3, "b" => 2}.each do |key, val|
  print val, "from", key, "; "             # 3 from a; 2 from b;
end
# Остальные два итератора передают в блок только ключ или только значение:
{"a" => 3, "b" => 2}.each_key do |key|
  print "key = #{key};"                    # Prints: key = a; key = b;

{"a" => 3, "b" => 2}.each_value do |value|
  print "val = #{value};"                  # Prints: val = 3; val = 2;
end
# Инвертирование хэша
# Инвертирование хэша осуществляется в Ruby тривиально с помощью метода invert:
a = {"fred"=>"555-1122", "jane"=>"555-7779"}
b = a.invert
b["555-7779"]                               # "jane"

# Поиск ключей и значений в хэше
# Определить, было ли присвоено значение некоторому ключу, позволяет метод has_key? или любой из его синонимов include?, key?, member?:
a = {"a"=>1, "b"=>2}
a.has_hey? "c"       # false
a.include? "a"       # true
a.key? 2             # false
a.member? "b"        # true
# Можно также воспользоваться методом empty?, чтобы узнать, остался ли в хэше хотя бы один ключ.
# А метод length и его синоним size позволяют узнать, сколько ключей имеется в хэше:
a.empty?             # false
a.length             # 2
# Можно подтвердить также, существует ли указанное значение.
# Для этого предназначены методы has_value? или value?:
a.has_value? 2       # true
a.value?     99      # false

# Копирование хэша в массив.
# Чтобы преобразовать весь хэш в массив, пользуйтесь методом to_a.
# Получившийся массив содержит двухэлементные массивы, содержащие пары ключ-значение:
h = {"a" => 1, "b" => 2}
h.to_a                    # [["a", 1], ["b", 2]]
# Можно также получить массив, содержащий только ключи или только значения:
h.heys                    # ["a", "b"]
h.values                  # [1, 2]
# Наконец, можно поместить в массив только значения, соответствующие заданному списку ключей. 
# Этот метод работает для хэшей примерно так же, как одноименный метод для массивов.
# (Кроме того, как и в случае массивов, метод values_at заменяет устаревшие методы indices и indexes.)
h = {1=>"one", 2=>"two", 3=>"three", 4=>"four", "cinco"=>"five"}
h.values_at(3,"cinco",4)                  # ["three", "five", "four"]
h.values_at(1, 3)                         # ["one", "three"]

# Выборка пар ключ-значение по заданному критерию
# К классу Hash подмешан модуль Enumerable, поэтому можно обращаться к методам detect(find), select(find_all), grep, min, max и reject (как и для массивов).
# Метод detect (синоним find) находит одну пару ключ-значение. Он принимает блок (которому передается по одной паре за раз) и возвращает первую пару,
# для которой вычисление блока дает true.
names = {"fred"=>"jones", "jane"=>"tucker",
         "joe"=>"tucker","mary"=>"SMITH"}
# Найти tucker
names.detect { |k, v| v == "tucker" }              # ["joe", "tucker"]
# Найти имена, записанные заглавными буквами
names.find { |k, v| v == v.upcase }                # ["mary", "SMITH"]

# Разумеется, объекты в хэше могут быть сколько угодно сложными, как и условие, проверяемое в блоке, но
# сравнение объектов разных типов может оказаться проблематичным
# Метод select (синоним find_all) возвращает все пары, удовлетворяющие условию, а не только первую:
names.select { |k, v| v == "tucker" }
# [["joe", "tucker"], ["jane", "tucker"]]
names.find_all { |k, v| k.count("r")>0}
# [["mary", "SMITH"], ["fred", "jones"]]

# Сортировка хэша
# Хэши по своей природе не упорядочены ни по ключам, ни по значениям. Чтобы отсортировать хэш, Ruby преобразует его в массив,
# а затем сортирует этот массив. Понятно, что и результатом является массив.
names = {"Jack"=>"Ruby", "Monty"=>"Python",
         "Blaise"=>"Pascal", "Minnie"=>"Perl"}
list = names.sort
# list равно:
# [["Blaise", "Pascal"], ["Jack", "Ruby"],
# ["Minnie", "Perl"], ["Monty", "Python"]]
# Ниже показано, как такой массив преобразовать обрабно в хэш:
list_hash = list.to_h

# Объединение двух хэшей
# Иногда нужно объеденить хэши. Метод merge получает два хэша и формирует из них третий, перезаписывая обнаружившиеся дубликаты:
dict = {"base" => "foundation", "pedestal" => "base"}
added = {"base" => "non_acid", "salt" => "NaCL"}
new_dict = dict.merge(added)
# {"base" => "non-acid", "pedestal" => "base", "salt" = "NaCl"}
# У метода merge есть синоним update

# Если задан блок, то он может содержать алгоритм устранения коллизий. В примере ниже, если два ключа совпадают, 
# то в объединенном хэше остается меньшее значение (по алфавиту, по числовому значению или в каком то ином смысле):
dict = {"base" => "foundation", "pedestal" => "base"}
added = {"base" => "non-acid", "salt" => "NaCL"}
new_dict = dict.merge(added) { |key,old,new| old < new ? old : new}
# {"salt" => "NaCl", "pedestal" => "base", "base" => "foundation"}
# Таким образом, при использовании блока результат может получиться не такой, как в случае, когда блок не задан.
# Имеются также методы merge! и update!, которые изменяют вызывающий объект "на месте".

# Создание хэша из массива.
# Простейший способ сделать это - прибегнуть к методу to_h массива, содержащего двухэлементные массивы.
# Можно также воспользоваться методом [] класса Hash, которому передаются либо двухэлементные массивы, либо один
# массив, содержащий четное число элементов.
pairs = [[2, 3], [4, 5], [6, 7]]
array = [2, 3, 4, 5, 6, 7]
h1 = pairs.to_h                         # {2 => 3, 4 => 5, 6 => 7}
h2 = Hash[pairs]                        # {2 => 3, 4 => 5, 6 => 7}
h3 = Hash[*array]                      # {2 => 3, 4 => 5, 6 => 7}

# Вычислениие разности и пересечения хэшей
a = {"a" => 1, "b" => 2, "z" => 3}
b = {"x" => 99, "y" => 88, "z" => 77}
intersection = a.keys & b.keys
difference = a.keys - b.keys
c = a.dup.update(b)
inter = {}
intersection.each { |k| inter[k] = c[k] }
# inter равно {"z" = 77}
diff={}
difference.each { |k| diff[k]=c[k] }
# diff равно {"a"=> 1, "b"=>2}

# Хэш как разреженная матрица
# Часто в массиве или матрице заполнена лишь небольшая часть элементов. Можно хранить их как обычно, но такое
# расходование памяти неэкономно. Хэш позволяет хранить только реально существующие значения.
# В следующем примере предполагается, что несуществующие значения о умолчанию равны нулю:
values = Hash.new(0)
values[1001] = 5
values[2010] = 7
values[9237] = 9
x = values[9237]            # 9
y = values[5005]            # 0
# Ясно, что обычный массив в таком случае содержал бы более 9000 неиспользуемых элементов, что не всегда приемлемо.
# А если нужно реализовать разреженную матрицу размерности два или более?
# В этом случае можно было бы использовать массивы в качестве ключей:
cube = Hash.new(0)
cube[[2000, 2000, 2000]] = 2
z = cube[[36, 24, 36]]      # 0
# Здесь обычная матрица содержала бы миллиарды элементов.

# Хэши обычно индексируются на основе значений ключей. При желании можно изменить подобное поведение, так чтобы
# сравнение производилось по идентификатору объекта. Метод compare_by_identity переводит хэш в этот специальный режим,
# а метод compare_by_identity? сообщает, в каком режиме находится хэш:
h1 = { "alpha" => 1, :echo => 2, 35 => 3 }
h2 = h1.dup.compare_by_identity

h1.compare_by_identity?                  # false
h2.compare_by_identity?                  # true

a1 = h1.values_at("alpha", :echo, 35)    # [1, 2, 3]
a2 = h2.values_at("alpha", :echo, 35)    # [nil, 2, 3]
# Причина продемонстрированного выше поведения, конечно же, в том, что симвоы и целые числа в Ruby являются
# непосредственными значениями (как и true, false, nil).
# Однако же для строк в кавычках создаются разные объекты с разными идентификаторами.

# Метод inject. Этот метод пришел в Ruby из языка Smalltalk. В качестве примера рассмотрим массив чисел,
# которые нужно просуммировать:
nums = [3, 5, 7, 9, 11, 13]
sum = nums.inject(0) { |x,n| x + n }
# Обратите внимание, что начальное значение аккумулятора равно 0 ("нейтральный элемент" для операци сложения).
# Затем блок получает текущее значение аккумулятора и значение текущего элемента списка.
# Действие блока заключается в прибавлении нового значения к текущей сумме. Ясно, что этот код эквивалентен следующему:
sum = 0
nums.each { |n| sum += n}
# Начальное значение аккумулятора задавать необязательно. Если оно опущено, то в качестве такового используется
# значение первого элемента, который при последующих итерациях опускается.
sum = nums.inject { |x, n| x + n}
# То же самое, что:
sum = nums[0]
nums[1..-1].each { |n| sum += n}

# Похожий пример - вычисление произведения чисел. В данном случае аккумулятору следует присвоить начальное 
# значение 1 (нейтральный элемент для операции умножения)
prod = nums.inject(1) {|x,n| x*n}
# или
prod = nums.inject {|x,n| x*n}

# В следующем немного более сложном примере мы находим самое длинное слово в списке:
words = %w[ alpha beta gamma delta epsilon eta theta ]
longest_word = words.inject do |best,w|
  w.length > best.length ? w : best
end
# возвращается значение "epsilon"

# Кванторы. Кванторы any? и all? упрощают проверку свойств коллекции. Оба квантора принимают в качестве
# параметра блок (который должен возвращать значение true или false).
nums = [1, 3, 5, 8, 9]
# Есть ли среди чисел четные?
flag1 = nums.any? {|x| x % 2 == 0}      # true

# Все ли числа четные?
flag2 = nums.all? {|x| x % 2 == 0}      # false

# Если блок не задан, то просто проверяется значение истинности каждого элемента. Иными словами, неявно добавляется блок {|x| x}.
flag1 = list.all?                       # list не содержит ни одного false или nil
flag2 = list.any?                       # list содержит хотя бы одно истинное значение
                                        # не nil и не false

# Метод partition. Если при вызове метода задан блок, то этот блок вычисляется для каждого элемента набора.
# В результате создается два массива, в первый попадают элементы, для которых блок вернул true, во второй - остальные.
# Метод возвращает массив, двумя элементами которогоо являются эти массивы.
nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]

odd_even = nums.partition { |x| x % 2 == 1 }
# [[1,3,5,7,9], [2,3,4,6,8]]

under5 = nums.partition { |x| x < 5 }
# [[1,2,3,4], [5,6,7,8,9]]

squares = nums.partition { |x| Math.sqrt(x).to_i**2 == x }
# [[1,4,9], [2,3,5,6,7,8]]

# Обход с группировкой
# Иногда желательно на каждой итерации анализировать по два, три или более элементов.
# Итератор each_slice принимает в качестве параметра число n, равное числу просматриваемых на каждой
# итерации элементов. Если не осталось достаточного количества, то размер последнего фрагмента будет меньше.
arr = [1,2,3,4,5,6,7,8,9,10]
arr.each_slice(3) do |triple|
  puts triple.join(",")
end

# Выводится:
# 1,2,3
# 4,5,6
# 7,8,9
# 10

# Имеется также итератор each_cons, который позволяет обходить набор методом "скользящего окна" заданного размера
# В таком случае фрагменты всегда будут иметь одинаковый размер.
arr = [1,2,3,4,5,6,7,8,9,10]
arr.each_cons(3) do |triple|
  puts triple.join(",")
end
# Выводится:
# 1,2,3
# 2,3,4
# 3,4,5
# 4,5,6
# 5,6,7
# 6,7,8
# 7,8,9
# 8,9,10

# Преобразование в массив или множество
# Каждая перечисляемая структура теоретически может быть тривиально преобразована в массив (методом to_a)
# Например, такое преобразование для хэша дает вложенный массив пар:
hash = {1=>2, 3=>4, 5=>6}
arr = hash.to_a                 # [[5, 6], [1, 2], [3, 4]]

# Синонимом метода to_a является метод entries.
# Если была затребована библиотека set, становится доступен метод to_set.
require 'set'
hash = {1=>2, 3=>4, 5=>6}
set = hash.to_set               # #<Set: {[1, 2], [3, 4], [5, 6]}>

# Перечислители
# Итераторный метод each не требует задания блока. Если блок не задан, то метод возвращает объект-перечислитель:
items = [1,2,3,4]
enum = items.each
enum.each { |x| puts x }        # Печатает числа по одному в строке

# 8.3.6 Пример внешнего итерирования
people = [2, "George", "Washington",
          3, "Edgar", "Allan", "Poe",
          2, "John", "Glenn",
          4, "Little", "Red", "Riding", "Hood",
          1, "Sting"]
enum = people.each
loop do
       count = enum.next         # Получить следующий элемент из массива
       count.times { print enum.next }
       puts
end

# Существует метод rewind, который "сбрасывает" внутреннее состояние, возвращаясь к началу перечисляемой последовательности:
list = [10, 20, 30, 40, 50]
enum = list.each 
puts enum.next      # 10
puts enum.next      # 20
puts.enum.next      # 30
enum.rewind
puts enum.next      # 10

# Метод with_index является простым (внутренним) итератором. Его можно использовать
# вместе с другим перечислителем, и возвращает он итератор:
list = [10, 20, 30, 40, 50]
list.each.with_index {|x,i| puts "list[#{i}] = #{x}" }
# или...
enum = list.each.with_index
loop { x, i = enum2.next; puts "list[#{i}] = #{x}" }   # такой же результат

# Дополнительные сведения о перечисляемых объектах
# Поиск и выборка
# Метод find_index ищет первый объект, равный переданному параметру и возвращает его индекс (индексация с нуля):
array = [10, 20, 30, 40, 50, 30, 20]
location = array.find_index(30)                # результат равен 2

# Методы first и last возвращают n первых или последних элементов коллекции (по умолчанию один):
array = [14, 17, 23, 25, 29, 35]
head = array.first                             # 14
tail = array.last                              # 35
front = array.first(2)                         # [14, 17]
back = array.last(3)                           # [25, 29, 35]

# Существуют также два квантора: one? и none?. Метод one? понять легко: чтобы он вернул true,
# вычисление блока кода должно дать результат true ровно один раз:
array = [1, 3, 7, 10, 15, 17, 21]
array.one? {|x| x % 2 == 0}                    # true (одно четное число)
array.one? {|x| x > 16}                        # false
[].one? {|x| true}                             # для пустого массива всегда возвращается false
# Но, вот none? не столь интуитивно очевиден. Он возвращает true, если при вычислении блока ни разу не получилось true.
array = [1, 3, 7, 10, 15, 17, 21]
array.none? {|x| x > 50}                       # true (значение блока равно false для всех элементов)
array.none? {|x| x == 1}                       # false
[].none? {|x| true}                            # true (для пустого массива блок не выполняется)
# Если блок опущен, то для каждого элемента коллекции проверяется, похож ли он на true или на false.
# Метод возвращает true, только если все проверки дают false.

# Подсчет и сравнение.
# С методом count все просто. Он может принимать параметр, блок или ничего. В последнем случае просто
# возвращается размер коллекции. Если параметром является объект, то подсчитывается количество вхождений этого 
# объекта (сравнение производится с помощью оператора ==). Если задан блок, то подсчитывается количество
# элементов коллекции, для которых блок возвращает true.
days = %w[Sunday Monday Tuesday Wednesday Thursday Friday Saturday]
days.count                         # всего 7
days.count("Saturday")             # 1 (суббота только одна!)
days.count {|x| x.length == 6}     # есть три 3 слова из шести букв
# С методами min и max мы уже встречались. Для их работы необходимо, чтобы существовал оператор <=>
# (или был включен модуль Comparable). Существует также метод minmax, который возвращает сразу
# и минимальный, и максимальный элемент массива:
days = %w[Sunday Monday Tuesday Wednesday Thursday Friday Saturday]
days.minmax     # ["Friday", "Wednesday"]
# Если для сравнения элементов нужно использовать более сложное правило, то можно прибегнуть
# к методам min_by, max_by и minmax_by, которые принимают произвольный блок кода
# (по аналогии с методом sort_by, рассмотренным выше в этой главе):
days = %w[Sunday Monday Tuesday Wednesday Thursday Friday Saturday]
days.min_by {|x| x.length}                      # "Sunday" (хотя есть и другие)
days.max_by {|x| x.length}                      # "Wednesday"
days.minmax_by {|x| x.reverse}                  # ["Friday", "Thursday"]
# В последнем примере результат содержит первый и последний элементы массива,
# буквы которых переставлены "задом наперед".

# Итерирование
# Метод cycle умеет обходить коллекцию более одного раза или даже "бесконечно"
# Параметр задает число циклов, по умолчанию подразумевается бесконечное число:
months = %w[Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec]
months.cycle(2) { |x| puts m }              # всего будет 24 итерации 24
months.cycle { |x| puts x }                 # бесконечный цикл
# Метод each_with_object работает так же, как inject, но в виде дополнительной любезности возвращает
# тот же объект, который был ему передан. Так удается избежать некрасивого решения, когда приходится
# явно возвращать аккумулятор в конце блока
h = Hash.new(0)
result = [1,2,3,4].inject(h) {|acc,n| acc[n] += 1; acc}          # Некрасиво

h = Hash.new(0)
result = [1,2,3,4].each_with_object(h) do |n, acc|
  acc[n] += 1 }                                                  # Так лучше
end

# Извлечение и преобразование. 
# Существуют способы извлекать в массив только части коллекции с помощью методов take и take_while
# Они возвращают список первых элементов коллекции. В первом примере ниже рассматривается хэш, элементом
# такой коллекции является пара ключ-значение, возвращаемая в виде подмассива.
# В следующих примерах те же операции применяются к массивам:
hash = {1 => 2, 3 => 6, 4 => 8, 5 => 10, 7 => 14}
arr1 = hash.take(2)                          # [[1,2], [3,6]]
arr2 = hash.take_while {|k,v| v <= 8 }       # [[1,2], [3,6], [4,8]]
arr3 = arr1.take(1)                          # [[1,2]]
arr4 = arr2.take_while {|x| x[0] < 4 }       # [[1,2], [3,6]]
# Метод drop дополняет take. Он пропускает первые элементы коллекции и возвращает остальные.
# Существует также метод drop_while.
hash = {1 => 2, 3 => 6, 4 => 8, 5 => 10, 7 => 14}
arr1 = hash.drop(2)                          # [[4,8], [5,10], [7 => 14]]
arr2 = hash.take_while {|k,v| v <= 8 }       # [[5,10], [7 => 14]]
# Метод reduce также навеян теми же идеями, что inject. Он применяет бинарную операцию (заданную символом)
# к каждой паре элементов коллекции, но может принять также и блок. Если задано начальное значение 
# аккумулятора, оно и используется, в противном случае начальным значением будет первый элемент коллекции.
range = 3..6
# символ
range.reduce(:*)                             # 3*4*5*6 = 360
# с начальным значением, символ
range.reduce(2, :*)                          # 2*3*4*5*6 = 720
# с начальным значением, блок
range.reduce(10) {|acc, item| acc += item }  # 10+3+4+5+6 = 28
# блок
range.reduce {|acc, item| acc += item }      # 3+4+5+6 = 28
# Отметим, что задать одновременно символ бинарного оператора и блок невозможно.
# Перечисляемые объекты можно также преобразовывать в формат JSON (если затребована библиотека json)
# или в множество (если затребована библиотека set):
require 'set'
require 'json'

array = [3,4,5,6]
p array.to_set             # #<Set: {3, 4, 5, 6}>
p array.to_json            # "[3,4,5,6]"

# Ленивые перечислители.
# Метод lazy объекта Enumerable возвращает специальный объект Enumerator, который вычисляет следующий 
# элемент по мере необходимости. Это позволяет обходить группы, слишком большие для хранения в памяти,
# например, все нечетныые числа от 1 до бесконечности:
enum = (1..Float::INFINITY).each         # Enumerator
lazy = enum.lazy                         # LazyEnumerator по всем целым числам
odds = lazy.select(&:odd?)               # LazyEnumerator по нечетным числам
odds.first(5)                            # [1, 3, 5, 7, 9]
odds.next                                # 1
odds.next                                # 3
# Ленивые перечислители открывают новые возможности для экономии памяти и времени при обходе больших
# коллекций, поэтому рекомендуется внимательно ознакомиться с документацией по классу LazyEnumerator

# Множества
# Чтобы получить в свое распоряжение класс Set, достаточно написать:
require 'set'
# При этом также добавляется метод to_set в модуль Enumerable, так что любой перечисляемый объект 
# становится возможно преобразовать в множество.
# Создать новое множество нетрудно. Метод [] работает почти так же, как и для хэшей. Метод new 
# принимает в качестве необязательных параметров перечисляемый объект и блок. Если блок задан, то он
# выступает в роли "препроцессора" для списка (подобно операции map).
s1 = Set[3,4,5]                          # в математике обозначается {3,4,5}
arr = [3,4,5]
s2 = Set.new(arr)                        # то же самое
s3 = Set.new(arr) {|x| x.to_s }          # множество строк, а не чисел

# Простые операции над множествами
# Для объединения множеств служит метод union (синонимы | и +)
x = Set[1,2,3]
y = Set[3,4,5]

a = x.union(y)                            # Set[1,2,3,4,5]
b = x | y                                 # то же самое
c = x + y                                 # то же самое
# Пересечение множеств вычисляется методом intersection (синоним &):
x = Set[1,2,3]
y = Set[3,4,5]

a = x.intersection(y)                     # Set[3]
b = x & y                                 # то же самое

# В случае бинарных операторов в правой части необязательно должно быть множество.
# Подойдет любой перечисляемый объект, порождающий множество в качестве результата.
# Унарный минус обозначает разность множеств. Это было в разделе 8.1.9
diff = Set[1,2,3] - Set[3,4,5]            # Set[1,2]
# Принадлежность элемента множесту проверяют методы member? или include?, как для массивов.
# Напомним, что порядок операндов противоположен принятому в математике.
Set[1,2,3].include?(2)                    # true
Set[1,2,3].include?(4)                     # false
Set[1,2,3].member?(4)                     # false
# Чтобы проверить, является ли множество пустым, мы вызываем метод empty?, как и в случае массивов.
# Метод clear очищает множество, то есть удаляет из него все элементы.
s = Set[1,2,3,4,5,6]
s.empty?                                  # false
s.clear
s.empty?                                  # true
# Можно проверить, является ли одно множество подмножеством, собственным подмножеством или надмножеством другого.
x = Set[3,4,5]
y = Set[3,4]

x.subset?(y)                              # false
y.subset?(x)                              # true
y.proper_subset?(x)                       # true
x.subset?(x)                              # true
x.proper_subset?(x)                       # false
x.superset?(y)                            # true
# Метод add (синоним <<) добавляет в множество один элемент и обычно возвращает его в качестве значения.
# Метод add? возвращает nil, если такой элемент уже присутствовал в множестве. Метод merge полезен, если
# надо добавить сразу несколько элементов. Все они, конечно, могут изменить состояние вызывающего объекта.
# Метод replace работает так же, как и в случае строки или массива. Наконец, два множества можно сравнить
# на равенство очевидным способом:
Set[3,4,5] == Set[5,4,3]                  # true

# Более сложные операции над множествами.
# Ruby не гарантирует никакой последовательности при обходе множеств, временами можно получить повторяющиеся результаты
# но полагаться на это неразумно
s = Set[1,2,3,4,5]
s.each {|x| puts x; break }               # Выводится 5

# Метод classify подобен методу partition, но с разбиением на несколько частей;
# он послужил источником идеи для реализации вашей версии метода classify в разделе 8.3.3
files = Set.new(Dir["*"])
hash = files.classify do |f|
  if File.size(f) <= 10_000
    :small 
  elsif File.size(f) <= 10_000_000
    :medium 
  else
    :large
  end
end

big_files = hash[:large]                  # big_files - это Set

# Метод divide аналогичен, но вызывает блок, чтобы выяснить "степень общности" элементов,
# и возвращает множество, состоящее из множеств.
# Следующий блок (с арностью 1) разбивает множество на два подмножества, одно из которых содержит четные, а другое - нечетные числа:
require 'set'
numbers = Set[1,2,3,4,5,6,7,8,9,0]
set = numbers.divide{|i| i % 2}
p set          # #<Set: {#<Set: {5,1,7,3,9}>, #<Set: {0,6,2,8,4}>}>

# Простыми числами-близнецами называются простые числа отличающиеся на 2(например, 11 и 13); все
# остальные называются одиночными (например, 23). Следующий код разбивает множество на группы, помещая
#  числа-близнецы в одно и то же подмножестово. В данном случае применяется блок с арностью 2:
primes = Set[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]
set = primes.divide{|i,j| (i-j).abs == 2}
# set is #<Set: { #<Set: {2}>, #<Set: {3, 5, 7}>, #<Set: {11, 13},
# #<Set: {17, 19}>, #<Set: {23}>, #<Set: {29, 31}> }>

# Более строгая реализация стека
# Вот пример простого класса, который хранит внутри себя массив и управляет доступом к этому массиву.
class Stack

  def initialize
    @store = []
  end

  def push(x)
    @store.push(x)
  end

  def pop
    @store.pop
  end

  def peek
    @store.last
  end

  def empty?
    @store.empty?
  end

end
# Мы добавили еще одну опеарацию, которая для массивов не определена; метод peek возвращает элемент,
# находящийся на вершине стека, не выталкивая его.

# Более строгая реализация очереди. Если вы хотите защититься от некорректного доступа к структуре данных,
# рекомендуем поступать аналогично.
class Queue

  def initialize
    @store = []
  end

  def enqueue(x)
    @store << x
  end

  def dequeue
    @store.shift
  end

  def peek
    @store.first
  end

  def length
    @store.length
  end

  def empty?
    @store.empty?
  end

end

# Решение задачи "Ханойская башня" с помощью стека (с тремя дисками)
def towers(list)
  while !list.empty?
    n, src, dst, aux = list.pop
    if n == 1
      puts "Перемещаем диск c #{src} на #{dst}"
    else
      list.push [n-1, aux, dst, src]
      list.push [1, src, dst, aux]
      list.push [n-1, src, aux, dst]
    end
  end
end

list = []
list.push([3, "a", "c", "b"])

towers(list)

# Конечно, классическое решение этой задачи рекурсивно. Но, как отмечалось, тесная связь между алгоритмами
# не должна вызывать удивления, т.к. для рекурсии применяется невидимый системный стек.
def towers(n, src, dst, aux)
  if n == 1
    puts "Перемещаем диск с #{src} на #{dst}"
  else
    towers(n-1, src, aux, dst)
    towers(1, src, dst, aux)
    towers(n-1, aux, dst, src)
  end
end

towers(3, "a", "c", "b")
# Печатается точно такой же результат. Но, рекурсивное решение оказалось в два раза быстрее.

# Обнаружение несбалансированных скобок.
def paren_match(str)
  stack = Stack.new
  lsym = "{[(<"
  rsym = "}])>"
  str.each_char do |sym|
    if lsym.include? sym
      stack.push(sym)
    elsif rsym.include? sym
      top = stack.peek
      if lsym.index(top) != rsym.index(sym)
        return false
      else
        stack.pop
      end
      # Игнорируем символы, отличные от скобок...
    end
  end
  # Убедимся, что стек пуст...
  return stack.empty?
end

str1 = "(((a+b))*((c-d)-(e*f))"
str2 = "[[(a-(b-c))], [[x,y]]]"

paren_match str1                 # false
paren_match str2                 # true

# Использование двоичного дерева как справочной таблицы
class Tree

  # Предполагается, что определения
  # взяты из предыдущего примера...

  def search(x)
    if self.data == x 
      return self
    elsif x < self.data
      return left ? left.search(x) : nil 
    else
      return right ? right.search(x) : nil 
    end
  end

end

keys = [50, 20, 80, 10, 30, 70, 90, 5, 14,
        28, 41, 66, 75, 88, 96]

tree = Tree.new

keys.each {|x| tree.insert(x)}

s1 = tree.search(75)                      # Возвращает ссылку на узел, содержащий 75...

s2 = tree.search(100)                     # Возвращает nil (не найдено)
